<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LZEncoder.java</title>
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700" rel="stylesheet">
</head>
<body>

<div class="container">
    <div id="code_area" class="container_0">
<div>1&emsp;&emsp;/*</div>
<div>2&emsp;&emsp;&nbsp; * LZEncoder</div>
<div>3&emsp;&emsp;&nbsp; *</div>
<div>4&emsp;&emsp;&nbsp; * Authors: Lasse Collin &#60;lasse.collin@tukaani.org></div>
<div>5&emsp;&emsp;&nbsp; *          Igor Pavlov &#60;http://7-zip.org/></div>
<div>6&emsp;&emsp;&nbsp; *</div>
<div>7&emsp;&emsp;&nbsp; * This file has been put into the public domain.</div>
<div>8&emsp;&emsp;&nbsp; * You can do whatever you want with this file.</div>
<div>9&emsp;&emsp;&nbsp; */</div>
<div>10&emsp;&emsp;</div>
<div>11&emsp;&emsp;package org.tukaani.xz.lz;</div>
<div>12&emsp;&emsp;</div>
<div>13&emsp;&emsp;import java.io.IOException;</div>
<div>14&emsp;&emsp;import java.io.OutputStream;</div>
<div>15&emsp;&emsp;</div>
<div style="background-color:limegreen;">16&emsp;&emsp;<b>public abstract class LZEncoder {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>17&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int MF_HC4 = 0x04;</div>
<div>18&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int MF_BT4 = 0x14;</div>
<div>19&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final int matchLenMax;</div>
<div>20&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final int niceLen;</div>
<div>21&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final byte[] buf;</div>
<div>22&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>23&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Number of bytes to keep available before the current byte</div>
<div>24&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * when moving the LZ window.</div>
<div>25&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>26&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private final int keepSizeBefore;</div>
<div>27&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>28&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Number of bytes that must be available, the current byte included,</div>
<div>29&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to make hasEnoughData return true. Flushing and finishing are</div>
<div>30&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * naturally exceptions to this since there cannot be any data after</div>
<div>31&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the end of the uncompressed input.</div>
<div>32&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>33&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private final int keepSizeAfter;</div>
<div>34&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int readPos = -1;</div>
<div>35&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int readLimit = -1;</div>
<div>36&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean finishing = false;</div>
<div>37&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int writePos = 0;</div>
<div>38&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int pendingSize = 0;</div>
<div>39&emsp;&emsp;</div>
<div>40&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>41&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Creates a new LZEncoder. See &#60;code>getInstance&#60;/code>.</div>
<div>42&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>43&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    LZEncoder(int dictSize, int extraSizeBefore, int extraSizeAfter,</div>
<div>44&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              int niceLen, int matchLenMax) {</div>
<div>45&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        buf = new byte[getBufSize(dictSize, extraSizeBefore, extraSizeAfter,</div>
<div>46&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                matchLenMax)];</div>
<div>47&emsp;&emsp;</div>
<div>48&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        keepSizeBefore = extraSizeBefore + dictSize;</div>
<div>49&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        keepSizeAfter = extraSizeAfter + matchLenMax;</div>
<div>50&emsp;&emsp;</div>
<div>51&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.matchLenMax = matchLenMax;</div>
<div>52&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.niceLen = niceLen;</div>
<div>53&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>54&emsp;&emsp;</div>
<div>55&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static void normalize(int[] positions, int normalizationOffset) {</div>
<div style="background-color:limegreen;">56&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for(int i = 0; i &#60; positions.length; ++i) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div style="background-color:limegreen;">57&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if(positions[i] &#60;= normalizationOffset) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>58&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                positions[i] = 0;</div>
<div>59&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>60&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            else {</div>
<div>61&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                positions[i] -= normalizationOffset;</div>
<div>62&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>63&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>64&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>65&emsp;&emsp;</div>
<div>66&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>67&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Gets the size of the LZ window buffer that needs to be allocated.</div>
<div>68&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>69&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static int getBufSize(</div>
<div>70&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int dictSize, int extraSizeBefore, int extraSizeAfter,</div>
<div>71&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int matchLenMax) {</div>
<div>72&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int keepSizeBefore = extraSizeBefore + dictSize;</div>
<div>73&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int keepSizeAfter = extraSizeAfter + matchLenMax;</div>
<div>74&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int reserveSize = Math.min(dictSize / 2 + (256 &#60;&#60; 10), 512 &#60;&#60; 20);</div>
<div>75&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return keepSizeBefore + keepSizeAfter + reserveSize;</div>
<div>76&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>77&emsp;&emsp;</div>
<div>78&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>79&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Gets approximate memory usage of the LZEncoder base structure and</div>
<div>80&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the match finder as kibibytes.</div>
<div>81&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>82&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static int getMemoryUsage(</div>
<div>83&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int dictSize, int extraSizeBefore, int extraSizeAfter,</div>
<div>84&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int matchLenMax, int mf) {</div>
<div>85&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Buffer size + a little extra</div>
<div>86&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int m = getBufSize(dictSize, extraSizeBefore, extraSizeAfter,</div>
<div>87&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                matchLenMax) / 1024 + 10;</div>
<div>88&emsp;&emsp;</div>
<div>89&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        switch (mf) {</div>
<div>90&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            case MF_HC4:</div>
<div>91&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                m += HC4.getMemoryUsage(dictSize);</div>
<div>92&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                break;</div>
<div>93&emsp;&emsp;</div>
<div>94&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            case MF_BT4:</div>
<div>95&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                m += BT4.getMemoryUsage(dictSize);</div>
<div>96&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                break;</div>
<div>97&emsp;&emsp;</div>
<div>98&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            default:</div>
<div>99&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new IllegalArgumentException();</div>
<div>100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>101&emsp;&emsp;</div>
<div>102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return m;</div>
<div>103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>104&emsp;&emsp;</div>
<div>105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Creates a new LZEncoder.</div>
<div>107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p></div>
<div>108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param dictSize        dictionary size</div>
<div>110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param extraSizeBefore number of bytes to keep available in the</div>
<div>111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                        history in addition to dictSize</div>
<div>112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param extraSizeAfter  number of bytes that must be available</div>
<div>113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                        after current position + matchLenMax</div>
<div>114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param niceLen         if a match of at least &#60;code>niceLen&#60;/code></div>
<div>115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                        bytes is found, be happy with it and don't</div>
<div>116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                        stop looking for longer matches</div>
<div>117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param matchLenMax     don't test for matches longer than</div>
<div>118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                        &#60;code>matchLenMax&#60;/code> bytes</div>
<div>119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param mf              match finder ID</div>
<div>120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param depthLimit      match finder search depth limit</div>
<div>121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static LZEncoder getInstance(</div>
<div>123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int dictSize, int extraSizeBefore, int extraSizeAfter,</div>
<div>124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int niceLen, int matchLenMax, int mf, int depthLimit) {</div>
<div style="background-color:limegreen;">125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        switch (mf) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            case MF_HC4:</div>
<div>127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return new HC4(dictSize, extraSizeBefore, extraSizeAfter,</div>
<div>128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        niceLen, matchLenMax, depthLimit);</div>
<div>129&emsp;&emsp;</div>
<div>130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            case MF_BT4:</div>
<div>131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return new BT4(dictSize, extraSizeBefore, extraSizeAfter,</div>
<div>132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        niceLen, matchLenMax, depthLimit);</div>
<div>133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>134&emsp;&emsp;</div>
<div>135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throw new IllegalArgumentException();</div>
<div>136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>137&emsp;&emsp;</div>
<div>138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets a preset dictionary. If a preset dictionary is wanted, this</div>
<div>140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * function must be called immediately after creating the LZEncoder</div>
<div>141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * before any data has been encoded.</div>
<div>142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setPresetDict(int dictSize, byte[] presetDict) {</div>
<div style="background-color:limegreen;">144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !isStarted();&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div style="background-color:limegreen;">145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert writePos == 0;&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>146&emsp;&emsp;</div>
<div style="background-color:limegreen;">147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if(presetDict != null) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // If the preset dictionary buffer is bigger than the dictionary</div>
<div>149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // size, copy only the tail of the preset dictionary.</div>
<div>150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int copySize = Math.min(presetDict.length, dictSize);</div>
<div>151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int offset = presetDict.length - copySize;</div>
<div>152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.arraycopy(presetDict, offset, buf, 0, copySize);</div>
<div>153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            writePos += copySize;</div>
<div>154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            skip(copySize);</div>
<div>155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>157&emsp;&emsp;</div>
<div>158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Moves data from the end of the buffer to the beginning, discarding</div>
<div>160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * old data and making space for new input.</div>
<div>161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void moveWindow() {</div>
<div>163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Align the move to a multiple of 16 bytes. LZMA2 needs this</div>
<div>164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // because it uses the lowest bits from readPos to get the</div>
<div>165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // alignment of the uncompressed data.</div>
<div>166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int moveOffset = (readPos + 1 - keepSizeBefore) & ~15;</div>
<div>167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int moveSize = writePos - moveOffset;</div>
<div>168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.arraycopy(buf, moveOffset, buf, 0, moveSize);</div>
<div>169&emsp;&emsp;</div>
<div>170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        readPos -= moveOffset;</div>
<div>171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        readLimit -= moveOffset;</div>
<div>172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        writePos -= moveOffset;</div>
<div>173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>174&emsp;&emsp;</div>
<div>175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Copies new data into the LZEncoder's buffer.</div>
<div>177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int fillWindow(byte[] in, int off, int len) {</div>
<div style="background-color:limegreen;">179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !finishing;&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>180&emsp;&emsp;</div>
<div>181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Move the sliding window if needed.</div>
<div style="background-color:limegreen;">182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if(readPos >= buf.length - keepSizeAfter) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            moveWindow();</div>
<div>184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>185&emsp;&emsp;</div>
<div>186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Try to fill the dictionary buffer. If it becomes full,</div>
<div>187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // some of the input bytes may be left unused.</div>
<div style="background-color:limegreen;">188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if(len > buf.length - writePos) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            len = buf.length - writePos;</div>
<div>190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>191&emsp;&emsp;</div>
<div>192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.arraycopy(in, off, buf, writePos, len);</div>
<div>193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        writePos += len;</div>
<div>194&emsp;&emsp;</div>
<div>195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Set the new readLimit but only if there's enough data to allow</div>
<div>196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // encoding of at least one more byte.</div>
<div style="background-color:limegreen;">197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if(writePos >= keepSizeAfter) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            readLimit = writePos - keepSizeAfter;</div>
<div>199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>200&emsp;&emsp;</div>
<div>201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        processPendingBytes();</div>
<div>202&emsp;&emsp;</div>
<div>203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Tell the caller how much input we actually copied into</div>
<div>204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // the dictionary.</div>
<div>205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return len;</div>
<div>206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>207&emsp;&emsp;</div>
<div>208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Process pending bytes remaining from preset dictionary initialization</div>
<div>210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * or encoder flush operation.</div>
<div>211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void processPendingBytes() {</div>
<div>213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // After flushing or setting a preset dictionary there will be</div>
<div>214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // pending data that hasn't been ran through the match finder yet.</div>
<div>215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Run it through the match finder now if there is enough new data</div>
<div>216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // available (readPos &#60; readLimit) that the encoder may encode at</div>
<div>217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // least one more input byte. This way we don't waste any time</div>
<div>218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // looping in the match finder (and marking the same bytes as</div>
<div>219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // pending again) if the application provides very little new data</div>
<div>220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // per write call.</div>
<div style="background-color:limegreen;">221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if(pendingSize > 0 && readPos &#60; readLimit) {&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            readPos -= pendingSize;</div>
<div>223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int oldPendingSize = pendingSize;</div>
<div>224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            pendingSize = 0;</div>
<div>225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            skip(oldPendingSize);</div>
<div style="background-color:limegreen;">226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert pendingSize &#60; oldPendingSize;&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>229&emsp;&emsp;</div>
<div>230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns true if at least one byte has already been run through</div>
<div>232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the match finder.</div>
<div>233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isStarted() {</div>
<div style="background-color:limegreen;">235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return readPos != -1;&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>237&emsp;&emsp;</div>
<div>238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Marks that all the input needs to be made available in</div>
<div>240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the encoded output.</div>
<div>241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setFlushing() {</div>
<div>243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        readLimit = writePos - 1;</div>
<div>244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        processPendingBytes();</div>
<div>245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>246&emsp;&emsp;</div>
<div>247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Marks that there is no more input remaining. The read position</div>
<div>249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * can be advanced until the end of the data.</div>
<div>250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setFinishing() {</div>
<div>252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        readLimit = writePos - 1;</div>
<div>253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        finishing = true;</div>
<div>254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        processPendingBytes();</div>
<div>255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>256&emsp;&emsp;</div>
<div>257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Tests if there is enough input available to let the caller encode</div>
<div>259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * at least one more byte.</div>
<div>260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean hasEnoughData(int alreadyReadLen) {</div>
<div style="background-color:limegreen;">262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return readPos - alreadyReadLen &#60; readLimit;&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>264&emsp;&emsp;</div>
<div>265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void copyUncompressed(OutputStream out, int backward, int len)</div>
<div>266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throws IOException {</div>
<div>267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        out.write(buf, readPos + 1 - backward, len);</div>
<div>268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>269&emsp;&emsp;</div>
<div>270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the number of bytes available, including the current byte.</div>
<div>272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p></div>
<div>273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note that the result is undefined if &#60;code>getMatches&#60;/code> or</div>
<div>274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;code>skip&#60;/code> hasn't been called yet and no preset dictionary</div>
<div>275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is being used.</div>
<div>276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getAvail() {</div>
<div style="background-color:limegreen;">278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isStarted();&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return writePos - readPos;</div>
<div>280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>281&emsp;&emsp;</div>
<div>282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Gets the lowest four bits of the absolute offset of the current byte.</div>
<div>284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Bits other than the lowest four are undefined.</div>
<div>285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getPos() {</div>
<div>287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return readPos;</div>
<div>288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>289&emsp;&emsp;</div>
<div>290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Gets the byte from the given backward offset.</div>
<div>292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p></div>
<div>293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The current byte is at &#60;code>0&#60;/code>, the previous byte</div>
<div>294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * at &#60;code>1&#60;/code> etc. To get a byte at zero-based distance,</div>
<div>295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * use &#60;code>getByte(dist + 1)&#60;code>.</div>
<div>296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p></div>
<div>297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This function is equivalent to &#60;code>getByte(0, backward)&#60;/code>.</div>
<div>298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getByte(int backward) {</div>
<div>300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return buf[readPos - backward] & 0xFF;</div>
<div>301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>302&emsp;&emsp;</div>
<div>303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Gets the byte from the given forward minus backward offset.</div>
<div>305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The forward offset is added to the current position. This lets</div>
<div>306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * one read bytes ahead of the current byte.</div>
<div>307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getByte(int forward, int backward) {</div>
<div>309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return buf[readPos + forward - backward] & 0xFF;</div>
<div>310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>311&emsp;&emsp;</div>
<div>312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the length of a match at the given distance.</div>
<div>314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param dist     zero-based distance of the match to test</div>
<div>316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param lenLimit don't test for a match longer than this</div>
<div>317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return length of the match; it is in the range [0, lenLimit]</div>
<div>318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getMatchLen(int dist, int lenLimit) {</div>
<div>320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int backPos = readPos - dist - 1;</div>
<div>321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int len = 0;</div>
<div>322&emsp;&emsp;</div>
<div style="background-color:limegreen;">323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        while (len &#60; lenLimit && buf[readPos + len] == buf[backPos + len])&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ++len;</div>
<div>325&emsp;&emsp;</div>
<div>326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return len;</div>
<div>327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>328&emsp;&emsp;</div>
<div>329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the length of a match at the given distance and forward offset.</div>
<div>331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param forward  forward offset</div>
<div>333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param dist     zero-based distance of the match to test</div>
<div>334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param lenLimit don't test for a match longer than this</div>
<div>335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return length of the match; it is in the range [0, lenLimit]</div>
<div>336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getMatchLen(int forward, int dist, int lenLimit) {</div>
<div>338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int curPos = readPos + forward;</div>
<div>339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int backPos = curPos - dist - 1;</div>
<div>340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int len = 0;</div>
<div>341&emsp;&emsp;</div>
<div style="background-color:limegreen;">342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        while (len &#60; lenLimit && buf[curPos + len] == buf[backPos + len])&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ++len;</div>
<div>344&emsp;&emsp;</div>
<div>345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return len;</div>
<div>346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>347&emsp;&emsp;</div>
<div>348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Verifies that the matches returned by the match finder are valid.</div>
<div>350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This is meant to be used in an assert statement. This is totally</div>
<div>351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * useless for actual encoding since match finder's results should</div>
<div>352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * naturally always be valid if it isn't broken.</div>
<div>353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param matches return value from &#60;code>getMatches&#60;/code></div>
<div>355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if matches are valid, false if match finder is broken</div>
<div>356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean verifyMatches(Matches matches) {</div>
<div>358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int lenLimit = Math.min(getAvail(), matchLenMax);</div>
<div>359&emsp;&emsp;</div>
<div style="background-color:limegreen;">360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for(int i = 0; i &#60; matches.count; ++i)&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div style="background-color:limegreen;">361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if(getMatchLen(matches.dist[i], lenLimit) != matches.len[i]) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div>362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return false;</div>
<div>363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>364&emsp;&emsp;</div>
<div>365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>367&emsp;&emsp;</div>
<div>368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Moves to the next byte, checks if there is enough input available,</div>
<div>370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and returns the amount of input available.</div>
<div>371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param requiredForFlushing  minimum number of available bytes when</div>
<div>373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                             flushing; encoding may be continued with</div>
<div>374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                             new input after flushing</div>
<div>375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param requiredForFinishing minimum number of available bytes when</div>
<div>376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                             finishing; encoding must not be continued</div>
<div>377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                             after finishing or the match finder state</div>
<div>378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *                             may be corrupt</div>
<div>379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the number of bytes available or zero if there</div>
<div>380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is not enough input available</div>
<div>381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int movePos(int requiredForFlushing, int requiredForFinishing) {</div>
<div style="background-color:limegreen;">383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert requiredForFlushing >= requiredForFinishing;&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>384&emsp;&emsp;</div>
<div>385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ++readPos;</div>
<div>386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int avail = writePos - readPos;</div>
<div>387&emsp;&emsp;</div>
<div style="background-color:limegreen;">388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if(avail &#60; requiredForFlushing) {&nbsp;&#8594; [GZIPCOMPRESSOR]</b></div>
<div style="background-color:limegreen;">389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if(avail &#60; requiredForFinishing || !finishing) {&nbsp;&#8594; [GZIPCOMPRESSOR] & [GZIPCOMPRESSOR]</b></div>
<div>390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ++pendingSize;</div>
<div>391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                avail = 0;</div>
<div>392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>394&emsp;&emsp;</div>
<div>395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return avail;</div>
<div>396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>397&emsp;&emsp;</div>
<div>398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Runs match finder for the next byte and returns the matches found.</div>
<div>400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public abstract Matches getMatches();</div>
<div>402&emsp;&emsp;</div>
<div>403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Skips the given number of bytes in the match finder.</div>
<div>405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public abstract void skip(int len);</div>
<div>407&emsp;&emsp;}</div>
</div>
</div>
</body>
</html>