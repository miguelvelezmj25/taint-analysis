<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FileSummaryLN.java</title>
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700" rel="stylesheet">
</head>
<body>

<div class="container">
    <div id="code_area" class="container_0">
<div>1&emsp;&emsp;/*-</div>
<div>2&emsp;&emsp;&nbsp; * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</div>
<div>3&emsp;&emsp;&nbsp; *</div>
<div>4&emsp;&emsp;&nbsp; * This file was distributed by Oracle as part of a version of Oracle Berkeley</div>
<div>5&emsp;&emsp;&nbsp; * DB Java Edition made available at:</div>
<div>6&emsp;&emsp;&nbsp; *</div>
<div>7&emsp;&emsp;&nbsp; * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</div>
<div>8&emsp;&emsp;&nbsp; *</div>
<div>9&emsp;&emsp;&nbsp; * Please see the LICENSE file included in the top-level directory of the</div>
<div>10&emsp;&emsp;&nbsp; * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</div>
<div>11&emsp;&emsp;&nbsp; * license and additional information.</div>
<div>12&emsp;&emsp;&nbsp; */</div>
<div>13&emsp;&emsp;</div>
<div>14&emsp;&emsp;package berkeley.com.sleepycat.je.tree;</div>
<div>15&emsp;&emsp;</div>
<div>16&emsp;&emsp;import java.nio.ByteBuffer;</div>
<div>17&emsp;&emsp;</div>
<div>18&emsp;&emsp;import berkeley.com.sleepycat.je.DatabaseException;</div>
<div>19&emsp;&emsp;import berkeley.com.sleepycat.je.cleaner.FileSummary;</div>
<div>20&emsp;&emsp;import berkeley.com.sleepycat.je.cleaner.PackedOffsets;</div>
<div>21&emsp;&emsp;import berkeley.com.sleepycat.je.cleaner.TrackedFileSummary;</div>
<div>22&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.DatabaseImpl;</div>
<div>23&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.MemoryBudget;</div>
<div>24&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogEntryType;</div>
<div>25&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogUtils;</div>
<div>26&emsp;&emsp;import berkeley.com.sleepycat.je.log.Loggable;</div>
<div>27&emsp;&emsp;import berkeley.com.sleepycat.utilint.StringUtils;</div>
<div>28&emsp;&emsp;</div>
<div>29&emsp;&emsp;/**</div>
<div>30&emsp;&emsp;&nbsp; * A FileSummaryLN represents a Leaf Node in the UtilizationProfile database.</div>
<div>31&emsp;&emsp;&nbsp; *</div>
<div>32&emsp;&emsp;&nbsp; * &#60;p>The contents of the FileSummaryLN are not fixed until the moment at which</div>
<div>33&emsp;&emsp;&nbsp; * the LN is added to the log.  A base summary object contains the summary last</div>
<div>34&emsp;&emsp;&nbsp; * added to the log.  A tracked summary object contains live summary info being</div>
<div>35&emsp;&emsp;&nbsp; * updated in real time.  The tracked summary is added to the base summary just</div>
<div>36&emsp;&emsp;&nbsp; * before logging it, and then the tracked summary is reset.  This ensures that</div>
<div>37&emsp;&emsp;&nbsp; * the logged summary will accurately reflect the totals calculated at the</div>
<div>38&emsp;&emsp;&nbsp; * point in the log where the LN is added.&#60;/p></div>
<div>39&emsp;&emsp;&nbsp; *</div>
<div>40&emsp;&emsp;&nbsp; * &#60;p>This is all done in the writeToLog method, which operates under the log</div>
<div>41&emsp;&emsp;&nbsp; * write latch.  All utilization tracking must be done under the log write</div>
<div>42&emsp;&emsp;&nbsp; * latch.&#60;/p></div>
<div>43&emsp;&emsp;&nbsp; *</div>
<div>44&emsp;&emsp;&nbsp; * &#60;p>In record version 1, obsolete offset tracking was added and multiple</div>
<div>45&emsp;&emsp;&nbsp; * records are stored for a single file rather than a single record.  Each</div>
<div>46&emsp;&emsp;&nbsp; * record contains the offsets that were tracked since the last record was</div>
<div>47&emsp;&emsp;&nbsp; * written.</div>
<div>48&emsp;&emsp;&nbsp; *</div>
<div>49&emsp;&emsp;&nbsp; * &#60;p>The key is 8 bytes: 4 bytes for the file number followed by 4 bytes for</div>
<div>50&emsp;&emsp;&nbsp; * the sequence number.  The lowest valued key for a given file contains the</div>
<div>51&emsp;&emsp;&nbsp; * most recent summary information, while to get a complete list of obsolete</div>
<div>52&emsp;&emsp;&nbsp; * offsets all records for the file must be read.  A range search using just</div>
<div>53&emsp;&emsp;&nbsp; * the first 4 bytes can be used to find the most recent record -- this is</div>
<div>54&emsp;&emsp;&nbsp; * possible because the sequence number values are decreasing over time for a</div>
<div>55&emsp;&emsp;&nbsp; * given file.  Here are example keys for three summary records in file 1:&#60;/p></div>
<div>56&emsp;&emsp;&nbsp; *</div>
<div>57&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>58&emsp;&emsp;&nbsp; * (file=1, sequence=Integer.MAX_VALUE - 300)</div>
<div>59&emsp;&emsp;&nbsp; * (file=1, sequence=Integer.MAX_VALUE - 200)</div>
<div>60&emsp;&emsp;&nbsp; * (file=1, sequence=Integer.MAX_VALUE - 100)</div>
<div>61&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>62&emsp;&emsp;&nbsp; *</div>
<div>63&emsp;&emsp;&nbsp; * &#60;p>The sequence number is the number of obsolete entries counted so far,</div>
<div>64&emsp;&emsp;&nbsp; * subtracted from Integer.MAX_VALUE to cause the latest written record to have</div>
<div>65&emsp;&emsp;&nbsp; * the lowest key.&#60;/p></div>
<div>66&emsp;&emsp;&nbsp; *</div>
<div>67&emsp;&emsp;&nbsp; * &#60;h3>Log version information&#60;/h3></div>
<div>68&emsp;&emsp;&nbsp; * &#60;p>Version 0: Keys are old format strings. No obsolete detail is</div>
<div>69&emsp;&emsp;&nbsp; * present.&#60;/p></div>
<div>70&emsp;&emsp;&nbsp; * &#60;p>Version 1: Keys are two 4 byte integers: {file, sequence}.  Obsolete</div>
<div>71&emsp;&emsp;&nbsp; * detail is present.  Some offsets may be invalid if RMW was used.&#60;/p></div>
<div>72&emsp;&emsp;&nbsp; * &#60;p>Version 2: The RMW problem with invalid offsets was corrected.  There is</div>
<div>73&emsp;&emsp;&nbsp; * no data format change; all versions of JE 2.0.x can read version 1.&#60;/p></div>
<div>74&emsp;&emsp;&nbsp; *</div>
<div>75&emsp;&emsp;&nbsp; * @see com.sleepycat.je.cleaner.UtilizationProfile</div>
<div>76&emsp;&emsp;&nbsp; */</div>
<div style="background-color:limegreen;">77&emsp;&emsp;<b>public final class FileSummaryLN extends LN {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>78&emsp;&emsp;</div>
<div>79&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String BEGIN_TAG = "&#60;fileSummaryLN>";</div>
<div>80&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String END_TAG = "&#60;/fileSummaryLN>";</div>
<div>81&emsp;&emsp;</div>
<div>82&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int extraMarshaledMemorySize;</div>
<div>83&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private final FileSummary baseSummary;</div>
<div>84&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private TrackedFileSummary trackedSummary;</div>
<div>85&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private PackedOffsets obsoleteOffsets;</div>
<div>86&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean needOffsets;</div>
<div>87&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int entryVersion;</div>
<div>88&emsp;&emsp;</div>
<div>89&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>90&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Creates a new LN with a given base summary.</div>
<div>91&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>92&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public FileSummaryLN(FileSummary baseSummary) {</div>
<div>93&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super(new byte[0]);</div>
<div style="background-color:limegreen;">94&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert baseSummary != null;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>95&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.baseSummary = baseSummary;</div>
<div>96&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        obsoleteOffsets = new PackedOffsets();</div>
<div>97&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryVersion = -1;</div>
<div>98&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>99&emsp;&emsp;</div>
<div>100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Creates an empty LN to be filled in from the log.</div>
<div>102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public FileSummaryLN() {</div>
<div>104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        baseSummary = new FileSummary();</div>
<div>105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        obsoleteOffsets = new PackedOffsets();</div>
<div>106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>107&emsp;&emsp;</div>
<div>108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Creates a deleted FileSummaryLN.</div>
<div>110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param deletedMarker makes this constructor signature unique, the value</div>
<div>112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * passed doesn't matter.</div>
<div>113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private FileSummaryLN(boolean deletedMarker) {</div>
<div>115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super((byte[]) null);</div>
<div>116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        baseSummary = new FileSummary();</div>
<div>117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        obsoleteOffsets = new PackedOffsets();</div>
<div>118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>119&emsp;&emsp;</div>
<div>120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Creates a deleted FileSummaryLN.</div>
<div>122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static LN makeDeletedLN() {</div>
<div>124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return new FileSummaryLN(true /*deletedMarker*/);</div>
<div>125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>126&emsp;&emsp;</div>
<div>127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the live summary object that will be added to the base summary at</div>
<div>129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the time the LN is logged.</div>
<div>130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setTrackedSummary(TrackedFileSummary trackedSummary) {</div>
<div>132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.trackedSummary = trackedSummary;</div>
<div>133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        needOffsets = true;</div>
<div>134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>135&emsp;&emsp;</div>
<div>136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the tracked summary, or null if setTrackedSummary was not</div>
<div>138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * called.</div>
<div>139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public TrackedFileSummary getTrackedSummary() {</div>
<div>141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return trackedSummary;</div>
<div>142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>143&emsp;&emsp;</div>
<div>144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the base summary for the file that is stored in the LN.</div>
<div>146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public FileSummary getBaseSummary() {</div>
<div>148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return baseSummary;</div>
<div>149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>150&emsp;&emsp;</div>
<div>151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the obsolete offsets for the file.</div>
<div>153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public PackedOffsets getObsoleteOffsets() {</div>
<div>155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return obsoleteOffsets;</div>
<div>156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>157&emsp;&emsp;</div>
<div>158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns true if the given key for this LN is a String file number key.</div>
<div>160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For the old version of the LN there will be a single record per file.</div>
<div>161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If this is a version 0 log entry, the key is a string.  However, such an</div>
<div>163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * LN may be migrated by the cleaner, in which case the version will be 1</div>
<div>164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * or greater [#13061].  In the latter case, we can distinguish a string</div>
<div>165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * key by:</div>
<div>166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 1) If the key is not 8 bytes long, it has to be a string key.</div>
<div>168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 2) If the key is 8 bytes long, but bytes[4] is ascii "0" to "9", then it</div>
<div>170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * must be a string key.  bytes[4] to bytes[7] are a sequence number that</div>
<div>171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is the number of log entries counted.  For this number to be greater</div>
<div>172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * than 0x30000000, the binary value of 4 digits starting with ascii "0",</div>
<div>173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * over 400 million log entries would have to occur in a single file; this</div>
<div>174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * should never happen.</div>
<div>175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note that having to rely on method (2) is unlikely.  A string key will</div>
<div>177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * only be 8 bytes if the file number reach 8 decimal digits (10,000,000 to</div>
<div>178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 99,999,999).  This is a very large file number and unlikely to have</div>
<div>179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * occurred using JE 1.7.1 or earlier.</div>
<div>180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In summary, the only time the algorithm here could fail is if there were</div>
<div>182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * more than 400 million log entries per file, and more than 10 million</div>
<div>183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * were written with JE 1.7.1 or earlier.</div>
<div>184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static boolean hasStringKey(byte[] bytes) {</div>
<div>186&emsp;&emsp;</div>
<div style="background-color:limegreen;">187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bytes.length != 8) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL]</b></div>
<div>188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>           return (bytes[4] >= '0' && bytes[4] &#60;= '9');&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL] & [ALLOWCREATE, TRANSACTIONAL]</b></div>
<div>191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>193&emsp;&emsp;</div>
<div>194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Convert a FileSummaryLN key from a byte array to a long.  The file</div>
<div>196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * number is the first 4 bytes of the key.</div>
<div>197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static long getFileNumber(byte[] bytes) {</div>
<div>199&emsp;&emsp;</div>
<div style="background-color:limegreen;">200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (hasStringKey(bytes)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL]</b></div>
<div>201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return Long.valueOf(StringUtils.fromUTF8(bytes)).longValue();</div>
<div>202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ByteBuffer buf = ByteBuffer.wrap(bytes);</div>
<div>204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return LogUtils.readIntMSB(buf) & 0xFFFFFFFFL;</div>
<div>205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>207&emsp;&emsp;</div>
<div>208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the sequence number from the byte array. The sequence number is the</div>
<div>210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * last 4 bytes of the key.</div>
<div>211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static long getSequence(byte[] bytes) {</div>
<div>213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (hasStringKey(bytes)) {</div>
<div>214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ByteBuffer buf = ByteBuffer.wrap(bytes);</div>
<div>217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.readIntMSB(buf);</div>
<div>218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return </div>
<div>219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (Integer.MAX_VALUE - LogUtils.readIntMSB(buf)) & 0xFFFFFFFFL;</div>
<div>220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>222&emsp;&emsp;</div>
<div>223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the first 4 bytes of the key for the given file number.  This</div>
<div>225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * can be used to do a range search to find the first LN for the file.</div>
<div>226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static byte[] makePartialKey(long fileNum) {</div>
<div>228&emsp;&emsp;</div>
<div>229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] bytes = new byte[4];</div>
<div>230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ByteBuffer buf = ByteBuffer.wrap(bytes);</div>
<div>231&emsp;&emsp;</div>
<div>232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writeIntMSB(buf, (int) fileNum);</div>
<div>233&emsp;&emsp;</div>
<div>234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return bytes;</div>
<div>235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>236&emsp;&emsp;</div>
<div>237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the full two-part key for a given file number and unique</div>
<div>239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * sequence.  This can be used to insert a new LN.</div>
<div>240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param sequence is a unique identifier for the LN for the given file,</div>
<div>242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and must be greater than the last sequence.</div>
<div>243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static byte[] makeFullKey(long fileNum, int sequence) {</div>
<div>245&emsp;&emsp;</div>
<div style="background-color:limegreen;">246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert sequence >= 0;&nbsp;&#8594; [ALLOWCREATE] & [ALLOWCREATE]</b></div>
<div>247&emsp;&emsp;</div>
<div>248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] bytes = new byte[8];</div>
<div>249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ByteBuffer buf = ByteBuffer.wrap(bytes);</div>
<div>250&emsp;&emsp;</div>
<div>251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * The sequence is subtracted from MAX_VALUE so that increasing values</div>
<div>253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * will be sorted first.  This allows a simple range search to find the</div>
<div>254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * most recent value.</div>
<div>255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writeIntMSB(buf, (int) fileNum);</div>
<div>257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writeIntMSB(buf, Integer.MAX_VALUE - sequence);</div>
<div>258&emsp;&emsp;</div>
<div>259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return bytes;</div>
<div>260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>261&emsp;&emsp;</div>
<div>262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Initialize a node that has been faulted in from the log.  If this FSLN</div>
<div>264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * contains version 1 offsets that can be incorrect when RMW was used, and</div>
<div>265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if je.cleaner.rmwFix is enabled, discard the offsets.  [#13158]</div>
<div>266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void postFetchInit(DatabaseImpl db, long sourceLsn)</div>
<div>269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>270&emsp;&emsp;</div>
<div>271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.postFetchInit(db, sourceLsn);</div>
<div>272&emsp;&emsp;</div>
<div style="background-color:limegreen;">273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryVersion == 1 &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            db.getEnv().getCleaner().isRMWFixEnabled()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            obsoleteOffsets = new PackedOffsets();</div>
<div>276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>278&emsp;&emsp;</div>
<div>279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Dumping</div>
<div>281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>282&emsp;&emsp;</div>
<div>283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String toString() {</div>
<div>285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return dumpString(0, true);</div>
<div>286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>287&emsp;&emsp;</div>
<div>288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String beginTag() {</div>
<div>290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return BEGIN_TAG;</div>
<div>291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>292&emsp;&emsp;</div>
<div>293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String endTag() {</div>
<div>295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return END_TAG;</div>
<div>296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>297&emsp;&emsp;</div>
<div>298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String dumpString(int nSpaces, boolean dumpTags) {</div>
<div>300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        StringBuilder sb = new StringBuilder();</div>
<div>301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(super.dumpString(nSpaces, dumpTags));</div>
<div>302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div style="background-color:limegreen;">303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isDeleted()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(baseSummary.toString());</div>
<div>305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(obsoleteOffsets.toString());</div>
<div>306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return sb.toString();</div>
<div>308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>309&emsp;&emsp;</div>
<div>310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Dump additional fields. Done this way so the additional info can</div>
<div>312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be within the XML tags defining the dumped log entry.</div>
<div>313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected void dumpLogAdditional(StringBuilder sb, boolean verbose) {</div>
<div>316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (!isDeleted()) {</div>
<div>317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            baseSummary.dumpLog(sb, true);</div>
<div>318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (verbose) {</div>
<div>319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                obsoleteOffsets.dumpLog(sb, true);</div>
<div>320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>323&emsp;&emsp;</div>
<div>324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Logging</div>
<div>326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>327&emsp;&emsp;</div>
<div>328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return the correct log type for a FileSummaryLN. </div>
<div>330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note: FileSummaryLN will never be transactional.</div>
<div>332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected LogEntryType getLogType(boolean isInsert,</div>
<div>335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                      boolean isTransactional) {</div>
<div style="background-color:limegreen;">336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !isTransactional : "Txnl access to UP db not allowed";&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>337&emsp;&emsp;</div>
<div>338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return LogEntryType.LOG_FILESUMMARYLN;</div>
<div>339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>340&emsp;&emsp;</div>
<div>341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This log entry type is configured to perform marshaling (getLogSize and</div>
<div>343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * writeToLog) under the write log mutex.  Otherwise, the size could change</div>
<div>344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * in between calls to these two methods as the result of utilizaton</div>
<div>345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * tracking.</div>
<div>346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getLogSize(final int logVersion, final boolean forReplication) {</div>
<div>349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int size = super.getLogSize(logVersion, forReplication);</div>
<div style="background-color:limegreen;">350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isDeleted()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += baseSummary.getLogSize();</div>
<div>352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getOffsets();</div>
<div>353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += obsoleteOffsets.getLogSize();</div>
<div>354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return size;</div>
<div>356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>357&emsp;&emsp;</div>
<div>358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void writeToLog(final ByteBuffer logBuffer,</div>
<div>360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           final int logVersion,</div>
<div>361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           final boolean forReplication) {</div>
<div>362&emsp;&emsp;</div>
<div>363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Add the tracked (live) summary to the base summary before writing it</div>
<div>365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * to the log, and reset the tracked summary.  When deleting the LN,</div>
<div>366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the tracked summary is cleared explicitly and will be null.</div>
<div>367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (trackedSummary != null && !isDeleted()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            baseSummary.add(trackedSummary);</div>
<div>370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getOffsets();</div>
<div>371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Reset the totals to zero and clear the tracked offsets. */</div>
<div>372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            trackedSummary.reset();</div>
<div>373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>374&emsp;&emsp;</div>
<div>375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.writeToLog(logBuffer, logVersion, forReplication);</div>
<div>376&emsp;&emsp;</div>
<div style="background-color:limegreen;">377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isDeleted()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            baseSummary.writeToLog(logBuffer);</div>
<div>379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            obsoleteOffsets.writeToLog(logBuffer);</div>
<div>380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>382&emsp;&emsp;</div>
<div>383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void readFromLog(ByteBuffer itemBuffer, int entryVersion) {</div>
<div>385&emsp;&emsp;</div>
<div>386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.entryVersion = entryVersion;</div>
<div>387&emsp;&emsp;</div>
<div>388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.readFromLog(itemBuffer, entryVersion);</div>
<div>389&emsp;&emsp;</div>
<div>390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (!isDeleted()) {</div>
<div>391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            baseSummary.readFromLog(itemBuffer, entryVersion);</div>
<div>392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (entryVersion > 0) {</div>
<div>393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                obsoleteOffsets.readFromLog(itemBuffer, entryVersion);</div>
<div>394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>397&emsp;&emsp;</div>
<div>398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Should never be replicated.</div>
<div>400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean logicalEquals(Loggable other) {</div>
<div>403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>405&emsp;&emsp;</div>
<div>406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If tracked offsets may be present, get them so they are ready to be</div>
<div>408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * written to the log.</div>
<div>409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void getOffsets() {</div>
<div style="background-color:limegreen;">411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !isDeleted();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (needOffsets) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long[] offsets = trackedSummary.getObsoleteOffsets();</div>
<div style="background-color:limegreen;">414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (offsets != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int oldSize = obsoleteOffsets.getExtraMemorySize();</div>
<div>416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                obsoleteOffsets.pack(offsets);</div>
<div>417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int newSize = obsoleteOffsets.getExtraMemorySize();</div>
<div>418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                extraMarshaledMemorySize = newSize - oldSize;</div>
<div>419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            needOffsets = false;</div>
<div>421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>423&emsp;&emsp;</div>
<div>424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overrides this method to add space occupied by this object's fields.</div>
<div>426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getMemorySizeIncludedByParent() {</div>
<div>429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return super.getMemorySizeIncludedByParent() +</div>
<div>430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               (MemoryBudget.FILESUMMARYLN_OVERHEAD -</div>
<div>431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                MemoryBudget.LN_OVERHEAD) +</div>
<div>432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               obsoleteOffsets.getExtraMemorySize();</div>
<div>433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>434&emsp;&emsp;</div>
<div>435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Clear out the obsoleteOffsets to save memory when the LN is deleted.</div>
<div>437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void makeDeleted() {</div>
<div>440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.makeDeleted();</div>
<div>441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        obsoleteOffsets = new PackedOffsets();</div>
<div>442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>443&emsp;&emsp;</div>
<div>444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Adds the extra memory used by obsoleteOffsets to the parent BIN memory</div>
<div>446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * size. Must be called after LN is inserted into the BIN and logged,</div>
<div>447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * while the cursor is still positioned on the inserted LN.  The BIN must</div>
<div>448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be latched.  [#17462]</div>
<div>449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p>The obsoleteOffsets memory size is not intially budgeted in the usual</div>
<div>451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * way because PackedOffsets.pack (which changes the memory size) is called</div>
<div>452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * during marshalling (see getOffset).  This amount is not counted in the</div>
<div>453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parent IN size in the usual way, because LN logging / marshalling occurs</div>
<div>454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * after the LN is inserted in the BIN and its memory size has been counted</div>
<div>455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (see CursorImpl.putInternal).&#60;/p></div>
<div>456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p>Note that the tree memory usage cannot be updated directly in</div>
<div>458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * getOffsets because the tree memory usage must always be the sum of all</div>
<div>459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * IN sizes, and it is reset to this sum each checkpoint.&#60;/p></div>
<div>460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void addExtraMarshaledMemorySize(BIN parentBIN) {</div>
<div style="background-color:limegreen;">463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (extraMarshaledMemorySize != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert trackedSummary != null; /* Must be set during the insert. */&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert parentBIN.isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            parentBIN.updateMemorySize(0, extraMarshaledMemorySize);</div>
<div>467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            extraMarshaledMemorySize = 0;</div>
<div>468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>470&emsp;&emsp;</div>
<div>471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void dumpKey(StringBuilder sb, byte[] key) {</div>
<div>473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;fileSummaryLNKey fileNumber=\"0x" + </div>
<div>474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  Long.toHexString(getFileNumber(key)) + "\" ");</div>
<div>475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("sequence=\"0x" + </div>
<div>476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  Long.toHexString(getSequence(key)) + "\"/>");</div>
<div>477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.dumpKey(sb, key);</div>
<div>478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>479&emsp;&emsp;}</div>
</div>
</div>
</body>
</html>