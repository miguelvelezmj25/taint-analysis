<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BIN.java</title>
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700" rel="stylesheet">
</head>
<body>

<div class="container">
    <div id="code_area" class="container_0">
<div>1&emsp;&emsp;/*-</div>
<div>2&emsp;&emsp;&nbsp; * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</div>
<div>3&emsp;&emsp;&nbsp; *</div>
<div>4&emsp;&emsp;&nbsp; * This file was distributed by Oracle as part of a version of Oracle Berkeley</div>
<div>5&emsp;&emsp;&nbsp; * DB Java Edition made available at:</div>
<div>6&emsp;&emsp;&nbsp; *</div>
<div>7&emsp;&emsp;&nbsp; * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</div>
<div>8&emsp;&emsp;&nbsp; *</div>
<div>9&emsp;&emsp;&nbsp; * Please see the LICENSE file included in the top-level directory of the</div>
<div>10&emsp;&emsp;&nbsp; * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</div>
<div>11&emsp;&emsp;&nbsp; * license and additional information.</div>
<div>12&emsp;&emsp;&nbsp; */</div>
<div>13&emsp;&emsp;</div>
<div>14&emsp;&emsp;package berkeley.com.sleepycat.je.tree;</div>
<div>15&emsp;&emsp;</div>
<div>16&emsp;&emsp;import java.util.Arrays;</div>
<div>17&emsp;&emsp;import java.util.Collections;</div>
<div>18&emsp;&emsp;import java.util.Iterator;</div>
<div>19&emsp;&emsp;import java.util.Set;</div>
<div>20&emsp;&emsp;</div>
<div>21&emsp;&emsp;import berkeley.com.sleepycat.je.CacheMode;</div>
<div>22&emsp;&emsp;import berkeley.com.sleepycat.je.DatabaseException;</div>
<div>23&emsp;&emsp;import berkeley.com.sleepycat.je.EnvironmentFailureException;</div>
<div>24&emsp;&emsp;import berkeley.com.sleepycat.je.cleaner.LocalUtilizationTracker;</div>
<div>25&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.CursorImpl;</div>
<div>26&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.DatabaseImpl;</div>
<div>27&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.DbTree;</div>
<div>28&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.EnvironmentFailureReason;</div>
<div>29&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.EnvironmentImpl;</div>
<div>30&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.MemoryBudget;</div>
<div>31&emsp;&emsp;import berkeley.com.sleepycat.je.evictor.OffHeapCache;</div>
<div>32&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogEntryType;</div>
<div>33&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogItem;</div>
<div>34&emsp;&emsp;import berkeley.com.sleepycat.je.log.ReplicationContext;</div>
<div>35&emsp;&emsp;import berkeley.com.sleepycat.je.txn.LockManager;</div>
<div>36&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.DatabaseUtil;</div>
<div>37&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.DbLsn;</div>
<div>38&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.SizeofMarker;</div>
<div>39&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.TinyHashSet;</div>
<div>40&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.VLSN;</div>
<div>41&emsp;&emsp;</div>
<div>42&emsp;&emsp;/**</div>
<div>43&emsp;&emsp;&nbsp; * A BIN represents a Bottom Internal Node in the JE tree.</div>
<div>44&emsp;&emsp;&nbsp; *</div>
<div>45&emsp;&emsp;&nbsp; * BIN-deltas</div>
<div>46&emsp;&emsp;&nbsp; * ==========</div>
<div>47&emsp;&emsp;&nbsp; * A BIN-delta is a BIN with the non-dirty slots omitted. A "full BIN", OTOH</div>
<div>48&emsp;&emsp;&nbsp; * contains all slots.  On disk and in memory, the format of a BIN-delta is the</div>
<div>49&emsp;&emsp;&nbsp; * same as that of a BIN.  In memory, a BIN object is actually a BIN-delta when</div>
<div>50&emsp;&emsp;&nbsp; * the BIN-delta flag is set (IN.isBINDelta).  On disk, the NewBINDelta log</div>
<div>51&emsp;&emsp;&nbsp; * entry type (class BINDeltaLogEntry) is the only thing that distinguishes it</div>
<div>52&emsp;&emsp;&nbsp; * from a full BIN, which has the BIN log entry type.</div>
<div>53&emsp;&emsp;&nbsp; *</div>
<div>54&emsp;&emsp;&nbsp; * BIN-deltas provides two benefits: Reduced writing and reduced memory usage.</div>
<div>55&emsp;&emsp;&nbsp; *</div>
<div>56&emsp;&emsp;&nbsp; * Reduced Writing</div>
<div>57&emsp;&emsp;&nbsp; * ---------------</div>
<div>58&emsp;&emsp;&nbsp; * Logging a BIN-delta rather a full BIN reduces writing significantly.  The</div>
<div>59&emsp;&emsp;&nbsp; * cost, however, is that two reads are necessary to reconstruct a full BIN</div>
<div>60&emsp;&emsp;&nbsp; * from scratch.  The reduced writing is worth this cost, particularly because</div>
<div>61&emsp;&emsp;&nbsp; * less writing means less log cleaning.</div>
<div>62&emsp;&emsp;&nbsp; *</div>
<div>63&emsp;&emsp;&nbsp; * A BIN-delta is logged when 25% or less (configured with EnvironmentConfig</div>
<div>64&emsp;&emsp;&nbsp; * TREE_BIN_DELTA) of the slots in a BIN are dirty. When a BIN-delta is logged,</div>
<div>65&emsp;&emsp;&nbsp; * the dirty flag is cleared on the the BIN in cache.  If more slots are</div>
<div>66&emsp;&emsp;&nbsp; * dirtied and another BIN-delta is logged, it will contain all entries dirtied</div>
<div>67&emsp;&emsp;&nbsp; * since the last full BIN was logged.  In other words, BIN-deltas are</div>
<div>68&emsp;&emsp;&nbsp; * cumulative and not chained, to avoid reading many (more than two) log</div>
<div>69&emsp;&emsp;&nbsp; * entries to reconstruct a full BIN.  The dirty flag on each slot is cleared</div>
<div>70&emsp;&emsp;&nbsp; * only when a full BIN is logged.</div>
<div>71&emsp;&emsp;&nbsp; *</div>
<div>72&emsp;&emsp;&nbsp; * In addition to the cost of fetching two entries on a BIN cache miss, another</div>
<div>73&emsp;&emsp;&nbsp; * drawback of the current approach is that dirtiness propagates upward in the</div>
<div>74&emsp;&emsp;&nbsp; * Btree due to BIN-delta logging, causing repeated logging of upper INs.  The</div>
<div>75&emsp;&emsp;&nbsp; * slot of the parent IN contains the LSN of the most recent BIN-delta or full</div>
<div>76&emsp;&emsp;&nbsp; * BIN that was logged.  A BINDeltaLogEntry in turn contains the LSN of the</div>
<div>77&emsp;&emsp;&nbsp; * last full BIN logged.</div>
<div>78&emsp;&emsp;&nbsp; *</div>
<div>79&emsp;&emsp;&nbsp; *   Historical note:  The pre-JE 5 implementation of OldBINDeltas worked</div>
<div>80&emsp;&emsp;&nbsp; *   differently and had a different cost/benefit trade-off.  When an</div>
<div>81&emsp;&emsp;&nbsp; *   OldBINDelta was logged, its dirty flag was not cleared, causing it to be</div>
<div>82&emsp;&emsp;&nbsp; *   logged repeatedly at every checkpoint.  A full BIN was logged after 10</div>
<div>83&emsp;&emsp;&nbsp; *   deltas, to prevent endless logging of the same BIN.  One benefit of this</div>
<div>84&emsp;&emsp;&nbsp; *   approach is that the BIN's parent IN was not dirtied when logging the</div>
<div>85&emsp;&emsp;&nbsp; *   OldBINDelta, preventing dirtiness from propagating upward.  Another</div>
<div>86&emsp;&emsp;&nbsp; *   benefit is that the OldBINDelta was only processed by recovery, and did</div>
<div>87&emsp;&emsp;&nbsp; *   not have to be fetched to reconstruct a full BIN from scratch on a cache</div>
<div>88&emsp;&emsp;&nbsp; *   miss.  But the cost (the logging of an OldBINDelta every checkpoint, even</div>
<div>89&emsp;&emsp;&nbsp; *   when it hadn't changed since the last time logged) outweighed the</div>
<div>90&emsp;&emsp;&nbsp; *   benefits.  When the current approach was implemented in JE 5, performance</div>
<div>91&emsp;&emsp;&nbsp; *   improved due to less logging.</div>
<div>92&emsp;&emsp;&nbsp; *</div>
<div>93&emsp;&emsp;&nbsp; *   In JE 6, deltas were also maintained in the Btree cache.  This was done to</div>
<div>94&emsp;&emsp;&nbsp; *   provide the reduced memory benefits described in the next section.  The</div>
<div>95&emsp;&emsp;&nbsp; *   log format for a delta was also changed.  The OldBINDelta log format is</div>
<div>96&emsp;&emsp;&nbsp; *   different (not the same as the BIN format) and is supported for backward</div>
<div>97&emsp;&emsp;&nbsp; *   compatibility as the OldBINDeltaLogEntry.  Its log entry type name is</div>
<div>98&emsp;&emsp;&nbsp; *   still BINDelta, which is why the new type is named NewBINDelta (for</div>
<div>99&emsp;&emsp;&nbsp; *   backward compatibility, log entry type names cannot be changed.)  This is</div>
<div>100&emsp;&emsp;&nbsp; *   also why the spelling "BIN-delta" is used to refer to deltas in the new</div>
<div>101&emsp;&emsp;&nbsp; *   approach.  The old BINDelta class was renamed to OldBINDelta and there is</div>
<div>102&emsp;&emsp;&nbsp; *   no longer a class named BINDelta.</div>
<div>103&emsp;&emsp;&nbsp; *</div>
<div>104&emsp;&emsp;&nbsp; * Reduced Memory Usage</div>
<div>105&emsp;&emsp;&nbsp; * --------------------</div>
<div>106&emsp;&emsp;&nbsp; * In the Btree cache, a BIN may be represented as a full BIN or a BIN-delta.</div>
<div>107&emsp;&emsp;&nbsp; * Eviction will mutate a full BIN to a BIN-delta in preference to discarding</div>
<div>108&emsp;&emsp;&nbsp; * the entire BIN. A BIN-delta in cache occupies less memory than a full BIN,</div>
<div>109&emsp;&emsp;&nbsp; * and can be exploited as follows:</div>
<div>110&emsp;&emsp;&nbsp; *</div>
<div>111&emsp;&emsp;&nbsp; *  - When a full BIN is needed, it can be constructed with only one fetch</div>
<div>112&emsp;&emsp;&nbsp; *    rather than two, reducing IO overall.  IN.fetchIN implements this</div>
<div>113&emsp;&emsp;&nbsp; *    optimization.</div>
<div>114&emsp;&emsp;&nbsp; *</div>
<div>115&emsp;&emsp;&nbsp; *  - Certain operations can sometimes be performed using the BIN-delta alone,</div>
<div>116&emsp;&emsp;&nbsp; *    allowing such operations on a given data set to take place using less</div>
<div>117&emsp;&emsp;&nbsp; *    less IO (for a given cache size).</div>
<div>118&emsp;&emsp;&nbsp; *</div>
<div>119&emsp;&emsp;&nbsp; * The latter benefit is not yet implemented.   No user CRUD operations are</div>
<div>120&emsp;&emsp;&nbsp; * currently implemented using BIN-deltas. In the future we plan to implement</div>
<div>121&emsp;&emsp;&nbsp; * the following operations using the BIN-delta alone.</div>
<div>122&emsp;&emsp;&nbsp; *</div>
<div>123&emsp;&emsp;&nbsp; *  - Consider recording deletions in a BIN-delta.  Currently, slot deletion</div>
<div>124&emsp;&emsp;&nbsp; *    prohibits a BIN-delta from being logged.  To record deletion in</div>
<div>125&emsp;&emsp;&nbsp; *    BIN-deltas, slot deletion will have to be deferred until a full BIN is</div>
<div>126&emsp;&emsp;&nbsp; *    logged.</div>
<div>127&emsp;&emsp;&nbsp; *</div>
<div>128&emsp;&emsp;&nbsp; *  - User reads by key, updates and deletions can be implemented if the key</div>
<div>129&emsp;&emsp;&nbsp; *    happens to appear in the BIN-delta.</div>
<div>130&emsp;&emsp;&nbsp; *</div>
<div>131&emsp;&emsp;&nbsp; *  - The Cleaner can migrate an LN if its key happens to appear in the</div>
<div>132&emsp;&emsp;&nbsp; *    BIN-delta.  This is similar to a user update operation, but in a</div>
<div>133&emsp;&emsp;&nbsp; *    different code path.</div>
<div>134&emsp;&emsp;&nbsp; *</div>
<div>135&emsp;&emsp;&nbsp; *  - Insertions, deletions and updates can always be performed in a BIN-delta</div>
<div>136&emsp;&emsp;&nbsp; *    during replica replay, since the Master operation has already determined</div>
<div>137&emsp;&emsp;&nbsp; *    whether the key exists.</div>
<div>138&emsp;&emsp;&nbsp; *</div>
<div>139&emsp;&emsp;&nbsp; *  - Recovery LN redo could also apply insertions, updates and inserts in the</div>
<div>140&emsp;&emsp;&nbsp; *    manner described.</div>
<div>141&emsp;&emsp;&nbsp; *</div>
<div>142&emsp;&emsp;&nbsp; *  - Add idempotent put/delete operations, which can always be applied in a</div>
<div>143&emsp;&emsp;&nbsp; *    BIN-delta.</div>
<div>144&emsp;&emsp;&nbsp; *</div>
<div>145&emsp;&emsp;&nbsp; *  - Store a hash of the keys in the full BIN in the BIN-delta and use it to</div>
<div>146&emsp;&emsp;&nbsp; *    perform the following in the delta:</div>
<div>147&emsp;&emsp;&nbsp; *    - putIfAbsent (true insertion)</div>
<div>148&emsp;&emsp;&nbsp; *    - get/delete/putIfPresent operations that return NOTFOUND</div>
<div>149&emsp;&emsp;&nbsp; *    - to avoid accumulating unnecessary deletions</div>
<div>150&emsp;&emsp;&nbsp; *</div>
<div>151&emsp;&emsp;&nbsp; * However, some internal operations do currently exploit BIN-deltas to avoid</div>
<div>152&emsp;&emsp;&nbsp; * unnecessary IO.  The following are currently implemented.</div>
<div>153&emsp;&emsp;&nbsp; *</div>
<div>154&emsp;&emsp;&nbsp; *  - The Evictor and Checkpointer log a BIN-delta that is present in the</div>
<div>155&emsp;&emsp;&nbsp; *    cache, without having to fetch the full BIN.</div>
<div>156&emsp;&emsp;&nbsp; *</div>
<div>157&emsp;&emsp;&nbsp; *  - The Cleaner can use the BIN-delta to avoid fetching when processing a BIN</div>
<div>158&emsp;&emsp;&nbsp; *    log entry (delta or full) and the BIN is not present in cache,</div>
<div>159&emsp;&emsp;&nbsp; *</div>
<div>160&emsp;&emsp;&nbsp; * To support BIB-delta-aware operations, the IN.fetchIN() and IN.getTarget()</div>
<div>161&emsp;&emsp;&nbsp; * methods may return a BIN delta. IN.getTarget() will return whatever object</div>
<div>162&emsp;&emsp;&nbsp; * is cached under the parent IN, and IN.fetchIN() will do a single I/O to</div>
<div>163&emsp;&emsp;&nbsp; * fetch the most recently log record for the requested BIN, which may be a</div>
<div>164&emsp;&emsp;&nbsp; * full BIN or a delta. Callers of these methods must be prepared to handle</div>
<div>165&emsp;&emsp;&nbsp; * a BIN delta; either doing their operation directly on the delta, if</div>
<div>166&emsp;&emsp;&nbsp; * possible, or mutating the delta to a full BIN by calling</div>
<div>167&emsp;&emsp;&nbsp; * BIN.mutateToFullBIN().</div>
<div>168&emsp;&emsp;&nbsp; */</div>
<div>169&emsp;&emsp;public class BIN extends IN {</div>
<div>170&emsp;&emsp;</div>
<div>171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String BEGIN_TAG = "&#60;bin>";</div>
<div>172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String END_TAG = "&#60;/bin>";</div>
<div>173&emsp;&emsp;</div>
<div>174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used as the "empty rep" for the INLongRep lastLoggedSizes field.</div>
<div>176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minLength is 1 because log sizes are unpredictable.</div>
<div>178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * allowSparseRep is false because all slots have log sizes and less</div>
<div>180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * mutation is better.</div>
<div>181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final INLongRep.EmptyRep EMPTY_LAST_LOGGED_SIZES =</div>
<div>183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        new INLongRep.EmptyRep(1, false);</div>
<div>184&emsp;&emsp;</div>
<div>185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used as the "empty rep" for the INLongRep vlsnCache field.</div>
<div>187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minLength is 5 because VLSNS grow that large fairly quickly, and less</div>
<div>189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * mutation is better. The value 5 accomodates data set sizes up to 100</div>
<div>190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * billion. If we want to improve memory utilization for smaller data sets</div>
<div>191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * or reduce mutation for larger data sets, we could dynamically determine</div>
<div>192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a value based on the last assigned VLSN.</div>
<div>193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * allowSparseRep is false because either all slots typically have VLSNs,</div>
<div>195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * or none do, and less mutation is better.</div>
<div>196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final INLongRep.EmptyRep EMPTY_VLSNS =</div>
<div>198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        new INLongRep.EmptyRep(5, false);</div>
<div>199&emsp;&emsp;</div>
<div>200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used as the "empty rep" for the INLongRep offHeapLNIds field.</div>
<div>202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minLength is 8 because memory IDs are 64-bit pointers.</div>
<div>204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * allowSparseRep is true because some workloads will only load LN IDs for</div>
<div>206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a subset of the LNs in the BIN.</div>
<div>207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final INLongRep.EmptyRep EMPTY_OFFHEAP_LN_IDS =</div>
<div>209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        new INLongRep.EmptyRep(8, true);</div>
<div>210&emsp;&emsp;</div>
<div>211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used as the "empty rep" for the INLongRep expirationValues field.</div>
<div>213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minLength is 1 because we expect most expiration values, which are an</div>
<div>215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * offset from a base day/hour, to fit in one byte.</div>
<div>216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * allowSparseRep is true because some workloads only set TTLs on some of</div>
<div>218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the LNs in a BIN.</div>
<div>219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final INLongRep.EmptyRep EMPTY_EXPIRATION =</div>
<div>221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        new INLongRep.EmptyRep(1, true);</div>
<div>222&emsp;&emsp;</div>
<div>223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The set of cursors that are currently referring to this BIN.</div>
<div>225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This field is set to null when there are no cursors on this BIN.</div>
<div>226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private TinyHashSet&#60;CursorImpl> cursorSet;</div>
<div>228&emsp;&emsp;</div>
<div>229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Support for logging BIN deltas. (Partial BIN logging)</div>
<div>231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>232&emsp;&emsp;</div>
<div>233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If this is a delta, fullBinNEntries stores the number of entries</div>
<div>235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * in the full version of the BIN. This is a persistent field for</div>
<div>236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN-delta logrecs only, and for log versions >= 10.</div>
<div>237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int fullBinNEntries = -1;</div>
<div>239&emsp;&emsp;</div>
<div>240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If this is a delta, fullBinMaxEntries stores the max number of</div>
<div>242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * entries (capacity) in the full version of the BIN. This is a</div>
<div>243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * persistent field for BIN-delta logrecs only, and for log versions >= 10.</div>
<div>244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int fullBinMaxEntries = -1;</div>
<div>246&emsp;&emsp;</div>
<div>247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If "this" is a BIN-delta, bloomFilter is a bloom-filter representation</div>
<div>249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * of the set of keys in the clean slots of the full version of the same</div>
<div>250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN. It is used to allow blind put operations in deltas, by answering</div>
<div>251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the question whether the put key is in the full BIN or not. See the</div>
<div>252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * javadoc of the  TREE_BIN_DELTA_BLIND_PUTS config param for more info.</div>
<div>253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This is a persistent field for BIN-delta logrecs only, and for log</div>
<div>254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * versions >= 10.</div>
<div>255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    byte[] bloomFilter;</div>
<div>257&emsp;&emsp;</div>
<div>258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * See comment in IN.java, right after the lastFullVersion data field.</div>
<div>260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private long lastDeltaVersion = DbLsn.NULL_LSN;</div>
<div>262&emsp;&emsp;</div>
<div>263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Caches the VLSN sequence for the LN entries in a BIN, when VLSN</div>
<div>265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * preservation and caching are configured.</div>
<div>266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * A VLSN is added to the cache when an LN is evicted from a BIN. When the</div>
<div>268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * LN is resident, there is no need for caching because the LN contains the</div>
<div>269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * VLSN. See BIN.setTarget.  This strategy works because an LN is always</div>
<div>270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cached during a read or write operation, and only evicted after that,</div>
<div>271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * based on eviction policies.</div>
<div>272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For embedded LNs a VLSN is added to the cache every time the record is</div>
<div>274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * logged. Furthermore, the vlsn cache is made persistent for such LNs.</div>
<div>275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * An EMPTY_REP is used initially until the need arises to add a non-zero</div>
<div>277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * value.  The cache will remain empty if LNs are never evicted or version</div>
<div>278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * caching is not configured, which is always the case for standalone JE.</div>
<div>279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private INLongRep vlsnCache = EMPTY_VLSNS;</div>
<div>281&emsp;&emsp;</div>
<div>282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Stores the size of the most recently written logrec of each LN, or zero</div>
<div>284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if the size is unknown.</div>
<div>285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * We use INLongRep in spite of the fact that sizes are int not long;</div>
<div>287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * INLongRep will store the minimum number of bytes. An EMPTY_REP is</div>
<div>288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * used initially until the need arises to add a non-zero value.</div>
<div>289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private INLongRep lastLoggedSizes = EMPTY_LAST_LOGGED_SIZES;</div>
<div>291&emsp;&emsp;</div>
<div>292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * When some LNs are in the off-heap cache, the offHeapLruId is this BIN's</div>
<div>294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * index in the off-heap LRU list.</div>
<div>295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private INLongRep offHeapLNIds = EMPTY_OFFHEAP_LN_IDS;</div>
<div>297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int offHeapLruId = -1;</div>
<div>298&emsp;&emsp;</div>
<div>299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * An expirationValues slot value is one more than the number of days/hours</div>
<div>301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to add to the expirationBase to get the true expiration days/hours. A</div>
<div>302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot value of zero means no expiration, and a non-zero slot value is one</div>
<div>303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * greater than the actual offset to be added. The base is the smallest</div>
<div>304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * non-zero offset that has been encountered.</div>
<div>305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private INLongRep expirationValues = EMPTY_EXPIRATION;</div>
<div>307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int expirationBase = -1;</div>
<div>308&emsp;&emsp;</div>
<div>309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Can be set to true by tests to prevent last logged sizes from being</div>
<div>311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * stored.</div>
<div>312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static boolean TEST_NO_LAST_LOGGED_SIZES = false;</div>
<div>314&emsp;&emsp;</div>
<div>315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public BIN() {</div>
<div>316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>317&emsp;&emsp;</div>
<div>318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public BIN(</div>
<div>319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        DatabaseImpl db,</div>
<div>320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] identifierKey,</div>
<div>321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int capacity,</div>
<div>322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int level) {</div>
<div>323&emsp;&emsp;</div>
<div>324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super(db, identifierKey, capacity, level);</div>
<div>325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>326&emsp;&emsp;</div>
<div>327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For Sizeof.</div>
<div>329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public BIN(@SuppressWarnings("unused") SizeofMarker marker) {</div>
<div>331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super(marker);</div>
<div>332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>333&emsp;&emsp;</div>
<div>334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Create a new BIN.  Need this because we can't call newInstance()</div>
<div>336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * without getting a 0 for nodeId.</div>
<div>337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected IN createNewInstance(</div>
<div>340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] identifierKey,</div>
<div>341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int maxEntries,</div>
<div>342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int level) {</div>
<div>343&emsp;&emsp;</div>
<div>344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return new BIN(getDatabase(), identifierKey, maxEntries, level);</div>
<div>345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>346&emsp;&emsp;</div>
<div>347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public BINReference createReference() {</div>
<div>348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return new BINReference(</div>
<div>349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          getNodeId(), getDatabase().getId(), getIdentifierKey());</div>
<div>350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>351&emsp;&emsp;</div>
<div>352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isBIN() {</div>
<div>354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>356&emsp;&emsp;</div>
<div>357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return whether the shared latch for this kind of node should be of the</div>
<div>359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * "always exclusive" variety.  Presently, only IN's are actually latched</div>
<div>360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * shared.  BINs are latched exclusive only.</div>
<div>361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isAlwaysLatchedExclusively() {</div>
<div>364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>366&emsp;&emsp;</div>
<div>367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String shortClassName() {</div>
<div>369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return "BIN";</div>
<div>370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>371&emsp;&emsp;</div>
<div>372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String beginTag() {</div>
<div>374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return BEGIN_TAG;</div>
<div>375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>376&emsp;&emsp;</div>
<div>377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String endTag() {</div>
<div>379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return END_TAG;</div>
<div>380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>381&emsp;&emsp;</div>
<div>382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isVLSNCachingEnabled() {</div>
<div style="background-color:limegreen;">383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (!databaseImpl.getSortedDuplicates() && getEnv().getCacheVLSN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>385&emsp;&emsp;</div>
<div>386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setCachedVLSN(int idx, long vlsn) {</div>
<div>387&emsp;&emsp;</div>
<div>388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * We do not cache the VLSN for dup DBs, because dup DBs are typically</div>
<div>390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * used only for indexes, and the overhead of VLSN maintenance would be</div>
<div>391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * wasted.  Plus, although technically VLSN preservation might apply to</div>
<div>392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * dup DBs, the VLSNs are not reliably available since the LNs are</div>
<div>393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * immediately obsolete.</div>
<div>394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isVLSNCachingEnabled()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setCachedVLSNUnconditional(idx, vlsn);</div>
<div>399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>400&emsp;&emsp;</div>
<div>401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setCachedVLSNUnconditional(int idx, long vlsn) {</div>
<div style="background-color:limegreen;">402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        vlsnCache = vlsnCache.set(&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            idx,</div>
<div>404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            (vlsn == VLSN.NULL_VLSN_SEQUENCE ? 0 : vlsn),</div>
<div>405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            this);</div>
<div>406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>407&emsp;&emsp;</div>
<div>408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long getCachedVLSN(int idx) {</div>
<div>409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long vlsn = vlsnCache.get(idx);</div>
<div style="background-color:limegreen;">410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (vlsn == 0 ? VLSN.NULL_VLSN_SEQUENCE : vlsn);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>412&emsp;&emsp;</div>
<div>413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the VLSN.  VLSN.NULL_VLSN_SEQUENCE (-1) is returned in two</div>
<div>415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cases:</div>
<div>416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 1) This is a standalone environment.</div>
<div>417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 2) The VLSN is not cached (perhaps VLSN caching is not configured), and</div>
<div>418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    the allowFetch param is false.</div>
<div>419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * WARNING: Because the vlsnCache is only updated when an LN is evicted, it</div>
<div>421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is critical that getVLSN returns the VLSN for a resident LN before</div>
<div>422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * getting the VLSN from the cache.</div>
<div>423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getVLSN(int idx, boolean allowFetch, CacheMode cacheMode) {</div>
<div>425&emsp;&emsp;</div>
<div>426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Must return the VLSN from the LN, if it is resident. */</div>
<div>427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LN ln = (LN) getTarget(idx);</div>
<div style="background-color:limegreen;">428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ln != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return ln.getVLSNSequence();</div>
<div>430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>431&emsp;&emsp;</div>
<div>432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Next try the vlsnCache. */</div>
<div>433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long vlsn = getCachedVLSN(idx);</div>
<div style="background-color:limegreen;">434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!VLSN.isNull(vlsn)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return vlsn;</div>
<div>436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>437&emsp;&emsp;</div>
<div>438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Next try the off-heap cache. */</div>
<div>439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</div>
<div style="background-color:limegreen;">440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ohCache.isEnabled()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>441&emsp;&emsp;</div>
<div>442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            vlsn = ohCache.loadVLSN(this, idx);</div>
<div>443&emsp;&emsp;</div>
<div style="background-color:limegreen;">444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!VLSN.isNull(vlsn)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return vlsn;</div>
<div>446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>448&emsp;&emsp;</div>
<div>449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* As the last resort, fetch the LN if fetching is allowed. */</div>
<div style="background-color:limegreen;">450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!allowFetch || isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return vlsn;</div>
<div>452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>453&emsp;&emsp;</div>
<div>454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ln = fetchLN(idx, cacheMode);</div>
<div style="background-color:limegreen;">455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ln != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return ln.getVLSNSequence();</div>
<div>457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>458&emsp;&emsp;</div>
<div>459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return VLSN.NULL_VLSN_SEQUENCE;</div>
<div>460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>461&emsp;&emsp;</div>
<div>462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** For unit testing. */</div>
<div>463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public INLongRep getVLSNCache() {</div>
<div>464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return vlsnCache;</div>
<div>465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>466&emsp;&emsp;</div>
<div>467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The last logged size is never needed when the LN is counted obsolete</div>
<div>469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * immediately, since it is only needed for counting an LN obsolete</div>
<div>470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * during an update or deletion.</div>
<div>471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method may not be called until after the database is initialized,</div>
<div>473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * i,e., it may not be called during readFromLog.</div>
<div>474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isLastLoggedSizeStored(int idx) {</div>
<div>477&emsp;&emsp;</div>
<div style="background-color:limegreen;">478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return mayHaveLastLoggedSizeStored() && !isEmbeddedLN(idx);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>480&emsp;&emsp;</div>
<div>481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean mayHaveLastLoggedSizeStored() {</div>
<div>483&emsp;&emsp;</div>
<div>484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Check final static first so all test code is optimized away. */</div>
<div style="background-color:limegreen;">485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (DatabaseUtil.TEST) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Don't skew test measurements with internal DBs. */</div>
<div style="background-color:limegreen;">487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (TEST_NO_LAST_LOGGED_SIZES &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                !databaseImpl.getDbType().isInternal()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return false;</div>
<div>490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>492&emsp;&emsp;</div>
<div style="background-color:limegreen;">493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return !databaseImpl.isLNImmediatelyObsolete();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>495&emsp;&emsp;</div>
<div>496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets last logged size if necessary.</div>
<div>498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method does not dirty the IN because the caller methods dirty it,</div>
<div>500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for example, when setting the LSN, key, or node.</div>
<div>501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is sometimes called to add the logged size for a pre log</div>
<div>503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * version 9 BIN, for example, during fetchTarget and preload.  This makes</div>
<div>504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the logged size available for obsolete counting but does not dirty the</div>
<div>505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * IN, since that could cause an unexpected write of the IN being read.</div>
<div>506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param lastLoggedSize is positive if the size is known, zero if the size</div>
<div>508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is unknown, or -1 if the size should not be changed because logging of</div>
<div>509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the LN was deferred.</div>
<div>510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setLastLoggedSize(int idx, int lastLoggedSize) {</div>
<div>513&emsp;&emsp;</div>
<div style="background-color:limegreen;">514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if ((lastLoggedSize &#60; 0) || !isLastLoggedSizeStored(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>517&emsp;&emsp;</div>
<div>518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedSizeUnconditional(idx, lastLoggedSize);</div>
<div>519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>520&emsp;&emsp;</div>
<div>521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void clearLastLoggedSize(int idx) {</div>
<div>523&emsp;&emsp;</div>
<div>524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedSizeUnconditional(idx, 0);</div>
<div>525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>526&emsp;&emsp;</div>
<div>527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the size without checking whether it is necessary.</div>
<div>529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>530&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is used when reading from the log because the databaseImpl</div>
<div>531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is not yet initialized and isLastLoggedSizeStored cannot be called.</div>
<div>532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It is also called for efficiency reasons when it is known that storing</div>
<div>533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the logged size is necessary, for example, when copying values between</div>
<div>534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slots.</div>
<div>535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setLastLoggedSizeUnconditional(int idx, int lastLoggedSize) {</div>
<div>538&emsp;&emsp;</div>
<div>539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastLoggedSizes = lastLoggedSizes.set(idx, lastLoggedSize, this);</div>
<div>540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>541&emsp;&emsp;</div>
<div>542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a positive value if the size is known, or zero if unknown.</div>
<div>544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getLastLoggedSize(int idx) {</div>
<div>547&emsp;&emsp;</div>
<div style="background-color:limegreen;">548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isLastLoggedSizeStored(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return (int) lastLoggedSizes.get(idx);</div>
<div>550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>551&emsp;&emsp;</div>
<div>552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return 0;</div>
<div>553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>554&emsp;&emsp;</div>
<div>555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the expiration time for a slot in days or hours.</div>
<div>557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setExpiration(final int idx, int value, final boolean hours) {</div>
<div>559&emsp;&emsp;</div>
<div>560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* This slot has no expiration. */</div>
<div style="background-color:limegreen;">561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (value == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expirationValues = expirationValues.set(idx, 0, this);</div>
<div>563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>565&emsp;&emsp;</div>
<div>566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * If this is the first slot with an expiration, initialize the base to</div>
<div>568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the value and set the offset (slot value) to one.</div>
<div>569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (expirationBase == -1 || nEntries == 1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expirationBase = value;</div>
<div>572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setExpirationOffset(idx, 1);</div>
<div>573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setExpirationInHours(hours);</div>
<div>574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>576&emsp;&emsp;</div>
<div style="background-color:limegreen;">577&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (hours) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Convert existing values to hours if necessary. */</div>
<div style="background-color:limegreen;">579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!isExpirationInHours()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>580&emsp;&emsp;</div>
<div>581&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                expirationBase *= 24;</div>
<div>582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setExpirationInHours(true);</div>
<div>583&emsp;&emsp;</div>
<div style="background-color:limegreen;">584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                for (int i = 0; i &#60; nEntries; i += 1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>585&emsp;&emsp;</div>
<div style="background-color:limegreen;">586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (i == idx) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        continue;</div>
<div>588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>589&emsp;&emsp;</div>
<div>590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final int offset = (int) expirationValues.get(i);</div>
<div>591&emsp;&emsp;</div>
<div style="background-color:limegreen;">592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (offset == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        continue;</div>
<div>594&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>595&emsp;&emsp;</div>
<div>596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    setExpirationOffset(i, ((offset - 1) * 24) + 1);</div>
<div>597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>598&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* If values are stored in hours, convert days to hours. */</div>
<div style="background-color:limegreen;">601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isExpirationInHours()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                value *= 24;</div>
<div>603&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>605&emsp;&emsp;</div>
<div>606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Slot's expiration must not be less than the base. If it is, decrease</div>
<div>608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the base and increase the offset in other slots accordingly.</div>
<div>609&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (value &#60; expirationBase) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>611&emsp;&emsp;</div>
<div>612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int adjustment = expirationBase - value;</div>
<div>613&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expirationBase = value;</div>
<div>614&emsp;&emsp;</div>
<div style="background-color:limegreen;">615&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = 0; i &#60; nEntries; i += 1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>616&emsp;&emsp;</div>
<div style="background-color:limegreen;">617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (i == idx) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    continue;</div>
<div>619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>620&emsp;&emsp;</div>
<div>621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                final int offset = (int) expirationValues.get(i);</div>
<div>622&emsp;&emsp;</div>
<div style="background-color:limegreen;">623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (offset == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    continue;</div>
<div>625&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>626&emsp;&emsp;</div>
<div>627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setExpirationOffset(i, offset + adjustment);</div>
<div>628&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>630&emsp;&emsp;</div>
<div>631&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setExpirationOffset(idx, value - expirationBase + 1);</div>
<div>632&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>633&emsp;&emsp;</div>
<div>634&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean hasExpirationValues() {</div>
<div>635&emsp;&emsp;</div>
<div style="background-color:limegreen;">636&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return !expirationValues.isEmpty();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>638&emsp;&emsp;</div>
<div>639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the expiration time for a slot. The return value is in days or</div>
<div>641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * hours, depending on isExpirationTimeInHours.</div>
<div>642&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>643&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getExpiration(int idx) {</div>
<div>644&emsp;&emsp;</div>
<div>645&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int offset = (int) expirationValues.get(idx);</div>
<div>646&emsp;&emsp;</div>
<div style="background-color:limegreen;">647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (offset == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>650&emsp;&emsp;</div>
<div>651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return offset - 1 + expirationBase;</div>
<div>652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>653&emsp;&emsp;</div>
<div>654&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int getExpirationBase() {</div>
<div>655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return expirationBase;</div>
<div>656&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>657&emsp;&emsp;</div>
<div>658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int getExpirationOffset(int idx) {</div>
<div>659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (int) expirationValues.get(idx);</div>
<div>660&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>661&emsp;&emsp;</div>
<div>662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setExpirationBase(int base) {</div>
<div>663&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationBase = base;</div>
<div>664&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>665&emsp;&emsp;</div>
<div>666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setExpirationOffset(int idx, int offset) {</div>
<div>667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationValues = expirationValues.set(idx, offset, this);</div>
<div>668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>669&emsp;&emsp;</div>
<div>670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether the slot is known-deleted, pending-deleted, or expired.</div>
<div>672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isDefunct(int idx) {</div>
<div style="background-color:limegreen;">674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return isDeleted(idx) || isExpired(idx);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>676&emsp;&emsp;</div>
<div>677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether the slot is known-deleted or pending-deleted.</div>
<div>679&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isDeleted(int idx) {</div>
<div style="background-color:limegreen;">681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return isEntryKnownDeleted(idx) || isEntryPendingDeleted(idx);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>683&emsp;&emsp;</div>
<div>684&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether the slot is expired.</div>
<div>686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isExpired(int idx) {</div>
<div>688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getEnv().isExpired(getExpiration(idx), isExpirationInHours());</div>
<div>689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>690&emsp;&emsp;</div>
<div>691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isProbablyExpired(int idx) {</div>
<div>692&emsp;&emsp;</div>
<div>693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getEnv().expiresWithin(</div>
<div>694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getExpiration(idx), isExpirationInHours(),</div>
<div>695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEnv().getTtlClockTolerance());</div>
<div>696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>697&emsp;&emsp;</div>
<div>698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getLastLoggedSizeUnconditional(int idx) {</div>
<div>699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (int) lastLoggedSizes.get(idx);</div>
<div>700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>701&emsp;&emsp;</div>
<div>702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setOffHeapLNId(int idx, long memId) {</div>
<div>703&emsp;&emsp;</div>
<div style="background-color:limegreen;">704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (offHeapLNIds.get(idx) == memId) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>707&emsp;&emsp;</div>
<div>708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = offHeapLNIds.set(idx, memId, this);</div>
<div>709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>710&emsp;&emsp;</div>
<div>711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void clearOffHeapLNIds() {</div>
<div>712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = offHeapLNIds.clear(this, EMPTY_OFFHEAP_LN_IDS);</div>
<div>713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>714&emsp;&emsp;</div>
<div>715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getOffHeapLNIdsMemorySize() {</div>
<div>716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return offHeapLNIds.getMemorySize();</div>
<div>717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>718&emsp;&emsp;</div>
<div>719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getOffHeapLNId(int idx) {</div>
<div>720&emsp;&emsp;</div>
<div>721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return offHeapLNIds.get(idx);</div>
<div>722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>723&emsp;&emsp;</div>
<div>724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean hasOffHeapLNs() {</div>
<div>725&emsp;&emsp;</div>
<div style="background-color:limegreen;">726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return !offHeapLNIds.isEmpty();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>728&emsp;&emsp;</div>
<div>729&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setOffHeapLruId(int id) {</div>
<div>730&emsp;&emsp;</div>
<div style="background-color:limegreen;">731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert id >= 0 || !hasOffHeapLNs();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>732&emsp;&emsp;</div>
<div>733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLruId = id;</div>
<div>734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>735&emsp;&emsp;</div>
<div>736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getOffHeapLruId() {</div>
<div>737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return offHeapLruId;</div>
<div>738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>739&emsp;&emsp;</div>
<div>740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void freeOffHeapLN(int idx) {</div>
<div>741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getOffHeapCache().freeLN(this, idx);</div>
<div>742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>743&emsp;&emsp;</div>
<div>744&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Updates the vlsnCache when an LN target is evicted.  See vlsnCache.</div>
<div>746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setTarget(int idx, Node target) {</div>
<div>749&emsp;&emsp;</div>
<div style="background-color:limegreen;">750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (target == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final Node oldTarget = getTarget(idx);</div>
<div style="background-color:limegreen;">752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (oldTarget instanceof LN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>753&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setCachedVLSN(idx, ((LN) oldTarget).getVLSNSequence());</div>
<div>754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.setTarget(idx, target);</div>
<div>757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>758&emsp;&emsp;</div>
<div>759&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overridden to account for BIN-specific slot info.</div>
<div>761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>763&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void appendEntryFromOtherNode(IN from, int fromIdx) {</div>
<div>764&emsp;&emsp;</div>
<div>765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.appendEntryFromOtherNode(from, fromIdx);</div>
<div>766&emsp;&emsp;</div>
<div>767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN fromBin = (BIN) from;</div>
<div>768&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int idx = nEntries - 1;</div>
<div>769&emsp;&emsp;</div>
<div>770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setCachedVLSNUnconditional(idx, fromBin.getCachedVLSN(fromIdx));</div>
<div>771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedSizeUnconditional(idx, from.getLastLoggedSize(fromIdx));</div>
<div>772&emsp;&emsp;</div>
<div>773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setExpiration(</div>
<div>774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            idx, fromBin.getExpiration(fromIdx),</div>
<div>775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            fromBin.isExpirationInHours());</div>
<div>776&emsp;&emsp;</div>
<div>777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</div>
<div>778&emsp;&emsp;</div>
<div style="background-color:limegreen;">779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ohCache.isEnabled()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>780&emsp;&emsp;</div>
<div>781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            offHeapLNIds = offHeapLNIds.set(</div>
<div>782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                idx, fromBin.offHeapLNIds.get(fromIdx), this);</div>
<div>783&emsp;&emsp;</div>
<div>784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.ensureOffHeapLNsInLRU(this);</div>
<div>785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>787&emsp;&emsp;</div>
<div>788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>789&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overridden to account for BIN-specific slot info.</div>
<div>790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void copyEntries(int from, int to, int n) {</div>
<div>793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.copyEntries(from, to, n);</div>
<div>794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        vlsnCache = vlsnCache.copy(from, to, n, this);</div>
<div>795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastLoggedSizes = lastLoggedSizes.copy(from, to, n, this);</div>
<div>796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationValues = expirationValues.copy(from, to, n, this);</div>
<div>797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = offHeapLNIds.copy(from, to, n, this);</div>
<div>798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>799&emsp;&emsp;</div>
<div>800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overridden to account for BIN-specific slot info.</div>
<div>802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void clearEntry(int idx) {</div>
<div>805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.clearEntry(idx);</div>
<div>806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setCachedVLSNUnconditional(idx, VLSN.NULL_VLSN_SEQUENCE);</div>
<div>807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedSizeUnconditional(idx, 0);</div>
<div>808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setExpiration(idx, 0, false);</div>
<div>809&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = offHeapLNIds.set(idx, 0, this);</div>
<div>810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>811&emsp;&emsp;</div>
<div>812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Cursors</div>
<div>814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>815&emsp;&emsp;</div>
<div>816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* public for the test suite. */</div>
<div>817&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Set&#60;CursorImpl> getCursorSet() {</div>
<div style="background-color:limegreen;">818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>       if (cursorSet == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>819&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           return Collections.emptySet();</div>
<div>820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       }</div>
<div>821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       return cursorSet.copy();</div>
<div>822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>823&emsp;&emsp;</div>
<div>824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Register a cursor with this BIN.  Caller has this BIN already latched.</div>
<div>826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param cursor Cursor to register.</div>
<div>827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void addCursor(CursorImpl cursor) {</div>
<div style="background-color:limegreen;">829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursorSet == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cursorSet = new TinyHashSet&#60;CursorImpl>();</div>
<div>832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        cursorSet.add(cursor);</div>
<div>834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>835&emsp;&emsp;</div>
<div>836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Unregister a cursor with this bin.  Caller has this BIN already</div>
<div>838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * latched.</div>
<div>839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param cursor Cursor to unregister.</div>
<div>841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void removeCursor(CursorImpl cursor) {</div>
<div style="background-color:limegreen;">843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursorSet == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        cursorSet.remove(cursor);</div>
<div style="background-color:limegreen;">848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursorSet.size() == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cursorSet = null;</div>
<div>850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>852&emsp;&emsp;</div>
<div>853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the number of cursors currently referring to this BIN.</div>
<div>855&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int nCursors() {</div>
<div>857&emsp;&emsp;</div>
<div>858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>859&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Use a local var to concurrent assignment to the cursorSet field by</div>
<div>860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * another thread. This method is called via eviction without latching.</div>
<div>861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * LRU-TODO: with the new evictor this method is called with the node</div>
<div>862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * EX-latched. So, cleanup after the old evictor is scrapped.</div>
<div>863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final TinyHashSet&#60;CursorImpl> cursors = cursorSet;</div>
<div style="background-color:limegreen;">865&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursors == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>866&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return cursors.size();</div>
<div>869&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>870&emsp;&emsp;</div>
<div>871&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Adjust any cursors that are referring to this BIN.  This method is</div>
<div>873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * called during a split operation.  "this" is the BIN being split.</div>
<div>874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * newSibling is the new BIN into which the entries from "this" between</div>
<div>875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * newSiblingLow and newSiblingHigh have been copied.</div>
<div>876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>877&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSibling - the newSibling into which "this" has been split.</div>
<div>878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSiblingLow</div>
<div>879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSiblingHigh - the low and high entry of</div>
<div>880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * "this" that were moved into newSibling.</div>
<div>881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void adjustCursors(</div>
<div>884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN newSibling,</div>
<div>885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSiblingLow,</div>
<div>886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSiblingHigh)</div>
<div>887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    {</div>
<div style="background-color:limegreen;">888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert newSibling.isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert this.isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (cursorSet == null) {</div>
<div>891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int adjustmentDelta = (newSiblingHigh - newSiblingLow);</div>
<div>894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Iterator&#60;CursorImpl> iter = cursorSet.iterator();</div>
<div>895&emsp;&emsp;</div>
<div>896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        while (iter.hasNext()) {</div>
<div>897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            CursorImpl cursor = iter.next();</div>
<div>898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int cIdx = cursor.getIndex();</div>
<div>899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cursor.assertBIN(this);</div>
<div>900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            assert newSibling instanceof BIN;</div>
<div>901&emsp;&emsp;</div>
<div>902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>903&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * There are four cases to consider for cursor adjustments,</div>
<div>904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * depending on (1) how the existing node gets split, and (2) where</div>
<div>905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * the cursor points to currently.  In cases 1 and 2, the id key of</div>
<div>906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * the node being split is to the right of the splitindex so the</div>
<div>907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * new sibling gets the node entries to the left of that index.</div>
<div>908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * This is indicated by "new sibling" to the left of the vertical</div>
<div>909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * split line below.  The right side of the node contains entries</div>
<div>910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * that will remain in the existing node (although they've been</div>
<div>911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * shifted to the left).  The vertical bar (^) indicates where the</div>
<div>912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * cursor currently points.</div>
<div>913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * case 1:</div>
<div>915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   We need to set the cursor's "bin" reference to point at the</div>
<div>917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   new sibling, but we don't need to adjust its index since that</div>
<div>918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   continues to be correct post-split.</div>
<div>919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   |  new sibling        |  existing node  |</div>
<div>922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>923&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *         cursor ^</div>
<div>924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>925&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * case 2:</div>
<div>926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   We only need to adjust the cursor's index since it continues</div>
<div>928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   to point to the current BIN post-split.</div>
<div>929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   |  new sibling        |  existing node  |</div>
<div>932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *                              cursor ^</div>
<div>934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * case 3:</div>
<div>936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   Do nothing.  The cursor continues to point at the correct BIN</div>
<div>938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   and index.</div>
<div>939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   |  existing Node        |  new sibling  |</div>
<div>942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *         cursor ^</div>
<div>944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * case 4:</div>
<div>946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   Adjust the "bin" pointer to point at the new sibling BIN and</div>
<div>948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   also adjust the index.</div>
<div>949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   |  existing Node        |  new sibling  |</div>
<div>952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   +=======================================+</div>
<div>953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *                                 cursor ^</div>
<div>954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            BIN ns = (BIN) newSibling;</div>
<div>956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (newSiblingLow == 0) {</div>
<div>957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (cIdx &#60; newSiblingHigh) {</div>
<div>958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    /* case 1 */</div>
<div>959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    iter.remove();</div>
<div>960&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    cursor.setBIN(ns);</div>
<div>961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    ns.addCursor(cursor);</div>
<div>962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    /* case 2 */</div>
<div>964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    cursor.setIndex(cIdx - adjustmentDelta);</div>
<div>965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (cIdx >= newSiblingLow) {</div>
<div>968&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    /* case 4 */</div>
<div>969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    cursor.setIndex(cIdx - newSiblingLow);</div>
<div>970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    iter.remove();</div>
<div>971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    cursor.setBIN(ns);</div>
<div>972&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    ns.addCursor(cursor);</div>
<div>973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>977&emsp;&emsp;</div>
<div>978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For each cursor in this BIN's cursor set, ensure that the cursor is</div>
<div>980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * actually referring to this BIN.</div>
<div>981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void verifyCursors() {</div>
<div>983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (cursorSet == null) {</div>
<div>984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (CursorImpl cursor : cursorSet) {</div>
<div>987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cursor.assertBIN(this);</div>
<div>988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>990&emsp;&emsp;</div>
<div>991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Adjust cursors referring to this BIN following an insert.</div>
<div>993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param insertIndex - The index of the new entry.</div>
<div>995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void adjustCursorsForInsert(int insertIndex) {</div>
<div>998&emsp;&emsp;</div>
<div style="background-color:limegreen;">999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert this.isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursorSet == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>1002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1003&emsp;&emsp;</div>
<div style="background-color:limegreen;">1004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (CursorImpl cursor : cursorSet) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int cIdx = cursor.getIndex();</div>
<div style="background-color:limegreen;">1006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (insertIndex &#60;= cIdx) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                cursor.setIndex(cIdx + 1);</div>
<div>1008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1011&emsp;&emsp;</div>
<div>1012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called when we know we are about to split on behalf of a key that is the</div>
<div>1014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minimum (leftSide) or maximum (!leftSide) of this node.  This is</div>
<div>1015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * achieved by just forcing the split to occur either one element in from</div>
<div>1016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the left or the right (i.e. splitIndex is 1 or nEntries - 1).</div>
<div>1017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    IN splitSpecial(</div>
<div>1020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN parent,</div>
<div>1021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int parentIndex,</div>
<div>1022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN grandParent,</div>
<div>1023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int maxEntriesPerNode,</div>
<div>1024&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>1025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean leftSide)</div>
<div>1026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1027&emsp;&emsp;</div>
<div>1028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int nEntries = getNEntries();</div>
<div>1029&emsp;&emsp;</div>
<div>1030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int index = findEntry(key, true, false);</div>
<div>1031&emsp;&emsp;</div>
<div style="background-color:limegreen;">1032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean exact = (index & IN.EXACT_MATCH) != 0;&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        index &= ~IN.EXACT_MATCH;</div>
<div>1034&emsp;&emsp;</div>
<div style="background-color:limegreen;">1035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (leftSide && index &#60; 0) {&nbsp;&#8594; [ALLOWCREATE] & [ALLOWCREATE]</b></div>
<div>1036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return splitInternal(</div>
<div>1037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode, 1);</div>
<div>1038&emsp;&emsp;</div>
<div style="background-color:limegreen;">1039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (!leftSide && !exact && index == (nEntries - 1)) {&nbsp;&#8594; [ALLOWCREATE] & [ALLOWCREATE]</b></div>
<div>1040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return splitInternal(</div>
<div>1041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode,</div>
<div>1042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                nEntries - 1);</div>
<div>1043&emsp;&emsp;</div>
<div>1044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return split(</div>
<div>1046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode);</div>
<div>1047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1049&emsp;&emsp;</div>
<div>1050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Compress a full BIN by removing any slots that are deleted or expired.</div>
<div>1052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This must not be a BIN-delta. No cursors can be present on the BIN.</div>
<div>1054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Caller is responsible for latching and unlatching this node.</div>
<div>1055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If the slot containing the identifier is removed, the identifier key</div>
<div>1057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * will be changed to the key in the first remaining slot.</div>
<div>1058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Normally when a slot is removed, the IN is dirtied. However, during</div>
<div>1060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * compression the BIN is not dirtied when a slot is removed. This is safe</div>
<div>1061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the reasons described below. Note that the BIN being compressed is</div>
<div>1062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * always a full BIN, not a delta.</div>
<div>1063&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  + If the BIN is not dirty and it does not become dirty before shutdown,</div>
<div>1065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  i.e., it is not logged, then it is possible that this compression will</div>
<div>1066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  be "lost". However, the state of the slot on disk is expired/deleted,</div>
<div>1067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  and when the BIN is later fetched from disk, this state will be</div>
<div>1068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  restored and the compression will be performed again.</div>
<div>1069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  + If the slot is dirty, the BIN may also be dirty or may become dirty</div>
<div>1071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  later, and be logged. Logging a delta would cause the information in</div>
<div>1072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  the dirty slot to be lost. Therefore, when a dirty slot is removed, we</div>
<div>1073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  set a flag that prohibits the next BIN logged from being a delta.</div>
<div>1074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This optimization (that we don't dirty the BIN and we allow logging a</div>
<div>1076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * delta after removing a non-dirty slot) has one minor and one major</div>
<div>1077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * impact:</div>
<div>1078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1079&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 1. When a slot is removed for a deleted record, normally the slot and</div>
<div>1080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the BIN will be dirty. Although it is unusual, we may encounter a</div>
<div>1081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * non-dirty slot for a deleted record. This happens if the slot could not</div>
<div>1082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be removed by this method when a full BIN is logged, due to a lock or a</div>
<div>1083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cursor, and we compress the full BIN later.</div>
<div>1084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 2. When a slot is removed for an expired record, it is common that the</div>
<div>1086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot will not be be dirty. In this case, without the optimization, the</div>
<div>1087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * removal of expired slots would cause more logging and less deltas would</div>
<div>1088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be logged.</div>
<div>1089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param localTracker is used only for temporary DBs, and may be specified</div>
<div>1091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to consolidate multiple tracking operations.  If null, the tracking is</div>
<div>1092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * performed immediately in this method.</div>
<div>1093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if all deleted and expired slots were compressed, or false</div>
<div>1095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if one or more slots could not be compressed because we were unable to</div>
<div>1096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * obtain a lock. A false return value means "try again later".</div>
<div>1097&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean compress(boolean compressDirtySlots,</div>
<div>1099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            final LocalUtilizationTracker localTracker) {</div>
<div>1100&emsp;&emsp;</div>
<div>1101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * If the environment is not yet recovered we can't rely on locks</div>
<div>1103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * being set up to safeguard active data and so we can't compress</div>
<div>1104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * safely.</div>
<div>1105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!databaseImpl.getEnv().isValid()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1109&emsp;&emsp;</div>
<div style="background-color:limegreen;">1110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (nCursors() > 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw EnvironmentFailureException.unexpectedState();</div>
<div>1112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1113&emsp;&emsp;</div>
<div style="background-color:limegreen;">1114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw EnvironmentFailureException.unexpectedState();</div>
<div>1116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1117&emsp;&emsp;</div>
<div>1118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final DatabaseImpl db = getDatabase();</div>
<div>1119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = db.getEnv();</div>
<div>1120&emsp;&emsp;</div>
<div>1121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final LockManager lockManager =</div>
<div>1122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            envImpl.getTxnManager().getLockManager();</div>
<div>1123&emsp;&emsp;</div>
<div>1124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean setNewIdKey = false;</div>
<div>1125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean anyLocked = false;</div>
<div>1126&emsp;&emsp;</div>
<div style="background-color:limegreen;">1127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1128&emsp;&emsp;</div>
<div style="background-color:limegreen;">1129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!compressDirtySlots && isDirty(i)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>1131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1132&emsp;&emsp;</div>
<div>1133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final boolean expired =</div>
<div>1134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                envImpl.isExpired(getExpiration(i), isExpirationInHours());</div>
<div>1135&emsp;&emsp;</div>
<div>1136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final boolean deleted = isDeleted(i);</div>
<div>1137&emsp;&emsp;</div>
<div style="background-color:limegreen;">1138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!deleted && !expired) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>1140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1141&emsp;&emsp;</div>
<div>1142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * We have to be able to lock the LN before we can compress the</div>
<div>1144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * entry. If we can't, then skip over it. For a deleted record, a</div>
<div>1145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * read lock is sufficient because it means the deletion has been</div>
<div>1146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * committed, and other lockers don't hold read locks on a deleted</div>
<div>1147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * record. For an expired record, a write lock is needed to prevent</div>
<div>1148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * removal of a slot for a record that is read-locked elsewhere.</div>
<div>1149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * In both cases it is more efficient to call isLockUncontended</div>
<div>1150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * than to actually lock the LN, since we would release the lock</div>
<div>1151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * immediately.</div>
<div>1152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>1153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * We must be able to lock the LN even if isKnownDeleted is true,</div>
<div>1154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * because locks protect the aborts. (Aborts may execute multiple</div>
<div>1155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * operations, where each operation latches and unlatches. It's the</div>
<div>1156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * LN lock that protects the integrity of the whole multi-step</div>
<div>1157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * process.)</div>
<div>1158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>1159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * For example, during abort, there may be cases where we have</div>
<div>1160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * deleted and then added an LN during the same txn.  This means</div>
<div>1161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * that to undo/abort it, we first delete the LN (leaving</div>
<div>1162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * knownDeleted set), and then add it back into the tree.  We want</div>
<div>1163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * to make sure the entry is in the BIN when we do the insert back</div>
<div>1164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * in.</div>
<div>1165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final long lsn = getLsn(i);</div>
<div>1167&emsp;&emsp;</div>
<div>1168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Can discard a NULL_LSN entry without locking. */</div>
<div style="background-color:limegreen;">1169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lsn != DbLsn.NULL_LSN &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                !lockManager.isLockUncontended(lsn)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1171&emsp;&emsp;</div>
<div>1172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                anyLocked = true;</div>
<div>1173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>1174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1175&emsp;&emsp;</div>
<div>1176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* At this point, we know we can remove the slot. */</div>
<div style="background-color:limegreen;">1177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (entryKeys.compareKeys(&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getIdentifierKey(), keyPrefix, i, haveEmbeddedData(i),</div>
<div>1179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getKeyComparator()) == 0) {</div>
<div>1180&emsp;&emsp;</div>
<div>1181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>1182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * We're about to remove the entry with the idKey so the</div>
<div>1183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * node will need a new idkey.</div>
<div>1184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div>1185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setNewIdKey = true;</div>
<div>1186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1187&emsp;&emsp;</div>
<div>1188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * When we compress a deleted slot in a deferred-write DB, we</div>
<div>1190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * must either log a dirty LN or count it obsolete. However, if</div>
<div>1191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * we compress an expired slot, neither is necessary; see TTL.</div>
<div>1192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">1193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!expired && db.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1194&emsp;&emsp;</div>
<div>1195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                final LN ln = (LN) getTarget(i);</div>
<div>1196&emsp;&emsp;</div>
<div style="background-color:limegreen;">1197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (ln != null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    ln.isDirty() &&&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">1199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    !DbLsn.isTransient(lsn)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1200&emsp;&emsp;</div>
<div style="background-color:limegreen;">1201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (db.isTemporary()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1202&emsp;&emsp;</div>
<div>1203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        /*</div>
<div>1204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * When a previously logged LN in a temporary DB is</div>
<div>1205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * dirty, we can count the LSN of the last logged LN as</div>
<div>1206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * obsolete without logging. There is no requirement</div>
<div>1207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * for the dirty deleted LN to be durable past</div>
<div>1208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * recovery.  There is no danger of the last logged LN</div>
<div>1209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * being accessed again (after log cleaning, for</div>
<div>1210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * example), since temp DBs do not survive recovery.</div>
<div>1211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         */</div>
<div style="background-color:limegreen;">1212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                        if (localTracker != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            localTracker.countObsoleteNode(</div>
<div>1214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                lsn, ln.getGenericLogType(),</div>
<div>1215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                getLastLoggedSize(i), db);</div>
<div>1216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        } else {</div>
<div>1217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            envImpl.getLogManager().countObsoleteNode(</div>
<div>1218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                lsn, ln.getGenericLogType(),</div>
<div>1219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                getLastLoggedSize(i), db,</div>
<div>1220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                true /*countExact*/);</div>
<div>1221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        }</div>
<div>1222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    } else {</div>
<div>1223&emsp;&emsp;</div>
<div>1224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        /*</div>
<div>1225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * When a previously logged deferred-write LN is dirty,</div>
<div>1226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * we log the dirty deleted LN to make the deletion</div>
<div>1227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * durable. The act of logging will also count the last</div>
<div>1228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         * logged LSN as obsolete.</div>
<div>1229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         */</div>
<div>1230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        logDirtyLN(i, ln, true /*allowEviction*/);</div>
<div>1231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>1232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1234&emsp;&emsp;</div>
<div>1235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            deleteEntry(i, false /*makeDirty*/, true /*validate*/);</div>
<div>1236&emsp;&emsp;</div>
<div>1237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Since we're deleting the current entry, decrement the index. */</div>
<div>1238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            i--;</div>
<div>1239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1240&emsp;&emsp;</div>
<div style="background-color:limegreen;">1241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getNEntries() != 0 && setNewIdKey) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setIdentifierKey(getKey(0), false /*makeDirty*/);</div>
<div>1243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1244&emsp;&emsp;</div>
<div style="background-color:limegreen;">1245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getNEntries() == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* This BIN is empty and expendable. */</div>
<div>1247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateLRU(CacheMode.MAKE_COLD); // TODO actually make cold</div>
<div>1248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1249&emsp;&emsp;</div>
<div>1250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Reduce capacity if this BIN is larger than the configured capacity,</div>
<div>1252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * and has less entries then the configured capacity. This could be due</div>
<div>1253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * to enlarging the BIN during recovery (see reconstituteBIN) or</div>
<div>1254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * because the configured capacity was changed.</div>
<div>1255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>1256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int configuredCapacity = databaseImpl.getNodeMaxTreeEntries();</div>
<div style="background-color:limegreen;">1257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getMaxEntries() > configuredCapacity &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            getNEntries() &#60; configuredCapacity) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            resize(configuredCapacity);</div>
<div>1260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1261&emsp;&emsp;</div>
<div style="background-color:limegreen;">1262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return !anyLocked;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1264&emsp;&emsp;</div>
<div>1265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is called opportunistically at certain places where a</div>
<div>1267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * deleted slot is observed (when the slot's PendingDeleted or KnownDeleted</div>
<div>1268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * flag is set), to ensure that the slot is compressed away. This is an</div>
<div>1269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * attempt to process slots that were not compressed during the mainstream</div>
<div>1270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * record deletion process because of cursors on the BIN during compress,</div>
<div>1271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * or a crash prior to compression.</div>
<div>1272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void queueSlotDeletion(final int idx) {</div>
<div>1274&emsp;&emsp;</div>
<div>1275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * If the next logrec for this BIN should be a BIN-delta, don't queue</div>
<div>1277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the BIN if the deleted slot is dirty, because removing dirty BIN</div>
<div>1278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * slots prevents logging a delta.</div>
<div>1279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isDirty(idx) && shouldLogDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>1282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1283&emsp;&emsp;</div>
<div>1284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEnv().addToCompressorQueue(this);</div>
<div>1285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1286&emsp;&emsp;</div>
<div>1287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For debugging.  Overrides method in IN. */</div>
<div>1288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean validateSubtreeBeforeDelete(int index) {</div>
<div>1290&emsp;&emsp;</div>
<div style="background-color:limegreen;">1291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>1292&emsp;&emsp;</div>
<div>1293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>1294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1295&emsp;&emsp;</div>
<div>1296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Check if this node fits the qualifications for being part of a deletable</div>
<div>1298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * subtree. It may not have any LN children.</div>
<div>1299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * We assume that this is only called under an assert.</div>
<div>1301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isValidForDelete()</div>
<div>1304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1305&emsp;&emsp;</div>
<div>1306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(isLatchExclusiveOwner());</div>
<div>1307&emsp;&emsp;</div>
<div>1308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (isBINDelta()) {</div>
<div>1309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1311&emsp;&emsp;</div>
<div>1312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int numValidEntries = 0;</div>
<div>1313&emsp;&emsp;</div>
<div>1314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; getNEntries(); i++) {</div>
<div>1315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (!isEntryKnownDeleted(i)) {</div>
<div>1316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                numValidEntries++;</div>
<div>1317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1319&emsp;&emsp;</div>
<div>1320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (numValidEntries > 0) { // any valid entries, not eligible</div>
<div>1321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (nCursors() > 0) {      // cursors on BIN, not eligible</div>
<div>1324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;               // 0 entries, no cursors</div>
<div>1327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1328&emsp;&emsp;</div>
<div>1329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long compactMemory() {</div>
<div>1331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long oldSize = inMemorySize;</div>
<div>1332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        super.compactMemory();</div>
<div>1333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = offHeapLNIds.compact(this, EMPTY_OFFHEAP_LN_IDS);</div>
<div>1334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationValues = expirationValues.compact(this, EMPTY_EXPIRATION);</div>
<div>1335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return oldSize - inMemorySize;</div>
<div>1336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1337&emsp;&emsp;</div>
<div>1338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Adds vlsnCache size to computed memory size.</div>
<div>1340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long computeMemorySize() {</div>
<div>1343&emsp;&emsp;</div>
<div>1344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long size = super.computeMemorySize();</div>
<div>1345&emsp;&emsp;</div>
<div>1346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * vlsnCache, lastLoggedSizes, etc, are null only when this method is</div>
<div>1348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * called by the superclass constructor, i.e., before this class</div>
<div>1349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * constructor has run. Luckily the initial representations have a</div>
<div>1350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * memory size of zero, so we can ignore them in this case.</div>
<div>1351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (vlsnCache != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += vlsnCache.getMemorySize();</div>
<div>1354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1355&emsp;&emsp;</div>
<div style="background-color:limegreen;">1356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (lastLoggedSizes != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += lastLoggedSizes.getMemorySize();</div>
<div>1358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1359&emsp;&emsp;</div>
<div style="background-color:limegreen;">1360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (expirationValues != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += expirationValues.getMemorySize();</div>
<div>1362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1363&emsp;&emsp;</div>
<div style="background-color:limegreen;">1364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (offHeapLNIds != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += offHeapLNIds.getMemorySize();</div>
<div>1366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1367&emsp;&emsp;</div>
<div style="background-color:limegreen;">1368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bloomFilter != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += BINDeltaBloomFilter.getMemorySize(bloomFilter);</div>
<div>1370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1371&emsp;&emsp;</div>
<div>1372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return size;</div>
<div>1373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1374&emsp;&emsp;</div>
<div>1375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Utility method used during unit testing. */</div>
<div>1376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected long printMemorySize() {</div>
<div>1378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long inTotal = super.printMemorySize();</div>
<div>1379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long vlsnCacheOverhead = vlsnCache.getMemorySize();</div>
<div>1380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long logSizesOverhead = lastLoggedSizes.getMemorySize();</div>
<div>1381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long expirationOverhead = expirationValues.getMemorySize();</div>
<div>1382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long offHeapLNIdOverhead = offHeapLNIds.getMemorySize();</div>
<div>1383&emsp;&emsp;</div>
<div>1384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long binTotal = inTotal +</div>
<div>1385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            vlsnCacheOverhead + logSizesOverhead + offHeapLNIdOverhead;</div>
<div>1386&emsp;&emsp;</div>
<div>1387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.out.format(</div>
<div>1388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            "BIN: %d vlsns: %d logSizes: %d expiration: %d offHeapLNIds: %d %n",</div>
<div>1389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            binTotal, vlsnCacheOverhead, logSizesOverhead, expirationOverhead,</div>
<div>1390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            offHeapLNIdOverhead);</div>
<div>1391&emsp;&emsp;</div>
<div>1392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return binTotal;</div>
<div>1393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1394&emsp;&emsp;</div>
<div>1395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected long getFixedMemoryOverhead() {</div>
<div>1397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return MemoryBudget.BIN_FIXED_OVERHEAD;</div>
<div>1398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1399&emsp;&emsp;</div>
<div>1400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the treeAdmin memory in objects referenced by this BIN.</div>
<div>1402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Specifically, this refers to the DbFileSummaryMap held by</div>
<div>1403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * MapLNs</div>
<div>1404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getTreeAdminMemorySize() {</div>
<div>1407&emsp;&emsp;</div>
<div>1408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (getDatabase().getId().equals(DbTree.ID_DB_ID)) {</div>
<div>1409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long treeAdminMem = 0;</div>
<div>1410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            for (int i = 0; i &#60; getMaxEntries(); i++) {</div>
<div>1411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                Node n = getTarget(i);</div>
<div>1412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (n != null) {</div>
<div>1413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    MapLN mapLN = (MapLN) n;</div>
<div>1414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    treeAdminMem += mapLN.getDatabase().getTreeAdminMemory();</div>
<div>1415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return treeAdminMem;</div>
<div>1418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>1420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1422&emsp;&emsp;</div>
<div>1423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Reduce memory consumption. Note that evicting deferred-write LNs may</div>
<div>1425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * require logging them, which will mark this BIN dirty. Compression of</div>
<div>1426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * deleted slots will also mark the BIN dirty.</div>
<div>1427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The BIN should be latched by the caller.</div>
<div>1429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a long number encoding (a) the number of evicted bytes, and</div>
<div>1431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (b) whether this BIN  is evictable. (b) will be false if the BIN has</div>
<div>1432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * any cursors on it, or has any non-evictable children.</div>
<div>1433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long partialEviction() {</div>
<div>1436&emsp;&emsp;</div>
<div>1437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Try compressing non-dirty slots. */</div>
<div>1438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long oldMemSize = inMemorySize;</div>
<div>1439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEnv().lazyCompress(this);</div>
<div style="background-color:limegreen;">1440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oldMemSize > inMemorySize) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return oldMemSize - inMemorySize;</div>
<div>1442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1443&emsp;&emsp;</div>
<div>1444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Try LN eviction. Return if any were evicted. */</div>
<div>1445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long lnBytesAndStatus = evictLNs();</div>
<div style="background-color:limegreen;">1446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if ((lnBytesAndStatus & ~IN.NON_EVICTABLE_IN) != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return lnBytesAndStatus;</div>
<div>1448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1449&emsp;&emsp;</div>
<div>1450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Try discarding the VLSNCache. Return bytes and evictable status. */</div>
<div>1451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return discardVLSNCache() | lnBytesAndStatus;</div>
<div>1452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1453&emsp;&emsp;</div>
<div>1454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long discardVLSNCache() {</div>
<div>1455&emsp;&emsp;</div>
<div>1456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long vlsnBytes = vlsnCache.getMemorySize();</div>
<div>1457&emsp;&emsp;</div>
<div style="background-color:limegreen;">1458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (vlsnBytes > 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1459&emsp;&emsp;</div>
<div>1460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int numEntries = getNEntries();</div>
<div style="background-color:limegreen;">1461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = 0; i &#60; numEntries; ++i) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (isEmbeddedLN(i)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return 0;</div>
<div>1464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1466&emsp;&emsp;</div>
<div>1467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            vlsnCache = EMPTY_VLSNS;</div>
<div>1468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(0 - vlsnBytes);</div>
<div>1469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1470&emsp;&emsp;</div>
<div>1471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return vlsnBytes;</div>
<div>1472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1473&emsp;&emsp;</div>
<div>1474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Reduce memory consumption by evicting all LN targets. Note that this may</div>
<div>1476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cause LNs to be logged, which will mark this BIN dirty.</div>
<div>1477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The BIN should be latched by the caller.</div>
<div>1479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a long number encoding (a) the number of evicted bytes, and</div>
<div>1481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (b) whether this BIN  is evictable. (b) will be false if the BIN has</div>
<div>1482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * any cursors on it, or has any non-evictable children.</div>
<div>1483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long evictLNs()</div>
<div>1485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1486&emsp;&emsp;</div>
<div style="background-color:limegreen;">1487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner() :&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            "BIN must be latched before evicting LNs";</div>
<div>1489&emsp;&emsp;</div>
<div>1490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * We can't evict an LN which is pointed to by a cursor, in case that</div>
<div>1492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * cursor has a reference to the LN object. We'll take the cheap choice</div>
<div>1493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * and avoid evicting any LNs if there are cursors on this BIN. We</div>
<div>1494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * could do a more expensive, precise check to see entries have which</div>
<div>1495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * cursors. This is something we might move to later.</div>
<div>1496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (nCursors() > 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return IN.NON_EVICTABLE_IN;</div>
<div>1499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1500&emsp;&emsp;</div>
<div>1501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Try to evict each child LN. */</div>
<div>1502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long totalRemoved = 0;</div>
<div>1503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long numLNsEvicted = 0;</div>
<div>1504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean haveNonEvictableLN = false;</div>
<div>1505&emsp;&emsp;</div>
<div style="background-color:limegreen;">1506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1507&emsp;&emsp;</div>
<div style="background-color:limegreen;">1508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (getTarget(i) == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>1510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1511&emsp;&emsp;</div>
<div>1512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long lnRemoved = evictLNInternal(i, false /*ifFetchedCold*/);</div>
<div>1513&emsp;&emsp;</div>
<div style="background-color:limegreen;">1514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lnRemoved &#60; 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                haveNonEvictableLN = true;</div>
<div>1516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>1517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                totalRemoved += lnRemoved;</div>
<div>1518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ++numLNsEvicted;</div>
<div>1519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1521&emsp;&emsp;</div>
<div>1522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * compactMemory() may decrease the memory footprint by mutating the</div>
<div>1524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * representations of the target and key sets.</div>
<div>1525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (totalRemoved > 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(totalRemoved, 0);</div>
<div>1528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            totalRemoved += compactMemory();</div>
<div>1529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1530&emsp;&emsp;</div>
<div>1531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEvictor().incNumLNsEvicted(numLNsEvicted);</div>
<div>1532&emsp;&emsp;</div>
<div style="background-color:limegreen;">1533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (haveNonEvictableLN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return (totalRemoved | IN.NON_EVICTABLE_IN);</div>
<div>1535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return totalRemoved;</div>
<div>1537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1539&emsp;&emsp;</div>
<div>1540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void evictLN(int index) {</div>
<div>1541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        evictLN(index, false /*ifFetchedCold*/);</div>
<div>1542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1543&emsp;&emsp;</div>
<div>1544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void evictLN(int index, boolean ifFetchedCold)</div>
<div>1545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1546&emsp;&emsp;</div>
<div>1547&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long removed = evictLNInternal(index, ifFetchedCold);</div>
<div>1548&emsp;&emsp;</div>
<div>1549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* May decrease the memory footprint by changing the INTargetRep. */</div>
<div style="background-color:limegreen;">1550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (removed > 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(removed, 0);</div>
<div>1552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            compactMemory();</div>
<div>1553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1554&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1555&emsp;&emsp;</div>
<div>1556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Evict a single LN if allowed. The amount of memory freed is returned</div>
<div>1558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and must be subtracted from the memory budget by the caller.</div>
<div>1559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param ifFetchedCold If true, evict the LN only if it has the</div>
<div>1561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * FetchedCold flag set.</div>
<div>1562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return number of evicted bytes or -1 if the LN is not evictable.</div>
<div>1564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private long evictLNInternal(int index, boolean ifFetchedCold)</div>
<div>1566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1567&emsp;&emsp;</div>
<div>1568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Node n = getTarget(index);</div>
<div>1569&emsp;&emsp;</div>
<div style="background-color:limegreen;">1570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(n == null || n instanceof LN);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1571&emsp;&emsp;</div>
<div style="background-color:limegreen;">1572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (n == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>1574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1575&emsp;&emsp;</div>
<div>1576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final LN ln = (LN) n;</div>
<div>1577&emsp;&emsp;</div>
<div style="background-color:limegreen;">1578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ifFetchedCold && !ln.getFetchedCold()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>1580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1581&emsp;&emsp;</div>
<div>1582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Don't evict MapLNs for open databases (LN.isEvictable) [#13415].</div>
<div>1584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1585&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!ln.isEvictable(getLsn(index))) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return -1;</div>
<div>1587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1588&emsp;&emsp;</div>
<div>1589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Log target if necessary. Do not allow eviction since we evict</div>
<div>1591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * here and that would cause double-counting of the memory freed.</div>
<div>1592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>1593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        logDirtyLN(index, ln, false /*allowEviction*/);</div>
<div>1594&emsp;&emsp;</div>
<div>1595&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Clear target. */</div>
<div>1596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(index, null);</div>
<div>1597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ln.releaseMemoryBudget();</div>
<div>1598&emsp;&emsp;</div>
<div>1599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</div>
<div style="background-color:limegreen;">1600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ohCache.isEnabled()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.storeEvictedLN(this, index, ln);</div>
<div>1602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1603&emsp;&emsp;</div>
<div>1604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return n.getMemorySizeIncludedByParent();</div>
<div>1605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1606&emsp;&emsp;</div>
<div>1607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see IN#logDirtyChildren</div>
<div>1609&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void logDirtyChildren()</div>
<div>1612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1613&emsp;&emsp;</div>
<div>1614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Look for LNs that are dirty or have never been logged before. */</div>
<div style="background-color:limegreen;">1615&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1616&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Node node = getTarget(i);</div>
<div style="background-color:limegreen;">1617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (node != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logDirtyLN(i, (LN) node, true /*allowEviction*/);</div>
<div>1619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1622&emsp;&emsp;</div>
<div>1623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Logs the LN at the given index if it is dirty.</div>
<div>1625&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void logDirtyLN(</div>
<div>1627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>1628&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LN ln,</div>
<div>1629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean allowEviction)</div>
<div>1630&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>1631&emsp;&emsp;</div>
<div>1632&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long currLsn = getLsn(idx);</div>
<div>1633&emsp;&emsp;</div>
<div style="background-color:limegreen;">1634&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final boolean force = getDatabase().isDeferredWriteMode() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1635&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                              DbLsn.isTransientOrNull(currLsn);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1636&emsp;&emsp;</div>
<div style="background-color:limegreen;">1637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (force || ln.isDirty()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final DatabaseImpl dbImpl = getDatabase();</div>
<div>1639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final EnvironmentImpl envImpl = dbImpl.getEnv();</div>
<div>1640&emsp;&emsp;</div>
<div>1641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Only deferred write databases should have dirty LNs. */</div>
<div style="background-color:limegreen;">1642&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(dbImpl.isDeferredWriteMode() || ln instanceof MapLN);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1643&emsp;&emsp;</div>
<div>1644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1645&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Do not lock while logging.  Locking of new LSN is performed by</div>
<div>1646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * lockAfterLsnChange. This should never be part of the replication</div>
<div>1647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * stream, because this is a deferred-write DB.</div>
<div>1648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>1649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * No reason to include the previous record version in this logrec</div>
<div>1650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * because this logrec will never be undone (DW databases are</div>
<div>1651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * non-transactional)</div>
<div>1652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final LogItem logItem = ln.log(</div>
<div>1654&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                envImpl, dbImpl, null /*locker*/, null /*writeLockInfo*/,</div>
<div>1655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                isEmbeddedLN(idx), getKey(idx),</div>
<div>1656&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getExpiration(idx), isExpirationInHours(),</div>
<div>1657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                isEmbeddedLN(idx), currLsn, getLastLoggedSize(idx),</div>
<div>1658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                false/*isInsertion*/, true /*backgroundIO*/,</div>
<div>1659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ReplicationContext.NO_REPLICATE);</div>
<div>1660&emsp;&emsp;</div>
<div>1661&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateEntry(</div>
<div>1662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                idx, logItem.lsn, ln.getVLSNSequence(),</div>
<div>1663&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logItem.size);</div>
<div>1664&emsp;&emsp;</div>
<div>1665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Lock new LSN on behalf of existing lockers. */</div>
<div>1666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            CursorImpl.lockAfterLsnChange(</div>
<div>1667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                dbImpl, currLsn, logItem.lsn, null /*excludeLocker*/);</div>
<div>1668&emsp;&emsp;</div>
<div>1669&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * It is desirable to evict a non-dirty LN that is immediately</div>
<div>1671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * obsolete, because it will never be fetched again.</div>
<div>1672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">1673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (allowEviction &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                (databaseImpl.isLNImmediatelyObsolete() ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                 isEmbeddedLN(idx))) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                evictLN(idx);</div>
<div>1677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1679&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1680&emsp;&emsp;</div>
<div>1681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Logging support</div>
<div>1683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1684&emsp;&emsp;</div>
<div>1685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see IN#getLogType</div>
<div>1687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public LogEntryType getLogType() {</div>
<div>1690&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return LogEntryType.LOG_BIN;</div>
<div>1691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1692&emsp;&emsp;</div>
<div>1693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overrides the IN method to account for deltas.</div>
<div>1695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Public for unit testing.</div>
<div>1696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getLastDeltaLsn() {</div>
<div>1699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return lastDeltaVersion;</div>
<div>1700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1701&emsp;&emsp;</div>
<div>1702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setLastDeltaLsn(long lsn) {</div>
<div>1703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastDeltaVersion = lsn;</div>
<div>1704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1705&emsp;&emsp;</div>
<div>1706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN delta support</div>
<div>1708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1709&emsp;&emsp;</div>
<div>1710&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getFullBinNEntries() {</div>
<div style="background-color:limegreen;">1711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return fullBinNEntries;</div>
<div>1713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return nEntries;</div>
<div>1715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1717&emsp;&emsp;</div>
<div>1718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setFullBinNEntries(int n) {</div>
<div>1719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(isBINDelta(false));</div>
<div>1720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        fullBinNEntries = n;</div>
<div>1721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1722&emsp;&emsp;</div>
<div>1723&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void incFullBinNEntries() {</div>
<div style="background-color:limegreen;">1724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ++fullBinNEntries;</div>
<div>1726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1727&emsp;&emsp;</div>
<div>1728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getFullBinMaxEntries() {</div>
<div style="background-color:limegreen;">1729&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return fullBinMaxEntries;</div>
<div>1731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return getMaxEntries();</div>
<div>1733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1735&emsp;&emsp;</div>
<div>1736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setFullBinMaxEntries(int n) {</div>
<div>1737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(isBINDelta(false));</div>
<div>1738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        fullBinMaxEntries = n;</div>
<div>1739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1740&emsp;&emsp;</div>
<div>1741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int getDeltaCapacity(int numDirtyEntries) {</div>
<div>1742&emsp;&emsp;</div>
<div>1743&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean blindOps =</div>
<div style="background-color:limegreen;">1744&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            (getEnv().allowBlindOps() || getEnv().allowBlindPuts());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1745&emsp;&emsp;</div>
<div style="background-color:limegreen;">1746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return getMaxEntries();</div>
<div>1748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1749&emsp;&emsp;</div>
<div style="background-color:limegreen;">1750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (blindOps) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return (getNEntries() * databaseImpl.getBinDeltaPercent()) / 100;</div>
<div>1752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1753&emsp;&emsp;</div>
<div>1754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return numDirtyEntries;</div>
<div>1755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1756&emsp;&emsp;</div>
<div>1757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean allowBlindPuts() {</div>
<div>1758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean res = getEnv().allowBlindPuts();</div>
<div>1759&emsp;&emsp;</div>
<div style="background-color:limegreen;">1760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (res) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            res = res && databaseImpl.hasBtreeBinaryEqualityComparator();&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">1762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            res = res && databaseImpl.hasDuplicateBinaryEqualityComparator();&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>1763&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1764&emsp;&emsp;</div>
<div>1765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return res;</div>
<div>1766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1767&emsp;&emsp;</div>
<div>1768&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1769&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It is called in 3 cases listed below. In all cases, if blind puts are</div>
<div>1770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * not allowed, the method returns null.</div>
<div>1771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 1. A full BIN is being mutated to an in-memory delta. A new filter will</div>
<div>1773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    be created here and will be stored in the delta by the caller.</div>
<div>1774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 2. A full BIN is being logged as a delta. A new filter will be created</div>
<div>1775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    here and will be written in the delta logrec by the caller.</div>
<div>1776&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 3. An in-memory BIN-delta is being logged. If the delta has a bloom</div>
<div>1777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    filter already, that filter will be returned and written into the</div>
<div>1778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    logrec. The delta may not have a filter already because it was read</div>
<div>1779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    from an older-version logfile; in this case we return null.</div>
<div>1780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    byte[] createBloomFilter() {</div>
<div>1782&emsp;&emsp;</div>
<div style="background-color:limegreen;">1783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(bloomFilter == null || isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1784&emsp;&emsp;</div>
<div>1785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean blindPuts = allowBlindPuts();</div>
<div>1786&emsp;&emsp;</div>
<div style="background-color:limegreen;">1787&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!blindPuts) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(bloomFilter == null);&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1789&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return null;</div>
<div>1790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1791&emsp;&emsp;</div>
<div style="background-color:limegreen;">1792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bloomFilter != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * We are here because we are logging a delta that has a filter</div>
<div>1795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * already. We just need to log the existing filter.</div>
<div>1796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return bloomFilter;</div>
<div>1798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1799&emsp;&emsp;</div>
<div style="background-color:limegreen;">1800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return null;</div>
<div>1802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1803&emsp;&emsp;</div>
<div>1804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int numKeys = getNEntries() - getNDeltas();</div>
<div>1805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int nbytes = BINDeltaBloomFilter.getByteSize(numKeys);</div>
<div>1806&emsp;&emsp;</div>
<div>1807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] bf = new byte[nbytes];</div>
<div>1808&emsp;&emsp;</div>
<div>1809&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        BINDeltaBloomFilter.HashContext hc =</div>
<div>1810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            new BINDeltaBloomFilter.HashContext();</div>
<div>1811&emsp;&emsp;</div>
<div style="background-color:limegreen;">1812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (keyPrefix != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            hc.hashKeyPrefix(keyPrefix);</div>
<div>1814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1815&emsp;&emsp;</div>
<div style="background-color:limegreen;">1816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); ++i) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1817&emsp;&emsp;</div>
<div style="background-color:limegreen;">1818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isDirty(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1819&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>1820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1821&emsp;&emsp;</div>
<div>1822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte[] suffix = entryKeys.getKey(i, haveEmbeddedData(i));</div>
<div style="background-color:limegreen;">1823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (suffix == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                suffix = Key.EMPTY_KEY;</div>
<div>1825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1826&emsp;&emsp;</div>
<div>1827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            BINDeltaBloomFilter.add(bf, suffix, hc);</div>
<div>1828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1829&emsp;&emsp;</div>
<div>1830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return bf;</div>
<div>1831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1832&emsp;&emsp;</div>
<div>1833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean mayHaveKeyInFullBin(byte[] key) {</div>
<div>1834&emsp;&emsp;</div>
<div style="background-color:limegreen;">1835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1836&emsp;&emsp;</div>
<div style="background-color:limegreen;">1837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bloomFilter == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1840&emsp;&emsp;</div>
<div>1841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return BINDeltaBloomFilter.contains(bloomFilter, key);</div>
<div>1842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1843&emsp;&emsp;</div>
<div>1844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used in IN.getLogSize() only</div>
<div>1846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int getBloomFilterLogSize() {</div>
<div>1848&emsp;&emsp;</div>
<div style="background-color:limegreen;">1849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!allowBlindPuts()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>1851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1852&emsp;&emsp;</div>
<div style="background-color:limegreen;">1853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">1854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (bloomFilter != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1855&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return BINDeltaBloomFilter.getLogSize(bloomFilter);</div>
<div>1856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1857&emsp;&emsp;</div>
<div>1858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>1859&emsp;&emsp;</div>
<div>1860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">1861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(bloomFilter == null);&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>1862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int numKeys = getNEntries() - getNDeltas();</div>
<div>1863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return BINDeltaBloomFilter.getLogSize(numKeys);</div>
<div>1864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1865&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1866&emsp;&emsp;</div>
<div>1867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isDeltaProhibited() {</div>
<div style="background-color:limegreen;">1868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (getProhibitNextDelta() ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1869&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            getDatabase().isDeferredWriteMode() ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1870&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            getLastFullLsn() == DbLsn.NULL_LSN);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1871&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1872&emsp;&emsp;</div>
<div>1873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Decide whether to log a full or partial BIN, depending on the ratio of</div>
<div>1875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the delta size to full BIN size.</div>
<div>1876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1877&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Other factors are taken into account:</div>
<div>1878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * + a delta cannot be logged if the BIN has never been logged before</div>
<div>1879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * + deltas are not currently supported for DeferredWrite databases</div>
<div>1880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * + this particular delta may have been prohibited because the cleaner is</div>
<div>1881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   migrating the BIN or a dirty slot has been removed</div>
<div>1882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * + if there are no dirty slots, we might as well log a full BIN</div>
<div>1883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The restriction on using BIN-deltas for deferred-write DBs is for</div>
<div>1885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * reasons that are probably no longer relevant. However, we have not</div>
<div>1886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * tested deltas with DW, so we still prohibit them. Because BIN-deltas</div>
<div>1887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * may be in cache at the time a DB is opened in DW mode, a workaround is</div>
<div>1888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * currently necessary: see Database.mutateDeferredWriteBINDeltas.</div>
<div>1889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if we should log the deltas of this BIN</div>
<div>1891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean shouldLogDelta() {</div>
<div>1893&emsp;&emsp;</div>
<div style="background-color:limegreen;">1894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1895&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Cannot assert that db is not in DeferredWrite mode.</div>
<div>1897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * See Database.mutateDeferredWriteBINDeltas.</div>
<div>1898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">1899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert !getProhibitNextDelta();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert getLastFullLsn() != DbLsn.NULL_LSN;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1903&emsp;&emsp;</div>
<div>1904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Cheapest checks first. */</div>
<div style="background-color:limegreen;">1905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isDeltaProhibited()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1908&emsp;&emsp;</div>
<div>1909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Must count deltas to check further. */</div>
<div>1910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int numDeltas = getNDeltas();</div>
<div>1911&emsp;&emsp;</div>
<div>1912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* A delta with zero items is not valid. */</div>
<div style="background-color:limegreen;">1913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (numDeltas &#60;= 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1916&emsp;&emsp;</div>
<div>1917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Check the configured BinDeltaPercent. */</div>
<div>1918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int deltaLimit =</div>
<div>1919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            (getNEntries() * databaseImpl.getBinDeltaPercent()) / 100;</div>
<div>1920&emsp;&emsp;</div>
<div style="background-color:limegreen;">1921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return numDeltas &#60;= deltaLimit;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1923&emsp;&emsp;</div>
<div>1924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1925&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether mutateToBINDelta can be called.</div>
<div>1926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean canMutateToBINDelta() {</div>
<div style="background-color:limegreen;">1928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (!isBINDelta() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                shouldLogDelta() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                (nCursors() == 0));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1932&emsp;&emsp;</div>
<div>1933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Mutate to a delta (discard non-dirty entries and resize arrays).</div>
<div>1935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method must be called with this node latched exclusively, and</div>
<div>1937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * canMutateToBINDelta must return true.</div>
<div>1938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the number of bytes freed.</div>
<div>1940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long mutateToBINDelta() {</div>
<div>1942&emsp;&emsp;</div>
<div style="background-color:limegreen;">1943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">1944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert canMutateToBINDelta();&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>1945&emsp;&emsp;</div>
<div style="background-color:limegreen;">1946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getInListResident()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEnv().getInMemoryINs().updateBINDeltaStat(1);</div>
<div>1948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1949&emsp;&emsp;</div>
<div>1950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long oldSize = getInMemorySize();</div>
<div>1951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int nDeltas = getNDeltas();</div>
<div>1952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int capacity = getDeltaCapacity(nDeltas);</div>
<div>1953&emsp;&emsp;</div>
<div>1954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bloomFilter = createBloomFilter();</div>
<div>1955&emsp;&emsp;</div>
<div>1956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        initBINDelta(this, nDeltas, capacity, true);</div>
<div>1957&emsp;&emsp;</div>
<div>1958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return oldSize - getInMemorySize();</div>
<div>1959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1960&emsp;&emsp;</div>
<div>1961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method assumes that "this" BIN is a delta and creates a clone of</div>
<div>1963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * it. It is currently used by the DiskOrderedScanner only. The method</div>
<div>1964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * does not clone the targets array.</div>
<div>1965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public BIN cloneBINDelta() {</div>
<div>1967&emsp;&emsp;</div>
<div>1968&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(isBINDelta());</div>
<div>1969&emsp;&emsp;</div>
<div>1970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN bin = new BIN(</div>
<div>1971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            databaseImpl, getIdentifierKey(), 0/*capacity*/, getLevel());</div>
<div>1972&emsp;&emsp;</div>
<div>1973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.nodeId = nodeId;</div>
<div>1974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.flags = flags;</div>
<div>1975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.lastFullVersion = lastFullVersion;</div>
<div>1976&emsp;&emsp;</div>
<div>1977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int nDeltas = getNDeltas();</div>
<div>1978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        initBINDelta(bin, nDeltas, nDeltas, false);</div>
<div>1979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return bin;</div>
<div>1980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1981&emsp;&emsp;</div>
<div>1982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Replaces the contents of destBIN with the deltas in this BIN.</div>
<div>1984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void initBINDelta(</div>
<div>1986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN destBIN,</div>
<div>1987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int nDeltas,</div>
<div>1988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int capacity,</div>
<div>1989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean copyTargets) {</div>
<div>1990&emsp;&emsp;</div>
<div>1991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long[] longLSNs = null;</div>
<div>1992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] compactLSNs = null;</div>
<div>1993&emsp;&emsp;</div>
<div style="background-color:limegreen;">1994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryLsnLongArray == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            compactLSNs = new byte[nDeltas * 4];</div>
<div>1996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            longLSNs = new long[nDeltas];</div>
<div>1998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1999&emsp;&emsp;</div>
<div>2000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long[] vlsns = new long[nDeltas];</div>
<div>2001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int[] sizes = new int[nDeltas];</div>
<div>2002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[][] keys = new byte[nDeltas][];</div>
<div>2003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] states = new byte[nDeltas];</div>
<div>2004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long[] memIds = null;</div>
<div>2005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node[] targets = null;</div>
<div>2006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int[] expiration = null;</div>
<div>2007&emsp;&emsp;</div>
<div style="background-color:limegreen;">2008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (copyTargets) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            targets = new Node[nDeltas];</div>
<div>2010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            memIds = new long[nDeltas];</div>
<div>2011&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2012&emsp;&emsp;</div>
<div style="background-color:limegreen;">2013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (expirationBase != -1) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expiration = new int[nDeltas];</div>
<div>2015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2016&emsp;&emsp;</div>
<div>2017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int j = 0;</div>
<div style="background-color:limegreen;">2018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); i += 1) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2019&emsp;&emsp;</div>
<div style="background-color:limegreen;">2020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!isDirty(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                freeOffHeapLN(i);</div>
<div>2022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>2023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2024&emsp;&emsp;</div>
<div style="background-color:limegreen;">2025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (entryLsnLongArray == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int doff = j &#60;&#60; 2;</div>
<div>2027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int soff = i &#60;&#60; 2;</div>
<div>2028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                compactLSNs[doff] = entryLsnByteArray[soff];</div>
<div>2029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                compactLSNs[doff+1] = entryLsnByteArray[soff+1];</div>
<div>2030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                compactLSNs[doff+2] = entryLsnByteArray[soff+2];</div>
<div>2031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                compactLSNs[doff+3] = entryLsnByteArray[soff+3];</div>
<div>2032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>2033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                longLSNs[j] = getLsn(i);</div>
<div>2034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2035&emsp;&emsp;</div>
<div>2036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            keys[j] = entryKeys.get(i);</div>
<div>2037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            states[j] = getState(i);</div>
<div>2038&emsp;&emsp;</div>
<div style="background-color:limegreen;">2039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (targets != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                targets[j] = getTarget(i);</div>
<div>2041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2042&emsp;&emsp;</div>
<div style="background-color:limegreen;">2043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (memIds != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                memIds[j] = getOffHeapLNId(i);</div>
<div>2045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2046&emsp;&emsp;</div>
<div>2047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            vlsns[j] = getCachedVLSN(i);</div>
<div>2048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sizes[j] = getLastLoggedSize(i);</div>
<div>2049&emsp;&emsp;</div>
<div style="background-color:limegreen;">2050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (expiration != null) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>2051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                expiration[j] = getExpiration(i);</div>
<div>2052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2053&emsp;&emsp;</div>
<div>2054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            j += 1;</div>
<div>2055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2056&emsp;&emsp;</div>
<div>2057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>2058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Do this before resetContent() because destBIN and "this" may be the</div>
<div>2059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * same java obj</div>
<div>2060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>2061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        destBIN.fullBinNEntries = getFullBinNEntries();</div>
<div>2062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        destBIN.fullBinMaxEntries = getFullBinMaxEntries();</div>
<div>2063&emsp;&emsp;</div>
<div>2064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        destBIN.resetContent(</div>
<div>2065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            capacity, nDeltas,</div>
<div>2066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            baseFileNumber, compactLSNs, longLSNs,</div>
<div>2067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            states, keyPrefix, keys, targets,</div>
<div>2068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sizes, memIds, vlsns,</div>
<div>2069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expiration, isExpirationInHours());</div>
<div>2070&emsp;&emsp;</div>
<div>2071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        destBIN.setBINDelta(true);</div>
<div>2072&emsp;&emsp;</div>
<div>2073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        destBIN.compactMemory();</div>
<div>2074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2075&emsp;&emsp;</div>
<div>2076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Replaces the contents of this BIN with the given contents.</div>
<div>2078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used in mutating a full BIN to a BIN-delta or for creating</div>
<div>2079&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a new BIN delta with the given content.</div>
<div>2080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void resetContent(</div>
<div>2082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int capacity,</div>
<div>2083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int newNEntries,</div>
<div>2084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long baseFileNumber,</div>
<div>2085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] compactLSNs,</div>
<div>2086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long[] longLSNs,</div>
<div>2087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] states,</div>
<div>2088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] keyPrefix,</div>
<div>2089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[][] keys,</div>
<div>2090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Node[] targets,</div>
<div>2091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int[] loggedSizes,</div>
<div>2092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long[] memIds,</div>
<div>2093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long[] vlsns,</div>
<div>2094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int[] expiration,</div>
<div>2095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean expirationInHours) {</div>
<div>2096&emsp;&emsp;</div>
<div>2097&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateRepCacheStats(false);</div>
<div>2098&emsp;&emsp;</div>
<div>2099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nEntries = newNEntries;</div>
<div>2100&emsp;&emsp;</div>
<div>2101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.baseFileNumber = baseFileNumber;</div>
<div>2102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (longLSNs == null) {</div>
<div>2103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = new byte[capacity &#60;&#60; 2];</div>
<div>2104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = null;</div>
<div>2105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>2106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = null;</div>
<div>2107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = new long[capacity];</div>
<div>2108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2109&emsp;&emsp;</div>
<div>2110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.keyPrefix = keyPrefix;</div>
<div>2111&emsp;&emsp;</div>
<div>2112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = new INKeyRep.Default(capacity);</div>
<div>2113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = INTargetRep.NONE;</div>
<div>2114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        vlsnCache = EMPTY_VLSNS;</div>
<div>2115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastLoggedSizes = EMPTY_LAST_LOGGED_SIZES;</div>
<div>2116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationValues = EMPTY_EXPIRATION;</div>
<div>2117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationBase = -1;</div>
<div>2118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = EMPTY_OFFHEAP_LN_IDS;</div>
<div>2119&emsp;&emsp;</div>
<div>2120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateRepCacheStats(true);</div>
<div>2121&emsp;&emsp;</div>
<div>2122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates = new byte[capacity];</div>
<div>2123&emsp;&emsp;</div>
<div>2124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; newNEntries; i += 1) {</div>
<div>2125&emsp;&emsp;</div>
<div>2126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (longLSNs == null) {</div>
<div>2127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int off = i &#60;&#60; 2;</div>
<div>2128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnByteArray[off] = compactLSNs[off];</div>
<div>2129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnByteArray[off+1] = compactLSNs[off+1];</div>
<div>2130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnByteArray[off+2] = compactLSNs[off+2];</div>
<div>2131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnByteArray[off+3] = compactLSNs[off+3];</div>
<div>2132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>2133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnLongArray[i] = longLSNs[i];</div>
<div>2134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2135&emsp;&emsp;</div>
<div>2136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.set(i, keys[i], this);</div>
<div>2137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[i] = states[i];</div>
<div>2138&emsp;&emsp;</div>
<div>2139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (targets != null) {</div>
<div>2140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryTargets = entryTargets.set(i, targets[i], this);</div>
<div>2141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2142&emsp;&emsp;</div>
<div>2143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (memIds != null) {</div>
<div>2144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setOffHeapLNId(i, memIds[i]);</div>
<div>2145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2146&emsp;&emsp;</div>
<div>2147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (expiration != null) {</div>
<div>2148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setExpiration(i, expiration[i], expirationInHours);</div>
<div>2149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2150&emsp;&emsp;</div>
<div>2151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastLoggedSizeUnconditional(i, loggedSizes[i]);</div>
<div>2152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setCachedVLSNUnconditional(i, vlsns[i]);</div>
<div>2153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2154&emsp;&emsp;</div>
<div>2155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>2156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2157&emsp;&emsp;</div>
<div>2158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Fetch the full BIN and apply the deltas in this BIN to it, then use the</div>
<div>2160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * merged result to replace the contents of this BIN.</div>
<div>2161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method must be called with this node latched exclusively. If 'this'</div>
<div>2163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is not a delta, this method does nothing.</div>
<div>2164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>2166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void mutateToFullBIN(boolean leaveFreeSlot) {</div>
<div>2167&emsp;&emsp;</div>
<div style="background-color:limegreen;">2168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>2170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2171&emsp;&emsp;</div>
<div>2172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN fullBIN = fetchFullBIN(databaseImpl);</div>
<div>2173&emsp;&emsp;</div>
<div>2174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        mutateToFullBIN(fullBIN, leaveFreeSlot);</div>
<div>2175&emsp;&emsp;</div>
<div>2176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEvictor().incFullBINMissStats();</div>
<div>2177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2178&emsp;&emsp;</div>
<div>2179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Mutates this delta to a full BIN by applying this delta to the fullBIN</div>
<div>2181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * param and then replacing this BIN's contents with it.</div>
<div>2182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method must be called with this node latched exclusively. 'this'</div>
<div>2184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * must be a delta.</div>
<div>2185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * After mutation, the full BIN is compressed and compacted. The</div>
<div>2187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * compression is particularly important, since BIN-deltas in cache cannot</div>
<div>2188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be compressed.</div>
<div>2189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The method is public because it is called directly from FileProcessor</div>
<div>2191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * when it finds a BIN that must be migrated. In that case, fullBIN is a</div>
<div>2192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * full BIN that has just been read from the log, and it is not part of</div>
<div>2193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the memory-resident tree.</div>
<div>2194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void mutateToFullBIN(BIN fullBIN, boolean leaveFreeSlot) {</div>
<div>2196&emsp;&emsp;</div>
<div style="background-color:limegreen;">2197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isBINDelta() : this;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2199&emsp;&emsp;</div>
<div>2200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[][] keys = null;</div>
<div>2201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int i = 0;</div>
<div>2202&emsp;&emsp;</div>
<div style="background-color:limegreen;">2203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursorSet != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            keys = new byte[cursorSet.size()][];</div>
<div>2205&emsp;&emsp;</div>
<div style="background-color:limegreen;">2206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (CursorImpl cursor : cursorSet) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                final int index = cursor.getIndex();</div>
<div style="background-color:limegreen;">2208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (index >= 0 && index &#60; getNEntries()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    keys[i] = cursor.getCurrentKey(true/*isLatched*/);</div>
<div>2210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ++i;</div>
<div>2212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2214&emsp;&emsp;</div>
<div>2215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        reconstituteBIN(databaseImpl, fullBIN, leaveFreeSlot);</div>
<div>2216&emsp;&emsp;</div>
<div>2217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        resetContent(fullBIN);</div>
<div>2218&emsp;&emsp;</div>
<div>2219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setBINDelta(false);</div>
<div>2220&emsp;&emsp;</div>
<div style="background-color:limegreen;">2221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cursorSet != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2222&emsp;&emsp;</div>
<div>2223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            i = 0;</div>
<div style="background-color:limegreen;">2224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (CursorImpl cursor : cursorSet) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2225&emsp;&emsp;</div>
<div style="background-color:limegreen;">2226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (keys[i] != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    /*</div>
<div>2228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                     * Do not ask for an exact match from findEntry because if</div>
<div>2229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                     * the cursor was on a KD slot, findEntry would return -1.</div>
<div>2230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                     */</div>
<div>2231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    int index = findEntry(keys[i], true, false);</div>
<div>2232&emsp;&emsp;</div>
<div style="background-color:limegreen;">2233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if ((index & IN.EXACT_MATCH) == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        throw EnvironmentFailureException.unexpectedState(</div>
<div>2235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            getEnv(), "Failed to reposition cursor during " +</div>
<div>2236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            "mutation of a BIN delta to a full BIN");</div>
<div>2237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2238&emsp;&emsp;</div>
<div>2239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    index &= ~IN.EXACT_MATCH;</div>
<div>2240&emsp;&emsp;</div>
<div style="background-color:limegreen;">2241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    assert(index >= 0 && index &#60; getNEntries());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    cursor.setIndex(index);</div>
<div>2243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ++i;</div>
<div>2245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2247&emsp;&emsp;</div>
<div>2248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEnv().lazyCompress(this);</div>
<div>2249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        compactMemory();</div>
<div>2250&emsp;&emsp;</div>
<div style="background-color:limegreen;">2251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getInListResident()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEnv().getInMemoryINs().updateBINDeltaStat(-1);</div>
<div>2253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2255&emsp;&emsp;</div>
<div>2256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private BIN fetchFullBIN(DatabaseImpl dbImpl) {</div>
<div>2257&emsp;&emsp;</div>
<div>2258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = dbImpl.getEnv();</div>
<div>2259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long lsn = getLastFullLsn();</div>
<div>2260&emsp;&emsp;</div>
<div>2261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        try {</div>
<div>2262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return (BIN)</div>
<div>2263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                envImpl.getLogManager().getEntryHandleFileNotFound(lsn);</div>
<div>2264&emsp;&emsp;</div>
<div>2265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } catch (EnvironmentFailureException e) {</div>
<div>2266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            e.addErrorMessage(makeFetchErrorMsg(null, lsn, -1));</div>
<div>2267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw e;</div>
<div>2268&emsp;&emsp;</div>
<div>2269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } catch (RuntimeException e) {</div>
<div>2270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw new EnvironmentFailureException(</div>
<div>2271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                envImpl, EnvironmentFailureReason.LOG_INTEGRITY,</div>
<div>2272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                makeFetchErrorMsg(e.toString(), lsn, -1), e);</div>
<div>2273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2275&emsp;&emsp;</div>
<div>2276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Replaces the contents of this BIN with the contents of the given BIN,</div>
<div>2278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * including lsns, states, keys and targets.  Key prefixing and key/target</div>
<div>2279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * representations will also be those of the given BIN.</div>
<div>2280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void resetContent(final BIN other) {</div>
<div>2282&emsp;&emsp;</div>
<div>2283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateRepCacheStats(false);</div>
<div>2284&emsp;&emsp;</div>
<div>2285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nEntries = other.nEntries;</div>
<div>2286&emsp;&emsp;</div>
<div>2287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        baseFileNumber = other.baseFileNumber;</div>
<div>2288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray = other.entryLsnByteArray;</div>
<div>2289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnLongArray = other.entryLsnLongArray;</div>
<div>2290&emsp;&emsp;</div>
<div>2291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        keyPrefix = other.keyPrefix;</div>
<div>2292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = other.entryKeys;</div>
<div>2293&emsp;&emsp;</div>
<div>2294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = other.entryTargets;</div>
<div>2295&emsp;&emsp;</div>
<div>2296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates = other.entryStates;</div>
<div>2297&emsp;&emsp;</div>
<div>2298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastLoggedSizes = other.lastLoggedSizes;</div>
<div>2299&emsp;&emsp;</div>
<div>2300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationValues = other.expirationValues;</div>
<div>2301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationBase = other.expirationBase;</div>
<div>2302&emsp;&emsp;</div>
<div>2303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = other.offHeapLNIds;</div>
<div style="background-color:limegreen;">2304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert (getOffHeapLruId() >= 0) || !hasOffHeapLNs();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2305&emsp;&emsp;</div>
<div>2306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        vlsnCache = other.vlsnCache;</div>
<div>2307&emsp;&emsp;</div>
<div>2308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bloomFilter = null;</div>
<div>2309&emsp;&emsp;</div>
<div>2310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>2311&emsp;&emsp;</div>
<div>2312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateRepCacheStats(true);</div>
<div>2313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2314&emsp;&emsp;</div>
<div>2315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void resize(final int newCapacity) {</div>
<div>2316&emsp;&emsp;</div>
<div style="background-color:limegreen;">2317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert newCapacity >= getNEntries();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2318&emsp;&emsp;</div>
<div>2319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateRepCacheStats(false);</div>
<div>2320&emsp;&emsp;</div>
<div style="background-color:limegreen;">2321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryLsnByteArray != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = Arrays.copyOfRange(</div>
<div>2323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnByteArray, 0, newCapacity * 4);</div>
<div>2324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div style="background-color:limegreen;">2325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryLsnLongArray != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = Arrays.copyOfRange(</div>
<div>2327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnLongArray, 0, newCapacity);</div>
<div>2328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div style="background-color:limegreen;">2329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryStates != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates = Arrays.copyOfRange(</div>
<div>2331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryStates, 0, newCapacity);</div>
<div>2332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2333&emsp;&emsp;</div>
<div>2334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = entryKeys.resize(newCapacity);</div>
<div>2335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = entryTargets.resize(newCapacity);</div>
<div>2336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastLoggedSizes = lastLoggedSizes.resize(newCapacity);</div>
<div>2337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        expirationValues = expirationValues.resize(newCapacity);</div>
<div>2338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapLNIds = offHeapLNIds.resize(newCapacity);</div>
<div>2339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        vlsnCache = vlsnCache.resize(newCapacity);</div>
<div>2340&emsp;&emsp;</div>
<div>2341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>2342&emsp;&emsp;</div>
<div>2343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateRepCacheStats(true);</div>
<div>2344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2345&emsp;&emsp;</div>
<div>2346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Create a BIN by fetching its most recent full version from the log and</div>
<div>2348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * applying to it the deltas in this BIN delta. The new BIN is not added</div>
<div>2349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to the INList or the BTree.</div>
<div>2350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called from DiskOrderedScanner.fetchAndProcessBINs() and</div>
<div>2352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * DiskOrderedScanner.accumulateLNs()</div>
<div>2353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the full BIN with deltas applied.</div>
<div>2355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public BIN reconstituteBIN(DatabaseImpl dbImpl) {</div>
<div>2357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN fullBIN = fetchFullBIN(dbImpl);</div>
<div>2358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        reconstituteBIN(dbImpl, fullBIN, false /*leaveFreeSlot*/);</div>
<div>2359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return fullBIN;</div>
<div>2360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2361&emsp;&emsp;</div>
<div>2362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Given a full version BIN, apply to it the deltas in this BIN delta. The</div>
<div>2364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * fullBIN will then be complete, but its memory will not be compacted.</div>
<div>2365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called from mutateToFullBIN() above and from SortedLSNTreewalker.</div>
<div>2367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param leaveFreeSlot should be true if a slot will be inserted into the</div>
<div>2369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * resulting full BIN, without first checking whether the full BIN must be</div>
<div>2370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * split, and performing the split if necessary. If this param is true, the</div>
<div>2371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * returned BIN will contain at least one free slot. If this param is</div>
<div>2372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * false, a BIN with no free slots may be returned. For example, it is</div>
<div>2373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * important that false is passed when a split will be performed, since if</div>
<div>2374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * true were passed, the BIN would grow beyond its bounds unnecessarily.</div>
<div>2375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void reconstituteBIN(</div>
<div>2377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        DatabaseImpl dbImpl,</div>
<div>2378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        BIN fullBIN,</div>
<div>2379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean leaveFreeSlot) {</div>
<div>2380&emsp;&emsp;</div>
<div>2381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        fullBIN.setDatabase(dbImpl);</div>
<div>2382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        fullBIN.latch(CacheMode.UNCHANGED);</div>
<div>2383&emsp;&emsp;</div>
<div>2384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        try {</div>
<div style="background-color:limegreen;">2385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (databaseImpl == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setDatabase(dbImpl);</div>
<div>2387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2388&emsp;&emsp;</div>
<div style="background-color:limegreen;">2389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert fullBIN.getOffHeapLruId() &#60; 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert !fullBIN.hasOffHeapLNs();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2391&emsp;&emsp;</div>
<div>2392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The BIN's lastFullLsn is set here, while its lastLoggedLsn is</div>
<div>2394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * set by postFetchInit or postRecoveryInit.</div>
<div>2395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>2396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            fullBIN.setLastFullLsn(getLastFullLsn());</div>
<div>2397&emsp;&emsp;</div>
<div>2398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Compress the full BIN before applying deltas, to handle the</div>
<div>2400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * following scenario: Non-dirty slots were compressed away</div>
<div>2401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * earlier, leaving room for inserted records, and a delta was</div>
<div>2402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * logged with the inserted records. The full version of the BIN</div>
<div>2403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * (after compression) was not logged, because the BIN is not</div>
<div>2404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * dirtied when non-dirty slots were compressed away. If we don't</div>
<div>2405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * compress here, there may not be room in the original BIN for the</div>
<div>2406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * slots inserted when applying the deltas.</div>
<div>2407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>2408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * However, during recovery we can't compress because locking is</div>
<div>2409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * not used during recovery, and the compressor may delete a slot</div>
<div>2410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * for a record that is part of an active transaction. In addition,</div>
<div>2411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * even when compression is performed here, it is possible that it</div>
<div>2412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * doesn't compress all deleted/expired slots that were compressed</div>
<div>2413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * originally in the scenario described, for one of the following</div>
<div>2414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * reasons:</div>
<div>2415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>2416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *  + The record is locked temporarily by a read operation that</div>
<div>2417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *    will skip the record. Note that the compressor uses</div>
<div>2418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *    non-blocking locking.</div>
<div>2419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>2420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *  + If expiration has been disabled, or the system clock has been</div>
<div>2421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *    changed, slots that were expired originally may not be</div>
<div>2422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *    expired now.</div>
<div>2423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>2424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Therefore, in all cases we enlarge the BIN if necessary to hold</div>
<div>2425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * all slots to be inserted when applying the delta. An extra slot</div>
<div>2426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * is added if leaveFreeSlot is true, to handle cases</div>
<div>2427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * where mutation to a full BIN is performed after calling</div>
<div>2428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Tree.searchSplitsAllowed, or one of the methods that calls it</div>
<div>2429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * such as Tree.findBinForInsert and Tree.getParentBINForChildLN.</div>
<div>2430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * If the search returns a BIN-delta without splitting, and then we</div>
<div>2431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * must mutate to full BIN in order to insert, because blind</div>
<div>2432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * insertions do not apply, then the scenario described can occur.</div>
<div>2433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>2434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * If the BIN is enlarged, we add it to the compressor queue so it</div>
<div>2435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * will be shrunk back down to the Database's configured maxEntries</div>
<div>2436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * during normal compression.</div>
<div>2437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">2438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!dbImpl.getEnv().isInInit()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                fullBIN.compress(</div>
<div>2440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    false /*compressDirtySlots*/, null /*localTracker*/);</div>
<div>2441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">2442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            int nInsertions = leaveFreeSlot ? 1 : 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = 0; i &#60; getNEntries(); i += 1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                final int foundIndex = fullBIN.findEntry(</div>
<div>2445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getKey(i), true, false);</div>
<div style="background-color:limegreen;">2446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (foundIndex &#60; 0 || (foundIndex & IN.EXACT_MATCH) == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    nInsertions += 1;</div>
<div>2448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int maxEntries = nInsertions + fullBIN.getNEntries();</div>
<div style="background-color:limegreen;">2451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (maxEntries > fullBIN.getMaxEntries()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                fullBIN.resize(maxEntries);</div>
<div>2453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                dbImpl.getEnv().addToCompressorQueue(fullBIN);</div>
<div>2454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2455&emsp;&emsp;</div>
<div>2456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Process each delta. */</div>
<div style="background-color:limegreen;">2457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = 0; i &#60; getNEntries(); i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2458&emsp;&emsp;</div>
<div style="background-color:limegreen;">2459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                assert isDirty(i) : this;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2460&emsp;&emsp;</div>
<div>2461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                fullBIN.applyDelta(</div>
<div>2462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getKey(i), getData(i), getLsn(i), getState(i),</div>
<div>2463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getLastLoggedSize(i), getOffHeapLNId(i),</div>
<div>2464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getCachedVLSN(i), getTarget(i),</div>
<div>2465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getExpiration(i), isExpirationInHours());</div>
<div>2466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2467&emsp;&emsp;</div>
<div>2468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The applied deltas will leave some slots dirty, which is</div>
<div>2470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * necessary as a record of changes that will be included in the</div>
<div>2471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * next delta.  However, the BIN itself should not be dirty,</div>
<div>2472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * because this delta is a persistent record of those changes.</div>
<div>2473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>2474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            fullBIN.setDirty(false);</div>
<div>2475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } finally {</div>
<div>2476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            fullBIN.releaseLatch();</div>
<div>2477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2479&emsp;&emsp;</div>
<div>2480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Apply (insert, update) a given delta slot in this full BIN.</div>
<div>2482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note: also called from OldBINDelta class.</div>
<div>2483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void applyDelta(</div>
<div>2485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] key,</div>
<div>2486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] data,</div>
<div>2487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long lsn,</div>
<div>2488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte state,</div>
<div>2489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int lastLoggedSize,</div>
<div>2490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long ohLnId,</div>
<div>2491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long vlsn,</div>
<div>2492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Node child,</div>
<div>2493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int expiration,</div>
<div>2494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean expirationInHours) {</div>
<div>2495&emsp;&emsp;</div>
<div>2496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>2497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * The delta is the authoritative version of the entry. In all cases,</div>
<div>2498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * it should supersede the entry in the full BIN.  This is true even if</div>
<div>2499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the BIN Delta's entry is knownDeleted or if the full BIN's version</div>
<div>2500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * is knownDeleted. Therefore we use the flavor of findEntry that will</div>
<div>2501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * return a knownDeleted entry if the entry key matches (i.e. true,</div>
<div>2502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * false) but still indicates exact matches with the return index.</div>
<div>2503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * findEntry only returns deleted entries if third arg is false, but we</div>
<div>2504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * still need to know if it's an exact match or not so indicateExact is</div>
<div>2505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * true.</div>
<div>2506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>2507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int foundIndex = findEntry(key, true, false);</div>
<div>2508&emsp;&emsp;</div>
<div style="background-color:limegreen;">2509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (foundIndex >= 0 && (foundIndex & IN.EXACT_MATCH) != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2510&emsp;&emsp;</div>
<div>2511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            foundIndex &= ~IN.EXACT_MATCH;</div>
<div>2512&emsp;&emsp;</div>
<div>2513&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The entry exists in the full version, update it with the delta</div>
<div>2515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * info.  Note that all state flags should be restored [#22848].</div>
<div>2516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>2517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            applyDeltaSlot(</div>
<div>2518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                foundIndex, child, lsn, lastLoggedSize, state, key, data);</div>
<div>2519&emsp;&emsp;</div>
<div>2520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>2521&emsp;&emsp;</div>
<div>2522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The entry doesn't exist, insert the delta entry. We insert the</div>
<div>2524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * entry even when it is known or pending deleted, since the</div>
<div>2525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * deleted (and dirty) entry will be needed to log the next delta.</div>
<div>2526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * [#20737]</div>
<div>2527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>2528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int result = insertEntry1(</div>
<div>2529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child, key, data, lsn, state, false/*blindInsertion*/);</div>
<div>2530&emsp;&emsp;</div>
<div style="background-color:limegreen;">2531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert (result & INSERT_SUCCESS) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            foundIndex = result & ~IN.INSERT_SUCCESS;</div>
<div>2533&emsp;&emsp;</div>
<div>2534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastLoggedSizeUnconditional(foundIndex, lastLoggedSize);</div>
<div>2535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2536&emsp;&emsp;</div>
<div>2537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setCachedVLSNUnconditional(foundIndex, vlsn);</div>
<div>2538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setOffHeapLNId(foundIndex, ohLnId);</div>
<div>2539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setExpiration(foundIndex, expiration, expirationInHours);</div>
<div>2540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2541&emsp;&emsp;</div>
<div>2542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>2543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * DbStat support.</div>
<div>2544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>2546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void accumulateStats(TreeWalkerStatsAccumulator acc) {</div>
<div>2547&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        acc.processBIN(this, Long.valueOf(getNodeId()), getLevel());</div>
<div>2548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2549&emsp;&emsp;}</div>
</div>
</div>
</body>
</html>