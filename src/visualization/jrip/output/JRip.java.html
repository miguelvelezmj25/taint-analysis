<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JRip.java</title>
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700" rel="stylesheet">
</head>
<body>

<div class="container">
    <div id="code_area" class="container_0">
<div>1&emsp;&emsp;/*</div>
<div>2&emsp;&emsp;&nbsp; *   This program is free software: you can redistribute it and/or modify</div>
<div>3&emsp;&emsp;&nbsp; *   it under the terms of the GNU General Public License as published by</div>
<div>4&emsp;&emsp;&nbsp; *   the Free Software Foundation, either version 3 of the License, or</div>
<div>5&emsp;&emsp;&nbsp; *   (at your option) any later version.</div>
<div>6&emsp;&emsp;&nbsp; *</div>
<div>7&emsp;&emsp;&nbsp; *   This program is distributed in the hope that it will be useful,</div>
<div>8&emsp;&emsp;&nbsp; *   but WITHOUT ANY WARRANTY; without even the implied warranty of</div>
<div>9&emsp;&emsp;&nbsp; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</div>
<div>10&emsp;&emsp;&nbsp; *   GNU General Public License for more details.</div>
<div>11&emsp;&emsp;&nbsp; *</div>
<div>12&emsp;&emsp;&nbsp; *   You should have received a copy of the GNU General Public License</div>
<div>13&emsp;&emsp;&nbsp; *   along with this program.  If not, see &#60;http://www.gnu.org/licenses/>.</div>
<div>14&emsp;&emsp;&nbsp; */</div>
<div>15&emsp;&emsp;</div>
<div>16&emsp;&emsp;/*</div>
<div>17&emsp;&emsp;&nbsp; *    JRip.java</div>
<div>18&emsp;&emsp;&nbsp; *    Copyright (C) 2001-2012 University of Waikato, Hamilton, New Zealand</div>
<div>19&emsp;&emsp;&nbsp; */</div>
<div>20&emsp;&emsp;</div>
<div>21&emsp;&emsp;package weka.classifiers.rules;</div>
<div>22&emsp;&emsp;</div>
<div>23&emsp;&emsp;import java.io.Serializable;</div>
<div>24&emsp;&emsp;import java.util.ArrayList;</div>
<div>25&emsp;&emsp;import java.util.Collections;</div>
<div>26&emsp;&emsp;import java.util.Enumeration;</div>
<div>27&emsp;&emsp;import java.util.Random;</div>
<div>28&emsp;&emsp;import java.util.Vector;</div>
<div>29&emsp;&emsp;</div>
<div>30&emsp;&emsp;import weka.classifiers.AbstractClassifier;</div>
<div>31&emsp;&emsp;import weka.core.AdditionalMeasureProducer;</div>
<div>32&emsp;&emsp;import weka.core.Attribute;</div>
<div>33&emsp;&emsp;import weka.core.Capabilities;</div>
<div>34&emsp;&emsp;import weka.core.Capabilities.Capability;</div>
<div>35&emsp;&emsp;import weka.core.Copyable;</div>
<div>36&emsp;&emsp;import weka.core.Instance;</div>
<div>37&emsp;&emsp;import weka.core.Instances;</div>
<div>38&emsp;&emsp;import weka.core.Option;</div>
<div>39&emsp;&emsp;import weka.core.RevisionHandler;</div>
<div>40&emsp;&emsp;import weka.core.RevisionUtils;</div>
<div>41&emsp;&emsp;import weka.core.TechnicalInformation;</div>
<div>42&emsp;&emsp;import weka.core.TechnicalInformation.Field;</div>
<div>43&emsp;&emsp;import weka.core.TechnicalInformation.Type;</div>
<div>44&emsp;&emsp;import weka.core.TechnicalInformationHandler;</div>
<div>45&emsp;&emsp;import weka.core.Utils;</div>
<div>46&emsp;&emsp;import weka.core.WeightedInstancesHandler;</div>
<div>47&emsp;&emsp;import weka.filters.Filter;</div>
<div>48&emsp;&emsp;import weka.filters.supervised.attribute.ClassOrder;</div>
<div>49&emsp;&emsp;</div>
<div>50&emsp;&emsp;/**</div>
<div>51&emsp;&emsp;&nbsp; * &#60;!-- globalinfo-start --> This class implements a propositional rule learner,</div>
<div>52&emsp;&emsp;&nbsp; * Repeated Incremental Pruning to Produce Error Reduction (RIPPER), which was</div>
<div>53&emsp;&emsp;&nbsp; * proposed by William W. Cohen as an optimized version of IREP. &#60;br/></div>
<div>54&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>55&emsp;&emsp;&nbsp; * The algorithm is briefly described as follows: &#60;br/></div>
<div>56&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>57&emsp;&emsp;&nbsp; * Initialize RS = {}, and for each class from the less prevalent one to the</div>
<div>58&emsp;&emsp;&nbsp; * more frequent one, DO: &#60;br/></div>
<div>59&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>60&emsp;&emsp;&nbsp; * 1. Building stage:&#60;br/></div>
<div>61&emsp;&emsp;&nbsp; * Repeat 1.1 and 1.2 until the descrition length (DL) of the ruleset and</div>
<div>62&emsp;&emsp;&nbsp; * examples is 64 bits greater than the smallest DL met so far, or there are no</div>
<div>63&emsp;&emsp;&nbsp; * positive examples, or the error rate &gt;= 50%. &#60;br/></div>
<div>64&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>65&emsp;&emsp;&nbsp; * 1.1. Grow phase:&#60;br/></div>
<div>66&emsp;&emsp;&nbsp; * Grow one rule by greedily adding antecedents (or conditions) to the rule</div>
<div>67&emsp;&emsp;&nbsp; * until the rule is perfect (i.e. 100% accurate). The procedure tries every</div>
<div>68&emsp;&emsp;&nbsp; * possible value of each attribute and selects the condition with highest</div>
<div>69&emsp;&emsp;&nbsp; * information gain: p(log(p/t)-log(P/T)).&#60;br/></div>
<div>70&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>71&emsp;&emsp;&nbsp; * 1.2. Prune phase:&#60;br/></div>
<div>72&emsp;&emsp;&nbsp; * Incrementally prune each rule and allow the pruning of any final sequences of</div>
<div>73&emsp;&emsp;&nbsp; * the antecedents;The pruning metric is (p-n)/(p+n) -- but it's actually</div>
<div>74&emsp;&emsp;&nbsp; * 2p/(p+n) -1, so in this implementation we simply use p/(p+n) (actually</div>
<div>75&emsp;&emsp;&nbsp; * (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).&#60;br/></div>
<div>76&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>77&emsp;&emsp;&nbsp; * 2. Optimization stage:&#60;br/></div>
<div>78&emsp;&emsp;&nbsp; * after generating the initial ruleset {Ri}, generate and prune two variants of</div>
<div>79&emsp;&emsp;&nbsp; * each rule Ri from randomized data using procedure 1.1 and 1.2. But one</div>
<div>80&emsp;&emsp;&nbsp; * variant is generated from an empty rule while the other is generated by</div>
<div>81&emsp;&emsp;&nbsp; * greedily adding antecedents to the original rule. Moreover, the pruning</div>
<div>82&emsp;&emsp;&nbsp; * metric used here is (TP+TN)/(P+N).Then the smallest possible DL for each</div>
<div>83&emsp;&emsp;&nbsp; * variant and the original rule is computed. The variant with the minimal DL is</div>
<div>84&emsp;&emsp;&nbsp; * selected as the final representative of Ri in the ruleset.After all the rules</div>
<div>85&emsp;&emsp;&nbsp; * in {Ri} have been examined and if there are still residual positives, more</div>
<div>86&emsp;&emsp;&nbsp; * rules are generated based on the residual positives using Building Stage</div>
<div>87&emsp;&emsp;&nbsp; * again. &#60;br/></div>
<div>88&emsp;&emsp;&nbsp; * 3. Delete the rules from the ruleset that would increase the DL of the whole</div>
<div>89&emsp;&emsp;&nbsp; * ruleset if it were in it. and add resultant ruleset to RS. &#60;br/></div>
<div>90&emsp;&emsp;&nbsp; * ENDDO&#60;br/></div>
<div>91&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>92&emsp;&emsp;&nbsp; * Note that there seem to be 2 bugs in the original ripper program that would</div>
<div>93&emsp;&emsp;&nbsp; * affect the ruleset size and accuracy slightly. This implementation avoids</div>
<div>94&emsp;&emsp;&nbsp; * these bugs and thus is a little bit different from Cohen's original</div>
<div>95&emsp;&emsp;&nbsp; * implementation. Even after fixing the bugs, since the order of classes with</div>
<div>96&emsp;&emsp;&nbsp; * the same frequency is not defined in ripper, there still seems to be some</div>
<div>97&emsp;&emsp;&nbsp; * trivial difference between this implementation and the original ripper,</div>
<div>98&emsp;&emsp;&nbsp; * especially for audiology data in UCI repository, where there are lots of</div>
<div>99&emsp;&emsp;&nbsp; * classes of few instances.&#60;br/></div>
<div>100&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>101&emsp;&emsp;&nbsp; * Details please see:&#60;br/></div>
<div>102&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>103&emsp;&emsp;&nbsp; * William W. Cohen: Fast Effective Rule Induction. In: Twelfth International</div>
<div>104&emsp;&emsp;&nbsp; * Conference on Machine Learning, 115-123, 1995.&#60;br/></div>
<div>105&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>106&emsp;&emsp;&nbsp; * PS. We have compared this implementation with the original ripper</div>
<div>107&emsp;&emsp;&nbsp; * implementation in aspects of accuracy, ruleset size and running time on both</div>
<div>108&emsp;&emsp;&nbsp; * artificial data "ab+bcd+defg" and UCI datasets. In all these aspects it seems</div>
<div>109&emsp;&emsp;&nbsp; * to be quite comparable to the original ripper implementation. However, we</div>
<div>110&emsp;&emsp;&nbsp; * didn't consider memory consumption optimization in this implementation.&#60;br/></div>
<div>111&emsp;&emsp;&nbsp; * &#60;br/></div>
<div>112&emsp;&emsp;&nbsp; * &#60;p/></div>
<div>113&emsp;&emsp;&nbsp; * &#60;!-- globalinfo-end --></div>
<div>114&emsp;&emsp;&nbsp; * </div>
<div>115&emsp;&emsp;&nbsp; * &#60;!-- technical-bibtex-start --> BibTeX:</div>
<div>116&emsp;&emsp;&nbsp; * </div>
<div>117&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>118&emsp;&emsp;&nbsp; * &#64;inproceedings{Cohen1995,</div>
<div>119&emsp;&emsp;&nbsp; *    author = {William W. Cohen},</div>
<div>120&emsp;&emsp;&nbsp; *    booktitle = {Twelfth International Conference on Machine Learning},</div>
<div>121&emsp;&emsp;&nbsp; *    pages = {115-123},</div>
<div>122&emsp;&emsp;&nbsp; *    publisher = {Morgan Kaufmann},</div>
<div>123&emsp;&emsp;&nbsp; *    title = {Fast Effective Rule Induction},</div>
<div>124&emsp;&emsp;&nbsp; *    year = {1995}</div>
<div>125&emsp;&emsp;&nbsp; * }</div>
<div>126&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>127&emsp;&emsp;&nbsp; * &#60;p/></div>
<div>128&emsp;&emsp;&nbsp; * &#60;!-- technical-bibtex-end --></div>
<div>129&emsp;&emsp;&nbsp; * </div>
<div>130&emsp;&emsp;&nbsp; * &#60;!-- options-start --> Valid options are:</div>
<div>131&emsp;&emsp;&nbsp; * &#60;p/></div>
<div>132&emsp;&emsp;&nbsp; * </div>
<div>133&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>134&emsp;&emsp;&nbsp; * -F &lt;number of folds&gt;</div>
<div>135&emsp;&emsp;&nbsp; *  Set number of folds for REP</div>
<div>136&emsp;&emsp;&nbsp; *  One fold is used as pruning set.</div>
<div>137&emsp;&emsp;&nbsp; *  (default 3)</div>
<div>138&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>139&emsp;&emsp;&nbsp; * </div>
<div>140&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>141&emsp;&emsp;&nbsp; * -N &lt;min. weights&gt;</div>
<div>142&emsp;&emsp;&nbsp; *  Set the minimal weights of instances</div>
<div>143&emsp;&emsp;&nbsp; *  within a split.</div>
<div>144&emsp;&emsp;&nbsp; *  (default 2.0)</div>
<div>145&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>146&emsp;&emsp;&nbsp; * </div>
<div>147&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>148&emsp;&emsp;&nbsp; * -O &lt;number of runs&gt;</div>
<div>149&emsp;&emsp;&nbsp; *  Set the number of runs of</div>
<div>150&emsp;&emsp;&nbsp; *  optimizations. (Default: 2)</div>
<div>151&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>152&emsp;&emsp;&nbsp; * </div>
<div>153&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>154&emsp;&emsp;&nbsp; * -D</div>
<div>155&emsp;&emsp;&nbsp; *  Set whether turn on the</div>
<div>156&emsp;&emsp;&nbsp; *  debug mode (Default: false)</div>
<div>157&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>158&emsp;&emsp;&nbsp; * </div>
<div>159&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>160&emsp;&emsp;&nbsp; * -S &lt;seed&gt;</div>
<div>161&emsp;&emsp;&nbsp; *  The seed of randomization</div>
<div>162&emsp;&emsp;&nbsp; *  (Default: 1)</div>
<div>163&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>164&emsp;&emsp;&nbsp; * </div>
<div>165&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>166&emsp;&emsp;&nbsp; * -E</div>
<div>167&emsp;&emsp;&nbsp; *  Whether NOT check the error rate&gt;=0.5</div>
<div>168&emsp;&emsp;&nbsp; *  in stopping criteria  (default: check)</div>
<div>169&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>170&emsp;&emsp;&nbsp; * </div>
<div>171&emsp;&emsp;&nbsp; * &#60;pre></div>
<div>172&emsp;&emsp;&nbsp; * -P</div>
<div>173&emsp;&emsp;&nbsp; *  Whether NOT use pruning</div>
<div>174&emsp;&emsp;&nbsp; *  (default: use pruning)</div>
<div>175&emsp;&emsp;&nbsp; * &#60;/pre></div>
<div>176&emsp;&emsp;&nbsp; * </div>
<div>177&emsp;&emsp;&nbsp; * &#60;!-- options-end --></div>
<div>178&emsp;&emsp;&nbsp; * </div>
<div>179&emsp;&emsp;&nbsp; * @author Xin Xu (xx5@cs.waikato.ac.nz)</div>
<div>180&emsp;&emsp;&nbsp; * @author Eibe Frank (eibe@cs.waikato.ac.nz)</div>
<div>181&emsp;&emsp;&nbsp; * @version $Revision: 13402 $</div>
<div>182&emsp;&emsp;&nbsp; */</div>
<div>183&emsp;&emsp;public class JRip extends AbstractClassifier implements</div>
<div>184&emsp;&emsp;&nbsp;&nbsp;  AdditionalMeasureProducer, WeightedInstancesHandler,</div>
<div>185&emsp;&emsp;&nbsp;&nbsp;  TechnicalInformationHandler {</div>
<div>186&emsp;&emsp;</div>
<div>187&emsp;&emsp;&nbsp;&nbsp;  /** for serialization */</div>
<div>188&emsp;&emsp;&nbsp;&nbsp;  static final long serialVersionUID = -6589312996832147161L;</div>
<div>189&emsp;&emsp;</div>
<div>190&emsp;&emsp;&nbsp;&nbsp;  /** The limit of description length surplus in ruleset generation */</div>
<div>191&emsp;&emsp;&nbsp;&nbsp;  private static double MAX_DL_SURPLUS = 64.0;</div>
<div>192&emsp;&emsp;</div>
<div>193&emsp;&emsp;&nbsp;&nbsp;  /** The class attribute of the data */</div>
<div>194&emsp;&emsp;&nbsp;&nbsp;  private Attribute m_Class;</div>
<div>195&emsp;&emsp;</div>
<div>196&emsp;&emsp;&nbsp;&nbsp;  /** The ruleset */</div>
<div>197&emsp;&emsp;&nbsp;&nbsp;  private ArrayList&#60;Rule> m_Ruleset;</div>
<div>198&emsp;&emsp;</div>
<div>199&emsp;&emsp;&nbsp;&nbsp;  /** The predicted class distribution */</div>
<div>200&emsp;&emsp;&nbsp;&nbsp;  private ArrayList&#60;double[]> m_Distributions;</div>
<div>201&emsp;&emsp;</div>
<div>202&emsp;&emsp;&nbsp;&nbsp;  /** Runs of optimizations */</div>
<div>203&emsp;&emsp;&nbsp;&nbsp;  private int m_Optimizations = 2;</div>
<div>204&emsp;&emsp;</div>
<div>205&emsp;&emsp;&nbsp;&nbsp;  /** Random object used in this class */</div>
<div>206&emsp;&emsp;&nbsp;&nbsp;  private Random m_Random = null;</div>
<div>207&emsp;&emsp;</div>
<div>208&emsp;&emsp;&nbsp;&nbsp;  /** # of all the possible conditions in a rule */</div>
<div>209&emsp;&emsp;&nbsp;&nbsp;  private double m_Total = 0;</div>
<div>210&emsp;&emsp;</div>
<div>211&emsp;&emsp;&nbsp;&nbsp;  /** The seed to perform randomization */</div>
<div>212&emsp;&emsp;&nbsp;&nbsp;  private long m_Seed = 1;</div>
<div>213&emsp;&emsp;</div>
<div>214&emsp;&emsp;&nbsp;&nbsp;  /** The number of folds to split data into Grow and Prune for IREP */</div>
<div>215&emsp;&emsp;&nbsp;&nbsp;  private int m_Folds = 3;</div>
<div>216&emsp;&emsp;</div>
<div>217&emsp;&emsp;&nbsp;&nbsp;  /** The minimal number of instance weights within a split */</div>
<div>218&emsp;&emsp;&nbsp;&nbsp;  private double m_MinNo = 2.0;</div>
<div>219&emsp;&emsp;</div>
<div>220&emsp;&emsp;&nbsp;&nbsp;  /** Whether in a debug mode */</div>
<div>221&emsp;&emsp;&nbsp;&nbsp;  private boolean m_Debug = false;</div>
<div>222&emsp;&emsp;</div>
<div>223&emsp;&emsp;&nbsp;&nbsp;  /** Whether check the error rate >= 0.5 in stopping criteria */</div>
<div>224&emsp;&emsp;&nbsp;&nbsp;  private boolean m_CheckErr = true;</div>
<div>225&emsp;&emsp;</div>
<div>226&emsp;&emsp;&nbsp;&nbsp;  /** Whether use pruning, i.e. the data is clean or not */</div>
<div>227&emsp;&emsp;&nbsp;&nbsp;  private boolean m_UsePruning = true;</div>
<div>228&emsp;&emsp;</div>
<div>229&emsp;&emsp;&nbsp;&nbsp;  /** The filter used to randomize the class order */</div>
<div>230&emsp;&emsp;&nbsp;&nbsp;  private Filter m_Filter = null;</div>
<div>231&emsp;&emsp;</div>
<div>232&emsp;&emsp;&nbsp;&nbsp;  /** The RuleStats for the ruleset of each class value */</div>
<div>233&emsp;&emsp;&nbsp;&nbsp;  private ArrayList&#60;RuleStats> m_RulesetStats;</div>
<div>234&emsp;&emsp;</div>
<div>235&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>236&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns a string describing classifier</div>
<div>237&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>238&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return a description suitable for displaying in the explorer/experimenter</div>
<div>239&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         gui</div>
<div>240&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>241&emsp;&emsp;&nbsp;&nbsp;  public String globalInfo() {</div>
<div>242&emsp;&emsp;</div>
<div>243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "This class implements a propositional rule learner, Repeated Incremental "</div>
<div>244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Pruning to Produce Error Reduction (RIPPER), which was proposed by William "</div>
<div>245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "W. Cohen as an optimized version of IREP. \n\n"</div>
<div>246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "The algorithm is briefly described as follows: \n\n"</div>
<div>247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Initialize RS = {}, and for each class from the less prevalent one to "</div>
<div>248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "the more frequent one, DO: \n\n"</div>
<div>249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "1. Building stage:\nRepeat 1.1 and 1.2 until the descrition length (DL) "</div>
<div>250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "of the ruleset and examples is 64 bits greater than the smallest DL "</div>
<div>251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "met so far, or there are no positive examples, or the error rate >= 50%. "</div>
<div>252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\n\n"</div>
<div>253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "1.1. Grow phase:\n"</div>
<div>254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Grow one rule by greedily adding antecedents (or conditions) to "</div>
<div>255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "the rule until the rule is perfect (i.e. 100% accurate).  The "</div>
<div>256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "procedure tries every possible value of each attribute and selects "</div>
<div>257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "the condition with highest information gain: p(log(p/t)-log(P/T))."</div>
<div>258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\n\n"</div>
<div>259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "1.2. Prune phase:\n"</div>
<div>260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Incrementally prune each rule and allow the pruning of any "</div>
<div>261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "final sequences of the antecedents;"</div>
<div>262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "The pruning metric is (p-n)/(p+n) -- but it's actually "</div>
<div>263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "2p/(p+n) -1, so in this implementation we simply use p/(p+n) "</div>
<div>264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "(actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).\n\n"</div>
<div>265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "2. Optimization stage:\n after generating the initial ruleset {Ri}, "</div>
<div>266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "generate and prune two variants of each rule Ri from randomized data "</div>
<div>267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "using procedure 1.1 and 1.2. But one variant is generated from an "</div>
<div>268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "empty rule while the other is generated by greedily adding antecedents "</div>
<div>269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "to the original rule. Moreover, the pruning metric used here is "</div>
<div>270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "(TP+TN)/(P+N)."</div>
<div>271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Then the smallest possible DL for each variant and the original rule "</div>
<div>272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "is computed.  The variant with the minimal DL is selected as the final "</div>
<div>273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "representative of Ri in the ruleset."</div>
<div>274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "After all the rules in {Ri} have been examined and if there are still "</div>
<div>275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "residual positives, more rules are generated based on the residual "</div>
<div>276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "positives using Building Stage again. \n"</div>
<div>277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "3. Delete the rules from the ruleset that would increase the DL of the "</div>
<div>278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "whole ruleset if it were in it. and add resultant ruleset to RS. \n"</div>
<div>279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "ENDDO\n\n"</div>
<div>280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Note that there seem to be 2 bugs in the original ripper program that would "</div>
<div>281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "affect the ruleset size and accuracy slightly.  This implementation avoids "</div>
<div>282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "these bugs and thus is a little bit different from Cohen's original "</div>
<div>283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "implementation. Even after fixing the bugs, since the order of classes with "</div>
<div>284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "the same frequency is not defined in ripper, there still seems to be "</div>
<div>285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "some trivial difference between this implementation and the original ripper, "</div>
<div>286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "especially for audiology data in UCI repository, where there are lots of "</div>
<div>287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "classes of few instances.\n\n"</div>
<div>288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "Details please see:\n\n"</div>
<div>289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + getTechnicalInformation().toString()</div>
<div>290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\n\n"</div>
<div>291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "PS.  We have compared this implementation with the original ripper "</div>
<div>292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "implementation in aspects of accuracy, ruleset size and running time "</div>
<div>293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "on both artificial data \"ab+bcd+defg\" and UCI datasets.  In all these "</div>
<div>294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "aspects it seems to be quite comparable to the original ripper "</div>
<div>295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "implementation.  However, we didn't consider memory consumption "</div>
<div>296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "optimization in this implementation.\n\n";</div>
<div>297&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>298&emsp;&emsp;</div>
<div>299&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>300&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns an instance of a TechnicalInformation object, containing detailed</div>
<div>301&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * information about the technical background of this class, e.g., paper</div>
<div>302&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * reference or book this class is based on.</div>
<div>303&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>304&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the technical information about this class</div>
<div>305&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>306&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>307&emsp;&emsp;&nbsp;&nbsp;  public TechnicalInformation getTechnicalInformation() {</div>
<div>308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    TechnicalInformation result;</div>
<div>309&emsp;&emsp;</div>
<div>310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result = new TechnicalInformation(Type.INPROCEEDINGS);</div>
<div>311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setValue(Field.AUTHOR, "William W. Cohen");</div>
<div>312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setValue(Field.TITLE, "Fast Effective Rule Induction");</div>
<div>313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setValue(Field.BOOKTITLE,</div>
<div>314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "Twelfth International Conference on Machine Learning");</div>
<div>315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setValue(Field.YEAR, "1995");</div>
<div>316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setValue(Field.PAGES, "115-123");</div>
<div>317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setValue(Field.PUBLISHER, "Morgan Kaufmann");</div>
<div>318&emsp;&emsp;</div>
<div>319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return result;</div>
<div>320&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>321&emsp;&emsp;</div>
<div>322&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>323&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns an enumeration describing the available options Valid options are:</div>
<div>324&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>325&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>326&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -F number &#60;br></div>
<div>327&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * The number of folds for reduced error pruning. One fold is used as the</div>
<div>328&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * pruning set. (Default: 3)</div>
<div>329&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>330&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>331&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -N number &#60;br></div>
<div>332&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * The minimal weights of instances within a split. (Default: 2)</div>
<div>333&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>334&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>335&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -O number &#60;br></div>
<div>336&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Set the number of runs of optimizations. (Default: 2)</div>
<div>337&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>338&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>339&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -D &#60;br></div>
<div>340&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Whether turn on the debug mode</div>
<div>341&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>342&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -S number &#60;br></div>
<div>343&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * The seed of randomization used in Ripper.(Default: 1)</div>
<div>344&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>345&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>346&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -E &#60;br></div>
<div>347&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Whether NOT check the error rate >= 0.5 in stopping criteria. (default:</div>
<div>348&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * check)</div>
<div>349&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>350&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>351&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -P &#60;br></div>
<div>352&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Whether NOT use pruning. (default: use pruning)</div>
<div>353&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p></div>
<div>354&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>355&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return an enumeration of all the available options</div>
<div>356&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>357&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>358&emsp;&emsp;&nbsp;&nbsp;  public Enumeration&#60;Option> listOptions() {</div>
<div>359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Vector&#60;Option> newVector = new Vector&#60;Option>(7);</div>
<div>360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add(new Option("\tSet number of folds for REP\n"</div>
<div>361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\tOne fold is used as pruning set.\n" + "\t(default 3)", "F", 1,</div>
<div>362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "-F &#60;number of folds>"));</div>
<div>363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector</div>
<div>364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      .add(new Option("\tSet the minimal weights of instances\n"</div>
<div>365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        + "\twithin a split.\n" + "\t(default 2.0)", "N", 1,</div>
<div>366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        "-N &#60;min. weights>"));</div>
<div>367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add(new Option("\tSet the number of runs of\n"</div>
<div>368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\toptimizations. (Default: 2)", "O", 1, "-O &#60;number of runs>"));</div>
<div>369&emsp;&emsp;</div>
<div>370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add(new Option("\tSet whether turn on the\n"</div>
<div>371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\tdebug mode (Default: false)", "D", 0, "-D"));</div>
<div>372&emsp;&emsp;</div>
<div>373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add(new Option(</div>
<div>374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "\tThe seed of randomization\n" + "\t(Default: 1)", "S", 1, "-S &#60;seed>"));</div>
<div>375&emsp;&emsp;</div>
<div>376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add(new Option("\tWhether NOT check the error rate>=0.5\n"</div>
<div>377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\tin stopping criteria " + "\t(default: check)", "E", 0, "-E"));</div>
<div>378&emsp;&emsp;</div>
<div>379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add(new Option("\tWhether NOT use pruning\n"</div>
<div>380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "\t(default: use pruning)", "P", 0, "-P"));</div>
<div>381&emsp;&emsp;</div>
<div>382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.addAll(Collections.list(super.listOptions()));</div>
<div>383&emsp;&emsp;</div>
<div>384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return newVector.elements();</div>
<div>385&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>386&emsp;&emsp;</div>
<div>387&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>388&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Parses a given list of options.</div>
<div>389&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p/></div>
<div>390&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>391&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;!-- options-start --> Valid options are:</div>
<div>392&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;p/></div>
<div>393&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>394&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>395&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -F &lt;number of folds&gt;</div>
<div>396&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  Set number of folds for REP</div>
<div>397&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  One fold is used as pruning set.</div>
<div>398&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  (default 3)</div>
<div>399&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>400&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>401&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>402&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -N &lt;min. weights&gt;</div>
<div>403&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  Set the minimal weights of instances</div>
<div>404&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  within a split.</div>
<div>405&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  (default 2.0)</div>
<div>406&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>407&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>408&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>409&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -O &lt;number of runs&gt;</div>
<div>410&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  Set the number of runs of</div>
<div>411&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  optimizations. (Default: 2)</div>
<div>412&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>413&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>414&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>415&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -D</div>
<div>416&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  Set whether turn on the</div>
<div>417&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  debug mode (Default: false)</div>
<div>418&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>419&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>420&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>421&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -S &lt;seed&gt;</div>
<div>422&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  The seed of randomization</div>
<div>423&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  (Default: 1)</div>
<div>424&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>425&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>426&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>427&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -E</div>
<div>428&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  Whether NOT check the error rate&gt;=0.5</div>
<div>429&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  in stopping criteria  (default: check)</div>
<div>430&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>431&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>432&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;pre></div>
<div>433&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * -P</div>
<div>434&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  Whether NOT use pruning</div>
<div>435&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *  (default: use pruning)</div>
<div>436&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;/pre></div>
<div>437&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>438&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * &#60;!-- options-end --></div>
<div>439&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>440&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param options the list of options as an array of strings</div>
<div>441&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @throws Exception if an option is not supported</div>
<div>442&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>443&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>444&emsp;&emsp;&nbsp;&nbsp;  public void setOptions(String[] options) throws Exception {</div>
<div>445&emsp;&emsp;//    String numFoldsString = Utils.getOption('F', options);</div>
<div>446&emsp;&emsp;//    if (numFoldsString.length() != 0) {</div>
<div>447&emsp;&emsp;//      m_Folds = Integer.parseInt(numFoldsString);</div>
<div>448&emsp;&emsp;//    } else {</div>
<div>449&emsp;&emsp;//      m_Folds = 3;</div>
<div>450&emsp;&emsp;//    }</div>
<div>451&emsp;&emsp;//</div>
<div>452&emsp;&emsp;//    String minNoString = Utils.getOption('N', options);</div>
<div>453&emsp;&emsp;//    if (minNoString.length() != 0) {</div>
<div>454&emsp;&emsp;//      m_MinNo = Double.parseDouble(minNoString);</div>
<div>455&emsp;&emsp;//    } else {</div>
<div>456&emsp;&emsp;//      m_MinNo = 2.0;</div>
<div>457&emsp;&emsp;//    }</div>
<div>458&emsp;&emsp;//</div>
<div>459&emsp;&emsp;//    String seedString = Utils.getOption('S', options);</div>
<div>460&emsp;&emsp;//    if (seedString.length() != 0) {</div>
<div>461&emsp;&emsp;//      m_Seed = Long.parseLong(seedString);</div>
<div>462&emsp;&emsp;//    } else {</div>
<div>463&emsp;&emsp;//      m_Seed = 1;</div>
<div>464&emsp;&emsp;//    }</div>
<div>465&emsp;&emsp;//</div>
<div>466&emsp;&emsp;//    String runString = Utils.getOption('O', options);</div>
<div>467&emsp;&emsp;//    if (runString.length() != 0) {</div>
<div>468&emsp;&emsp;//      m_Optimizations = Integer.parseInt(runString);</div>
<div>469&emsp;&emsp;//    } else {</div>
<div>470&emsp;&emsp;//      m_Optimizations = 2;</div>
<div>471&emsp;&emsp;//    }</div>
<div>472&emsp;&emsp;//</div>
<div>473&emsp;&emsp;//    m_Debug = Utils.getFlag('D', options);</div>
<div>474&emsp;&emsp;//    m_CheckErr = !Utils.getFlag('E', options);</div>
<div>475&emsp;&emsp;//    m_UsePruning = !Utils.getFlag('P', options);</div>
<div>476&emsp;&emsp;//</div>
<div>477&emsp;&emsp;//    super.setOptions(options);</div>
<div>478&emsp;&emsp;//</div>
<div>479&emsp;&emsp;//    Utils.checkForRemainingOptions(options);</div>
<div>480&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>481&emsp;&emsp;</div>
<div>482&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>483&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets the current settings of the Classifier.</div>
<div>484&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>485&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return an array of strings suitable for passing to setOptions</div>
<div>486&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>487&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>488&emsp;&emsp;&nbsp;&nbsp;  public String[] getOptions() {</div>
<div>489&emsp;&emsp;</div>
<div>490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Vector&#60;String> options = new Vector&#60;String>();</div>
<div>491&emsp;&emsp;</div>
<div>492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("-F");</div>
<div>493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("" + m_Folds);</div>
<div>494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("-N");</div>
<div>495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("" + m_MinNo);</div>
<div>496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("-O");</div>
<div>497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("" + m_Optimizations);</div>
<div>498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("-S");</div>
<div>499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    options.add("" + m_Seed);</div>
<div>500&emsp;&emsp;</div>
<div>501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (m_Debug) {</div>
<div>502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      options.add("-D");</div>
<div>503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>504&emsp;&emsp;</div>
<div>505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (!m_CheckErr) {</div>
<div>506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      options.add("-E");</div>
<div>507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>508&emsp;&emsp;</div>
<div>509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (!m_UsePruning) {</div>
<div>510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      options.add("-P");</div>
<div>511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>512&emsp;&emsp;</div>
<div>513&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Collections.addAll(options, super.getOptions());</div>
<div>514&emsp;&emsp;</div>
<div>515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return options.toArray(new String[0]);</div>
<div>516&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>517&emsp;&emsp;</div>
<div>518&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>519&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns an enumeration of the additional measure names</div>
<div>520&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>521&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return an enumeration of the measure names</div>
<div>522&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>523&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>524&emsp;&emsp;&nbsp;&nbsp;  public Enumeration&#60;String> enumerateMeasures() {</div>
<div>525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Vector&#60;String> newVector = new Vector&#60;String>(1);</div>
<div>526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    newVector.add("measureNumRules");</div>
<div>527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return newVector.elements();</div>
<div>528&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>529&emsp;&emsp;</div>
<div>530&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>531&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the value of the named measure</div>
<div>532&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>533&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param additionalMeasureName the name of the measure to query for its value</div>
<div>534&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the value of the named measure</div>
<div>535&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @throws IllegalArgumentException if the named measure is not supported</div>
<div>536&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>537&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>538&emsp;&emsp;&nbsp;&nbsp;  public double getMeasure(String additionalMeasureName) {</div>
<div>539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (additionalMeasureName.compareToIgnoreCase("measureNumRules") == 0) {</div>
<div>540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return m_Ruleset.size();</div>
<div>541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {</div>
<div>542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      throw new IllegalArgumentException(additionalMeasureName</div>
<div>543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        + " not supported (RIPPER)");</div>
<div>544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>545&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>546&emsp;&emsp;</div>
<div>547&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>548&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>549&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>550&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>551&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>552&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>553&emsp;&emsp;&nbsp;&nbsp;  public String foldsTipText() {</div>
<div>554&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "Determines the amount of data used for pruning. One fold is used for "</div>
<div>555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + "pruning, the rest for growing the rules.";</div>
<div>556&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>557&emsp;&emsp;</div>
<div>558&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>559&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets the number of folds to use</div>
<div>560&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>561&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param fold the number of folds</div>
<div>562&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>563&emsp;&emsp;&nbsp;&nbsp;  public void setFolds(int fold) {</div>
<div>564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Folds = fold;</div>
<div>565&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>566&emsp;&emsp;</div>
<div>567&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>568&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets the number of folds</div>
<div>569&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>570&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the number of folds</div>
<div>571&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>572&emsp;&emsp;&nbsp;&nbsp;  public int getFolds() {</div>
<div>573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_Folds;</div>
<div>574&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>575&emsp;&emsp;</div>
<div>576&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>577&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>578&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>579&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>580&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>581&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>582&emsp;&emsp;&nbsp;&nbsp;  public String minNoTipText() {</div>
<div>583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "The minimum total weight of the instances in a rule.";</div>
<div>584&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>585&emsp;&emsp;</div>
<div>586&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>587&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets the minimum total weight of the instances in a rule</div>
<div>588&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>589&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param m the minimum total weight of the instances in a rule</div>
<div>590&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>591&emsp;&emsp;&nbsp;&nbsp;  public void setMinNo(double m) {</div>
<div>592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_MinNo = m;</div>
<div>593&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>594&emsp;&emsp;</div>
<div>595&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>596&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets the minimum total weight of the instances in a rule</div>
<div>597&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>598&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the minimum total weight of the instances in a rule</div>
<div>599&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>600&emsp;&emsp;&nbsp;&nbsp;  public double getMinNo() {</div>
<div>601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_MinNo;</div>
<div>602&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>603&emsp;&emsp;</div>
<div>604&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>605&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>606&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>607&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>608&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>609&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>610&emsp;&emsp;&nbsp;&nbsp;  public String seedTipText() {</div>
<div>611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "The seed used for randomizing the data.";</div>
<div>612&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>613&emsp;&emsp;</div>
<div>614&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>615&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets the seed value to use in randomizing the data</div>
<div>616&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>617&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param s the new seed value</div>
<div>618&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>619&emsp;&emsp;&nbsp;&nbsp;  public void setSeed(long s) {</div>
<div>620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Seed = s;</div>
<div>621&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>622&emsp;&emsp;</div>
<div>623&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>624&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets the current seed value to use in randomizing the data</div>
<div>625&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>626&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the seed value</div>
<div>627&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>628&emsp;&emsp;&nbsp;&nbsp;  public long getSeed() {</div>
<div>629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_Seed;</div>
<div>630&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>631&emsp;&emsp;</div>
<div>632&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>633&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>634&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>635&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>636&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>637&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>638&emsp;&emsp;&nbsp;&nbsp;  public String optimizationsTipText() {</div>
<div>639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "The number of optimization runs.";</div>
<div>640&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>641&emsp;&emsp;</div>
<div>642&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>643&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets the number of optimization runs</div>
<div>644&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>645&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param run the number of optimization runs</div>
<div>646&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>647&emsp;&emsp;&nbsp;&nbsp;  public void setOptimizations(int run) {</div>
<div>648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Optimizations = run;</div>
<div>649&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>650&emsp;&emsp;</div>
<div>651&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>652&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets the the number of optimization runs</div>
<div>653&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>654&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the number of optimization runs</div>
<div>655&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>656&emsp;&emsp;&nbsp;&nbsp;  public int getOptimizations() {</div>
<div>657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_Optimizations;</div>
<div>658&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>659&emsp;&emsp;</div>
<div>660&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>661&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>662&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>663&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>664&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>665&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>666&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>667&emsp;&emsp;&nbsp;&nbsp;  public String debugTipText() {</div>
<div>668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "Whether debug information is output to the console.";</div>
<div>669&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>670&emsp;&emsp;</div>
<div>671&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>672&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets whether debug information is output to the console</div>
<div>673&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>674&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param d whether debug information is output to the console</div>
<div>675&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>676&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>677&emsp;&emsp;&nbsp;&nbsp;  public void setDebug(boolean d) {</div>
<div>678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Debug = d;</div>
<div>679&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>680&emsp;&emsp;</div>
<div>681&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>682&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets whether debug information is output to the console</div>
<div>683&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>684&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return whether debug information is output to the console</div>
<div>685&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>686&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>687&emsp;&emsp;&nbsp;&nbsp;  public boolean getDebug() {</div>
<div>688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_Debug;</div>
<div>689&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>690&emsp;&emsp;</div>
<div>691&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>692&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>693&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>694&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>695&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>696&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>697&emsp;&emsp;&nbsp;&nbsp;  public String checkErrorRateTipText() {</div>
<div>698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "Whether check for error rate >= 1/2 is included"</div>
<div>699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      + " in stopping criterion.";</div>
<div>700&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>701&emsp;&emsp;</div>
<div>702&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>703&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets whether to check for error rate is in stopping criterion</div>
<div>704&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>705&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param d whether to check for error rate is in stopping criterion</div>
<div>706&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>707&emsp;&emsp;&nbsp;&nbsp;  public void setCheckErrorRate(boolean d) {</div>
<div>708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_CheckErr = d;</div>
<div>709&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>710&emsp;&emsp;</div>
<div>711&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>712&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets whether to check for error rate is in stopping criterion</div>
<div>713&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>714&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return true if checking for error rate is in stopping criterion</div>
<div>715&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>716&emsp;&emsp;&nbsp;&nbsp;  public boolean getCheckErrorRate() {</div>
<div>717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_CheckErr;</div>
<div>718&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>719&emsp;&emsp;</div>
<div>720&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>721&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the tip text for this property</div>
<div>722&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>723&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return tip text for this property suitable for displaying in the</div>
<div>724&emsp;&emsp;&nbsp;&nbsp;&nbsp;   *         explorer/experimenter gui</div>
<div>725&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>726&emsp;&emsp;&nbsp;&nbsp;  public String usePruningTipText() {</div>
<div>727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return "Whether pruning is performed.";</div>
<div>728&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>729&emsp;&emsp;</div>
<div>730&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>731&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Sets whether pruning is performed</div>
<div>732&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>733&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param d Whether pruning is performed</div>
<div>734&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>735&emsp;&emsp;&nbsp;&nbsp;  public void setUsePruning(boolean d) {</div>
<div>736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_UsePruning = d;</div>
<div>737&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>738&emsp;&emsp;</div>
<div>739&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>740&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Gets whether pruning is performed</div>
<div>741&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>742&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return true if pruning is performed</div>
<div>743&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>744&emsp;&emsp;&nbsp;&nbsp;  public boolean getUsePruning() {</div>
<div>745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_UsePruning;</div>
<div>746&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>747&emsp;&emsp;</div>
<div>748&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>749&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Get the ruleset generated by Ripper</div>
<div>750&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>751&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the ruleset</div>
<div>752&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>753&emsp;&emsp;&nbsp;&nbsp;  public ArrayList&#60;Rule> getRuleset() {</div>
<div>754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_Ruleset;</div>
<div>755&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>756&emsp;&emsp;</div>
<div>757&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>758&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Get the statistics of the ruleset in the given position</div>
<div>759&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>760&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param pos the position of the stats, assuming correct</div>
<div>761&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the statistics of the ruleset in the given position</div>
<div>762&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>763&emsp;&emsp;&nbsp;&nbsp;  public RuleStats getRuleStats(int pos) {</div>
<div>764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return m_RulesetStats.get(pos);</div>
<div>765&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>766&emsp;&emsp;</div>
<div>767&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>768&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * The single antecedent in the rule, which is composed of an attribute and</div>
<div>769&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * the corresponding value. There are two inherited classes, namely</div>
<div>770&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * NumericAntd and NominalAntd in which the attributes are numeric and nominal</div>
<div>771&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * respectively.</div>
<div>772&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>773&emsp;&emsp;&nbsp;&nbsp;  public abstract class Antd implements WeightedInstancesHandler, Copyable,</div>
<div>774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Serializable, RevisionHandler {</div>
<div>775&emsp;&emsp;</div>
<div>776&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** for serialization */</div>
<div>777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final long serialVersionUID = -8929754772994154334L;</div>
<div>778&emsp;&emsp;</div>
<div>779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The attribute of the antecedent */</div>
<div>780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected Attribute att;</div>
<div>781&emsp;&emsp;</div>
<div>782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The attribute value of the antecedent. For numeric attribute, value is</div>
<div>784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * either 0(1st bag) or 1(2nd bag)</div>
<div>785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected double value;</div>
<div>787&emsp;&emsp;</div>
<div>788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>789&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The maximum infoGain achieved by this antecedent test in the growing data</div>
<div>790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected double maxInfoGain;</div>
<div>792&emsp;&emsp;</div>
<div>793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The accurate rate of this antecedent test on the growing data */</div>
<div>794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected double accuRate;</div>
<div>795&emsp;&emsp;</div>
<div>796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The coverage of this antecedent in the growing data */</div>
<div>797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected double cover;</div>
<div>798&emsp;&emsp;</div>
<div>799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The accurate data for this antecedent in the growing data */</div>
<div>800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected double accu;</div>
<div>801&emsp;&emsp;</div>
<div>802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Constructor</div>
<div>804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Antd(Attribute a) {</div>
<div>806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      att = a;</div>
<div>807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      value = Double.NaN;</div>
<div>808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      maxInfoGain = 0;</div>
<div>809&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      accuRate = Double.NaN;</div>
<div>810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      cover = Double.NaN;</div>
<div>811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      accu = Double.NaN;</div>
<div>812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>813&emsp;&emsp;</div>
<div>814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* The abstract members for inheritance */</div>
<div>815&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public abstract Instances[] splitData(Instances data, double defAcRt,</div>
<div>816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double cla);</div>
<div>817&emsp;&emsp;</div>
<div>818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public abstract boolean covers(Instance inst);</div>
<div>819&emsp;&emsp;</div>
<div>820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public abstract String toString();</div>
<div>822&emsp;&emsp;</div>
<div>823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Implements Copyable</div>
<div>825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a copy of this object</div>
<div>827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public abstract Object copy();</div>
<div>830&emsp;&emsp;</div>
<div>831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Get functions of this antecedent */</div>
<div>832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Attribute getAttr() {</div>
<div>833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return att;</div>
<div>834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>835&emsp;&emsp;</div>
<div>836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getAttrValue() {</div>
<div>837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return value;</div>
<div>838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>839&emsp;&emsp;</div>
<div>840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getMaxInfoGain() {</div>
<div>841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return maxInfoGain;</div>
<div>842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>843&emsp;&emsp;</div>
<div>844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getAccuRate() {</div>
<div>845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return accuRate;</div>
<div>846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>847&emsp;&emsp;</div>
<div>848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getAccu() {</div>
<div>849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return accu;</div>
<div>850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>851&emsp;&emsp;</div>
<div>852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getCover() {</div>
<div>853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return cover;</div>
<div>854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>855&emsp;&emsp;</div>
<div>856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>857&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the revision string.</div>
<div>858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>859&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the revision</div>
<div>860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String getRevision() {</div>
<div>863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return RevisionUtils.extract("$Revision: 13402 $");</div>
<div>864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>865&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>866&emsp;&emsp;</div>
<div>867&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>868&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * The antecedent with numeric attribute</div>
<div>869&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>870&emsp;&emsp;&nbsp;&nbsp;  public class NumericAntd extends Antd {</div>
<div>871&emsp;&emsp;</div>
<div>872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** for serialization */</div>
<div>873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static final long serialVersionUID = 5699457269983735442L;</div>
<div>874&emsp;&emsp;</div>
<div>875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The split point for this numeric antecedent */</div>
<div>876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private double splitPoint;</div>
<div>877&emsp;&emsp;</div>
<div>878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Constructor</div>
<div>880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public NumericAntd(Attribute a) {</div>
<div>882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      super(a);</div>
<div>883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      splitPoint = Double.NaN;</div>
<div>884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>885&emsp;&emsp;</div>
<div>886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get split point of this numeric antecedent</div>
<div>888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the split point of this numeric antecedent</div>
<div>890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getSplitPoint() {</div>
<div>892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return splitPoint;</div>
<div>893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>894&emsp;&emsp;</div>
<div>895&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Implements Copyable</div>
<div>897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a copy of this object</div>
<div>899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Object copy() {</div>
<div>902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      NumericAntd na = new NumericAntd(getAttr());</div>
<div>903&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      na.value = this.value;</div>
<div>904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      na.splitPoint = this.splitPoint;</div>
<div>905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return na;</div>
<div>906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>907&emsp;&emsp;</div>
<div>908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Implements the splitData function. This procedure is to split the data</div>
<div>910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * into two bags according to the information gain of the numeric attribute</div>
<div>911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * value The maximum infoGain is also calculated.</div>
<div>912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param insts the data to be split</div>
<div>914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param defAcRt the default accuracy rate for data</div>
<div>915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param cl the class label to be predicted</div>
<div>916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the array of data after split</div>
<div>917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Instances[] splitData(Instances insts, double defAcRt, double cl) {</div>
<div>920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances data = insts;</div>
<div>921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int total = data.numInstances();// Total number of instances without</div>
<div>922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // missing value for att</div>
<div>923&emsp;&emsp;</div>
<div>924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int split = 1; // Current split position</div>
<div>925&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int prev = 0; // Previous split position</div>
<div>926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int finalSplit = split; // Final split position</div>
<div>927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      maxInfoGain = 0;</div>
<div>928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      value = 0;</div>
<div>929&emsp;&emsp;</div>
<div>930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double fstCover = 0, sndCover = 0, fstAccu = 0, sndAccu = 0;</div>
<div>931&emsp;&emsp;</div>
<div>932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      data.sort(att);</div>
<div>933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // Find the las instance without missing value</div>
<div style="background-color:limegreen;">934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; data.numInstances(); x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instance inst = data.instance(x);</div>
<div style="background-color:limegreen;">936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (inst.isMissing(att)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          total = x;</div>
<div>938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          break;</div>
<div>939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>940&emsp;&emsp;</div>
<div>941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sndCover += inst.weight();</div>
<div style="background-color:limegreen;">942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (Utils.eq(inst.classValue(), cl)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          sndAccu += inst.weight();</div>
<div>944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>946&emsp;&emsp;</div>
<div style="background-color:limegreen;">947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (total == 0) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return null; // Data all missing for the attribute</div>
<div>949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      splitPoint = data.instance(total - 1).value(att);</div>
<div>951&emsp;&emsp;</div>
<div style="background-color:limegreen;">952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (; split &#60;= total; split++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if ((split == total) || (data.instance(split).value(att) > // Can't&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                                   // split</div>
<div>955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                                   // within</div>
<div style="background-color:limegreen;">956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          data.instance(prev).value(att))) { // same value&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>957&emsp;&emsp;</div>
<div style="background-color:limegreen;">958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          for (int y = prev; y &#60; split; y++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Instance inst = data.instance(y);</div>
<div>960&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            fstCover += inst.weight();</div>
<div style="background-color:limegreen;">961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (Utils.eq(data.instance(y).classValue(), cl)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              fstAccu += inst.weight(); // First bag positive# ++</div>
<div>963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>965&emsp;&emsp;</div>
<div>966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          double fstAccuRate = (fstAccu + 1.0) / (fstCover + 1.0), sndAccuRate = (sndAccu + 1.0)</div>
<div>967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            / (sndCover + 1.0);</div>
<div>968&emsp;&emsp;</div>
<div>969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          /* Which bag has higher information gain? */</div>
<div>970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          boolean isFirst;</div>
<div>971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          double fstInfoGain, sndInfoGain;</div>
<div>972&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          double accRate, infoGain, coverage, accurate;</div>
<div>973&emsp;&emsp;</div>
<div>974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          fstInfoGain =</div>
<div>975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // Utils.eq(defAcRt, 1.0) ?</div>
<div>976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // fstAccu/(double)numConds :</div>
<div>977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          fstAccu * (Utils.log2(fstAccuRate) - Utils.log2(defAcRt));</div>
<div>978&emsp;&emsp;</div>
<div>979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          sndInfoGain =</div>
<div>980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // Utils.eq(defAcRt, 1.0) ?</div>
<div>981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // sndAccu/(double)numConds :</div>
<div>982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          sndAccu * (Utils.log2(sndAccuRate) - Utils.log2(defAcRt));</div>
<div>983&emsp;&emsp;</div>
<div style="background-color:limegreen;">984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (fstInfoGain > sndInfoGain) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            isFirst = true;</div>
<div>986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            infoGain = fstInfoGain;</div>
<div>987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accRate = fstAccuRate;</div>
<div>988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accurate = fstAccu;</div>
<div>989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            coverage = fstCover;</div>
<div>990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          } else {</div>
<div>991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            isFirst = false;</div>
<div>992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            infoGain = sndInfoGain;</div>
<div>993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accRate = sndAccuRate;</div>
<div>994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accurate = sndAccu;</div>
<div>995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            coverage = sndCover;</div>
<div>996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>997&emsp;&emsp;</div>
<div>998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          /* Check whether so far the max infoGain */</div>
<div style="background-color:limegreen;">999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (infoGain > maxInfoGain) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            splitPoint = data.instance(prev).value(att);</div>
<div style="background-color:limegreen;">1001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            value = (isFirst) ? 0 : 1;&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accuRate = accRate;</div>
<div>1003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accu = accurate;</div>
<div>1004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cover = coverage;</div>
<div>1005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            maxInfoGain = infoGain;</div>
<div style="background-color:limegreen;">1006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            finalSplit = (isFirst) ? split : prev;&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1008&emsp;&emsp;</div>
<div style="background-color:limegreen;">1009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          for (int y = prev; y &#60; split; y++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Instance inst = data.instance(y);</div>
<div>1011&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sndCover -= inst.weight();</div>
<div style="background-color:limegreen;">1012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (Utils.eq(data.instance(y).classValue(), cl)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              sndAccu -= inst.weight(); // Second bag positive# --</div>
<div>1014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          prev = split;</div>
<div>1017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1019&emsp;&emsp;</div>
<div>1020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* Split the data */</div>
<div>1021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances[] splitData = new Instances[2];</div>
<div>1022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      splitData[0] = new Instances(data, 0, finalSplit);</div>
<div>1023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      splitData[1] = new Instances(data, finalSplit, total - finalSplit);</div>
<div>1024&emsp;&emsp;</div>
<div>1025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return splitData;</div>
<div>1026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1027&emsp;&emsp;</div>
<div>1028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Whether the instance is covered by this antecedent</div>
<div>1030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param inst the instance in question</div>
<div>1032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the boolean value indicating whether the instance is covered by</div>
<div>1033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *         this antecedent</div>
<div>1034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean covers(Instance inst) {</div>
<div>1037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      boolean isCover = true;</div>
<div>1038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (!inst.isMissing(att)) {</div>
<div>1039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if ((int) value == 0) { // First bag</div>
<div>1040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          if (inst.value(att) > splitPoint) {</div>
<div>1041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            isCover = false;</div>
<div>1042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else if (inst.value(att) &#60; splitPoint) {</div>
<div>1044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          isCover = false;</div>
<div>1045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>1047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        isCover = false;</div>
<div>1048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1049&emsp;&emsp;</div>
<div>1050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return isCover;</div>
<div>1051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1052&emsp;&emsp;</div>
<div>1053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Prints this antecedent</div>
<div>1055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a textual description of this antecedent</div>
<div>1057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String toString() {</div>
<div style="background-color:limegreen;">1060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      String symbol = ((int) value == 0) ? " &#60;= " : " >= ";&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return (att.name() + symbol + Utils.doubleToString(splitPoint, 6));</div>
<div>1062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1063&emsp;&emsp;</div>
<div>1064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the revision string.</div>
<div>1066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the revision</div>
<div>1068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String getRevision() {</div>
<div>1071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return RevisionUtils.extract("$Revision: 13402 $");</div>
<div>1072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1073&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>1074&emsp;&emsp;</div>
<div>1075&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>1076&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * The antecedent with nominal attribute</div>
<div>1077&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>1078&emsp;&emsp;&nbsp;&nbsp;  public class NominalAntd extends Antd {</div>
<div>1079&emsp;&emsp;</div>
<div>1080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** for serialization */</div>
<div>1081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static final long serialVersionUID = -9102297038837585135L;</div>
<div>1082&emsp;&emsp;</div>
<div>1083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The parameters of infoGain calculated for each attribute value in the</div>
<div>1085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * growing data</div>
<div>1086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private final double[] accurate;</div>
<div>1088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private final double[] coverage;</div>
<div>1089&emsp;&emsp;</div>
<div>1090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Constructor</div>
<div>1092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public NominalAntd(Attribute a) {</div>
<div>1094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      super(a);</div>
<div>1095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int bag = att.numValues();</div>
<div>1096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      accurate = new double[bag];</div>
<div>1097&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      coverage = new double[bag];</div>
<div>1098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1099&emsp;&emsp;</div>
<div>1100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Implements Copyable</div>
<div>1102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a copy of this object</div>
<div>1104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Object copy() {</div>
<div>1107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Antd antec = new NominalAntd(getAttr());</div>
<div>1108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      antec.value = this.value;</div>
<div>1109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return antec;</div>
<div>1110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1111&emsp;&emsp;</div>
<div>1112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Implements the splitData function. This procedure is to split the data</div>
<div>1114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * into bags according to the nominal attribute value The infoGain for each</div>
<div>1115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * bag is also calculated.</div>
<div>1116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data the data to be split</div>
<div>1118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param defAcRt the default accuracy rate for data</div>
<div>1119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param cl the class label to be predicted</div>
<div>1120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the array of data after split</div>
<div>1121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Instances[] splitData(Instances data, double defAcRt, double cl) {</div>
<div>1124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int bag = att.numValues();</div>
<div>1125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances[] splitData = new Instances[bag];</div>
<div>1126&emsp;&emsp;</div>
<div style="background-color:limegreen;">1127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; bag; x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        splitData[x] = new Instances(data, data.numInstances());</div>
<div>1129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        accurate[x] = 0;</div>
<div>1130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        coverage[x] = 0;</div>
<div>1131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1132&emsp;&emsp;</div>
<div style="background-color:limegreen;">1133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; data.numInstances(); x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instance inst = data.instance(x);</div>
<div style="background-color:limegreen;">1135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!inst.isMissing(att)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          int v = (int) inst.value(att);</div>
<div>1137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          splitData[v].add(inst);</div>
<div>1138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          coverage[v] += inst.weight();</div>
<div style="background-color:limegreen;">1139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if ((int) inst.classValue() == (int) cl) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accurate[v] += inst.weight();</div>
<div>1141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1144&emsp;&emsp;</div>
<div style="background-color:limegreen;">1145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; bag; x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        double t = coverage[x] + 1.0;</div>
<div>1147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        double p = accurate[x] + 1.0;</div>
<div>1148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        double infoGain =</div>
<div>1149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Utils.eq(defAcRt, 1.0) ?</div>
<div>1150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // accurate[x]/(double)numConds :</div>
<div>1151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        accurate[x] * (Utils.log2(p / t) - Utils.log2(defAcRt));</div>
<div>1152&emsp;&emsp;</div>
<div style="background-color:limegreen;">1153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (infoGain > maxInfoGain) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          maxInfoGain = infoGain;</div>
<div>1155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          cover = coverage[x];</div>
<div>1156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          accu = accurate[x];</div>
<div>1157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          accuRate = p / t;</div>
<div>1158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          value = x;</div>
<div>1159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1161&emsp;&emsp;</div>
<div>1162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return splitData;</div>
<div>1163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1164&emsp;&emsp;</div>
<div>1165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Whether the instance is covered by this antecedent</div>
<div>1167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param inst the instance in question</div>
<div>1169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the boolean value indicating whether the instance is covered by</div>
<div>1170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *         this antecedent</div>
<div>1171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean covers(Instance inst) {</div>
<div>1174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      boolean isCover = false;</div>
<div>1175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (!inst.isMissing(att)) {</div>
<div>1176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if ((int) inst.value(att) == (int) value) {</div>
<div>1177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          isCover = true;</div>
<div>1178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return isCover;</div>
<div>1181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1182&emsp;&emsp;</div>
<div>1183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Prints this antecedent</div>
<div>1185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a textual description of this antecedent</div>
<div>1187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String toString() {</div>
<div>1190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return (att.name() + " = " + att.value((int) value));</div>
<div>1191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1192&emsp;&emsp;</div>
<div>1193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the revision string.</div>
<div>1195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the revision</div>
<div>1197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String getRevision() {</div>
<div>1200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return RevisionUtils.extract("$Revision: 13402 $");</div>
<div>1201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1202&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>1203&emsp;&emsp;</div>
<div>1204&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>1205&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * This class implements a single rule that predicts specified class.</div>
<div>1206&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>1207&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * A rule consists of antecedents "AND"ed together and the consequent (class</div>
<div>1208&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * value) for the classification. In this class, the Information Gain</div>
<div>1209&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * (p*[log(p/t) - log(P/T)]) is used to select an antecedent and Reduced Error</div>
<div>1210&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Prunning (REP) with the metric of accuracy rate p/(p+n) or (TP+TN)/(P+N) is</div>
<div>1211&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * used to prune the rule.</div>
<div>1212&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>1213&emsp;&emsp;&nbsp;&nbsp;  public class RipperRule extends Rule {</div>
<div>1214&emsp;&emsp;</div>
<div>1215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** for serialization */</div>
<div>1216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static final long serialVersionUID = -2410020717305262952L;</div>
<div>1217&emsp;&emsp;</div>
<div>1218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The internal representation of the class label to be predicted */</div>
<div>1219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private double m_Consequent = -1;</div>
<div>1220&emsp;&emsp;</div>
<div>1221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** The vector of antecedents of this rule */</div>
<div>1222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected ArrayList&#60;Antd> m_Antds = null;</div>
<div>1223&emsp;&emsp;</div>
<div>1224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** Constructor */</div>
<div>1225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public RipperRule() {</div>
<div>1226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      m_Antds = new ArrayList&#60;Antd>();</div>
<div>1227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1228&emsp;&emsp;</div>
<div>1229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Removes redundant tests in the rule.</div>
<div>1231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data an instance object that contains the appropriate header information for the attributes.</div>
<div>1233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void cleanUp(Instances data) {</div>
<div>1235&emsp;&emsp;</div>
<div>1236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double[] mins = new double[data.numAttributes()];</div>
<div>1237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double[] maxs = new double[data.numAttributes()];</div>
<div>1238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for (int i = 0; i &#60; data.numAttributes(); i++) {</div>
<div>1239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        mins[i] = Double.MAX_VALUE;</div>
<div>1240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        maxs[i] = -Double.MAX_VALUE;</div>
<div>1241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for (int i = m_Antds.size() - 1; i >= 0; i--) {</div>
<div>1243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Attribute att = m_Antds.get(i).getAttr();</div>
<div>1244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (att.isNumeric()) {</div>
<div>1245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          double splitPoint = ((NumericAntd)m_Antds.get(i)).getSplitPoint();</div>
<div>1246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          if (m_Antds.get(i).getAttrValue() == 0) {</div>
<div>1247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (splitPoint &#60; mins[att.index()]) {</div>
<div>1248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              mins[att.index()] = splitPoint;</div>
<div>1249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>1250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              m_Antds.remove(i);</div>
<div>1251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          } else {</div>
<div>1253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (splitPoint > maxs[att.index()]) {</div>
<div>1254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              maxs[att.index()] = splitPoint;</div>
<div>1255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>1256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              m_Antds.remove(i);</div>
<div>1257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1262&emsp;&emsp;</div>
<div>1263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the internal representation of the class label to be predicted</div>
<div>1265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param cl the internal representation of the class label to be predicted</div>
<div>1267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setConsequent(double cl) {</div>
<div>1269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      m_Consequent = cl;</div>
<div>1270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1271&emsp;&emsp;</div>
<div>1272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Gets the internal representation of the class label to be predicted</div>
<div>1274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the internal representation of the class label to be predicted</div>
<div>1276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double getConsequent() {</div>
<div>1279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return m_Consequent;</div>
<div>1280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1281&emsp;&emsp;</div>
<div>1282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get a shallow copy of this rule</div>
<div>1284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the copy</div>
<div>1286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public Object copy() {</div>
<div>1289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      RipperRule copy = new RipperRule();</div>
<div>1290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      copy.setConsequent(getConsequent());</div>
<div>1291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      copy.m_Antds = new ArrayList&#60;Antd>(this.m_Antds.size());</div>
<div>1292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for (Antd a : this.m_Antds) {</div>
<div>1293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        copy.m_Antds.add((Antd) a.copy());</div>
<div>1294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return copy;</div>
<div>1296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1297&emsp;&emsp;</div>
<div>1298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Whether the instance covered by this rule</div>
<div>1300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param datum the instance in question</div>
<div>1302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the boolean value indicating whether the instance is covered by</div>
<div>1303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *         this rule</div>
<div>1304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean covers(Instance datum) {</div>
<div>1307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      boolean isCover = true;</div>
<div>1308&emsp;&emsp;</div>
<div>1309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for (int i = 0; i &#60; m_Antds.size(); i++) {</div>
<div>1310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Antd antd = m_Antds.get(i);</div>
<div>1311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (!antd.covers(datum)) {</div>
<div>1312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          isCover = false;</div>
<div>1313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          break;</div>
<div>1314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1316&emsp;&emsp;</div>
<div>1317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return isCover;</div>
<div>1318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1319&emsp;&emsp;</div>
<div>1320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Whether this rule has antecedents, i.e. whether it is a default rule</div>
<div>1322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the boolean value indicating whether the rule has antecedents</div>
<div>1324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean hasAntds() {</div>
<div>1327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (m_Antds == null) {</div>
<div>1328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>1329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>1330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (m_Antds.size() > 0);</div>
<div>1331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1333&emsp;&emsp;</div>
<div>1334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return the antecedents</div>
<div>1336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the vector of antecedents</div>
<div>1338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public ArrayList&#60;Antd> getAntds() {</div>
<div>1340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return m_Antds;</div>
<div>1341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1342&emsp;&emsp;</div>
<div>1343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the number of antecedents of the rule</div>
<div>1345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the size of this rule</div>
<div>1347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public double size() {</div>
<div>1350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return m_Antds.size();</div>
<div>1351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1352&emsp;&emsp;</div>
<div>1353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Private function to compute default number of accurate instances in the</div>
<div>1355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * specified data for the consequent of the rule</div>
<div>1356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data the data in question</div>
<div>1358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the default accuracy number</div>
<div>1359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private double computeDefAccu(Instances data) {</div>
<div>1361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double defAccu = 0;</div>
<div style="background-color:limegreen;">1362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int i = 0; i &#60; data.numInstances(); i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instance inst = data.instance(i);</div>
<div style="background-color:limegreen;">1364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if ((int) inst.classValue() == (int) m_Consequent) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          defAccu += inst.weight();</div>
<div>1366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return defAccu;</div>
<div>1369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1370&emsp;&emsp;</div>
<div>1371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Build one rule using the growing data</div>
<div>1373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data the growing data used to build the rule</div>
<div>1375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @throws Exception if the consequent is not set yet</div>
<div>1376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void grow(Instances data) throws Exception {</div>
<div style="background-color:limegreen;">1379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Consequent == -1) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throw new Exception(" Consequent not set yet.");</div>
<div>1381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1382&emsp;&emsp;</div>
<div>1383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances growData = data;</div>
<div>1384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double sumOfWeights = growData.sumOfWeights();</div>
<div style="background-color:limegreen;">1385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (!Utils.gr(sumOfWeights, 0.0)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return;</div>
<div>1387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1388&emsp;&emsp;</div>
<div>1389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* Compute the default accurate rate of the growing data */</div>
<div>1390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double defAccu = computeDefAccu(growData);</div>
<div>1391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double defAcRt = (defAccu + 1.0) / (sumOfWeights + 1.0);</div>
<div>1392&emsp;&emsp;</div>
<div>1393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* Keep the record of which attributes have already been used */</div>
<div>1394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      boolean[] used = new boolean[growData.numAttributes()];</div>
<div style="background-color:limegreen;">1395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int k = 0; k &#60; used.length; k++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        used[k] = false;</div>
<div>1397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int numUnused = used.length;</div>
<div>1399&emsp;&emsp;</div>
<div>1400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // If there are already antecedents existing</div>
<div style="background-color:limegreen;">1401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int j = 0; j &#60; m_Antds.size(); j++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Antd antdj = m_Antds.get(j);</div>
<div style="background-color:limegreen;">1403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!antdj.getAttr().isNumeric()) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          used[antdj.getAttr().index()] = true;</div>
<div>1405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          numUnused--;</div>
<div>1406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1408&emsp;&emsp;</div>
<div>1409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double maxInfoGain;</div>
<div style="background-color:limegreen;">1410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      while (Utils.gr(growData.numInstances(), 0.0) && (numUnused > 0)&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        && Utils.sm(defAcRt, 1.0)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1412&emsp;&emsp;</div>
<div>1413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // We require that infoGain be positive</div>
<div>1414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * if(numAntds == originalSize) maxInfoGain = 0.0; // At least one</div>
<div>1416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * condition allowed else maxInfoGain = Utils.eq(defAcRt, 1.0) ?</div>
<div>1417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * defAccu/(double)numAntds : 0.0;</div>
<div>1418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>1419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        maxInfoGain = 0.0;</div>
<div>1420&emsp;&emsp;</div>
<div>1421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Build a list of antecedents */</div>
<div>1422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Antd oneAntd = null;</div>
<div>1423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instances coverData = null;</div>
<div>1424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Enumeration&#60;Attribute> enumAttr = growData.enumerateAttributes();</div>
<div>1425&emsp;&emsp;</div>
<div>1426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Build one condition based on all attributes not used yet */</div>
<div style="background-color:limegreen;">1427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        while (enumAttr.hasMoreElements()) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          Attribute att = (enumAttr.nextElement());</div>
<div>1429&emsp;&emsp;</div>
<div style="background-color:limegreen;">1430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.err.println("\nOne condition: size = "</div>
<div>1432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              + growData.sumOfWeights());</div>
<div>1433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1434&emsp;&emsp;</div>
<div>1435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          Antd antd = null;</div>
<div style="background-color:limegreen;">1436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (att.isNumeric()) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            antd = new NumericAntd(att);</div>
<div>1438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          } else {</div>
<div>1439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            antd = new NominalAntd(att);</div>
<div>1440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1441&emsp;&emsp;</div>
<div style="background-color:limegreen;">1442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (!used[att.index()]) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Compute the best information gain for each attribute, it's stored</div>
<div>1445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * in the antecedent formed by this attribute. This procedure</div>
<div>1446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * returns the data covered by the antecedent</div>
<div>1447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Instances coveredData = computeInfoGain(growData, defAcRt, antd);</div>
<div style="background-color:limegreen;">1449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (coveredData != null) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              double infoGain = antd.getMaxInfoGain();</div>
<div style="background-color:limegreen;">1451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>              if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                System.err.println("Test of \'" + antd.toString()</div>
<div>1453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  + "\': infoGain = " + infoGain + " | Accuracy = "</div>
<div>1454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  + antd.getAccuRate() + "=" + antd.getAccu() + "/"</div>
<div>1455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  + antd.getCover() + " def. accuracy: " + defAcRt);</div>
<div>1456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              }</div>
<div>1457&emsp;&emsp;</div>
<div style="background-color:limegreen;">1458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>              if (infoGain > maxInfoGain) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                oneAntd = antd;</div>
<div>1460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                coverData = coveredData;</div>
<div>1461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                maxInfoGain = infoGain;</div>
<div>1462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              }</div>
<div>1463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1466&emsp;&emsp;</div>
<div style="background-color:limegreen;">1467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oneAntd == null) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          break; // Cannot find antds</div>
<div>1469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div style="background-color:limegreen;">1470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (Utils.sm(oneAntd.getAccu(), m_MinNo)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          break;// Too low coverage</div>
<div>1472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1473&emsp;&emsp;</div>
<div>1474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // Numeric attributes can be used more than once</div>
<div style="background-color:limegreen;">1475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!oneAntd.getAttr().isNumeric()) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          used[oneAntd.getAttr().index()] = true;</div>
<div>1477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          numUnused--;</div>
<div>1478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1479&emsp;&emsp;</div>
<div>1480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        m_Antds.add(oneAntd);</div>
<div>1481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        growData = coverData;// Grow data size is shrinking</div>
<div>1482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        defAcRt = oneAntd.getAccuRate();</div>
<div>1483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1485&emsp;&emsp;</div>
<div>1486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Compute the best information gain for the specified antecedent</div>
<div>1488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param instances the data based on which the infoGain is computed</div>
<div>1490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param defAcRt the default accuracy rate of data</div>
<div>1491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param antd the specific antecedent</div>
<div>1492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the data covered by the antecedent</div>
<div>1493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private Instances computeInfoGain(Instances instances, double defAcRt,</div>
<div>1495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Antd antd) {</div>
<div>1496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances data = instances;</div>
<div>1497&emsp;&emsp;</div>
<div>1498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /*</div>
<div>1499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       * Split the data into bags. The information gain of each bag is also</div>
<div>1500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       * calculated in this procedure</div>
<div>1501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       */</div>
<div>1502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances[] splitData = antd.splitData(data, defAcRt, m_Consequent);</div>
<div>1503&emsp;&emsp;</div>
<div>1504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* Get the bag of data to be used for next antecedents */</div>
<div style="background-color:limegreen;">1505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (splitData != null) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return splitData[(int) antd.getAttrValue()];</div>
<div>1507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>1508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return null;</div>
<div>1509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1511&emsp;&emsp;</div>
<div>1512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1513&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Prune all the possible final sequences of the rule using the pruning</div>
<div>1514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * data. The measure used to prune the rule is based on flag given.</div>
<div>1515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param pruneData the pruning data used to prune the rule</div>
<div>1517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param useWhole flag to indicate whether use the error rate of the whole</div>
<div>1518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *          pruning data instead of the data covered</div>
<div>1519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void prune(Instances pruneData, boolean useWhole) {</div>
<div>1521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Instances data = pruneData;</div>
<div>1522&emsp;&emsp;</div>
<div>1523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double total = data.sumOfWeights();</div>
<div style="background-color:limegreen;">1524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (!Utils.gr(total, 0.0)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return;</div>
<div>1526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1527&emsp;&emsp;</div>
<div>1528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* The default accurate # and rate on pruning data */</div>
<div>1529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double defAccu = computeDefAccu(data);</div>
<div>1530&emsp;&emsp;</div>
<div style="background-color:limegreen;">1531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("Pruning with " + defAccu + " positive data out of "</div>
<div>1533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + total + " instances");</div>
<div>1534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1535&emsp;&emsp;</div>
<div>1536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int size = m_Antds.size();</div>
<div style="background-color:limegreen;">1537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (size == 0) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return; // Default rule before pruning</div>
<div>1539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1540&emsp;&emsp;</div>
<div>1541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double[] worthRt = new double[size];</div>
<div>1542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double[] coverage = new double[size];</div>
<div>1543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double[] worthValue = new double[size];</div>
<div style="background-color:limegreen;">1544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int w = 0; w &#60; size; w++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        worthRt[w] = coverage[w] = worthValue[w] = 0.0;</div>
<div>1546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1547&emsp;&emsp;</div>
<div>1548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* Calculate accuracy parameters for all the antecedents in this rule */</div>
<div>1549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double tn = 0.0; // True negative if useWhole</div>
<div style="background-color:limegreen;">1550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; size; x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Antd antd = m_Antds.get(x);</div>
<div>1552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instances newData = data;</div>
<div>1553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        data = new Instances(newData, 0); // Make data empty</div>
<div>1554&emsp;&emsp;</div>
<div style="background-color:limegreen;">1555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int y = 0; y &#60; newData.numInstances(); y++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          Instance ins = newData.instance(y);</div>
<div>1557&emsp;&emsp;</div>
<div style="background-color:limegreen;">1558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (antd.covers(ins)) { // Covered by this antecedent&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            coverage[x] += ins.weight();</div>
<div>1560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            data.add(ins); // Add to data for further pruning</div>
<div style="background-color:limegreen;">1561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if ((int) ins.classValue() == (int) m_Consequent) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              worthValue[x] += ins.weight();</div>
<div>1563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">1564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          } else if (useWhole) { // Not covered&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if ((int) ins.classValue() != (int) m_Consequent) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              tn += ins.weight();</div>
<div>1567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1570&emsp;&emsp;</div>
<div style="background-color:limegreen;">1571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (useWhole) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          worthValue[x] += tn;</div>
<div>1573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          worthRt[x] = worthValue[x] / total;</div>
<div>1574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          worthRt[x] = (worthValue[x] + 1.0) / (coverage[x] + 2.0);</div>
<div>1576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1577&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1578&emsp;&emsp;</div>
<div>1579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double maxValue = (defAccu + 1.0) / (total + 2.0);</div>
<div>1580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int maxIndex = -1;</div>
<div style="background-color:limegreen;">1581&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int i = 0; i &#60; worthValue.length; i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          double denom = useWhole ? total : coverage[i];&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          System.err.println(i + "(useAccuray? " + !useWhole + "): "&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1585&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            + worthRt[i] + "=" + worthValue[i] + "/" + denom);</div>
<div>1586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div style="background-color:limegreen;">1587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (worthRt[i] > maxValue) { // Prefer to the&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          maxValue = worthRt[i]; // shorter rule</div>
<div>1589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          maxIndex = i;</div>
<div>1590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1592&emsp;&emsp;</div>
<div>1593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /* Prune the antecedents according to the accuracy parameters */</div>
<div style="background-color:limegreen;">1594&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int z = size - 1; z > maxIndex; z--) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1595&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        m_Antds.remove(z);</div>
<div>1596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1598&emsp;&emsp;</div>
<div>1599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Prints this rule</div>
<div>1601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param classAttr the class attribute in the data</div>
<div>1603&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a textual description of this rule</div>
<div>1604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String toString(Attribute classAttr) {</div>
<div>1606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      StringBuffer text = new StringBuffer();</div>
<div style="background-color:limegreen;">1607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Antds.size() > 0) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int j = 0; j &#60; (m_Antds.size() - 1); j++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1609&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          text.append("(" + (m_Antds.get(j)).toString() + ") and ");</div>
<div>1610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        text.append("(" + (m_Antds.get(m_Antds.size() - 1)).toString() + ")");</div>
<div>1612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1613&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      text.append(" => " + classAttr.name() + "="</div>
<div>1614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        + classAttr.value((int) m_Consequent));</div>
<div>1615&emsp;&emsp;</div>
<div>1616&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return text.toString();</div>
<div>1617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1618&emsp;&emsp;</div>
<div>1619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the revision string.</div>
<div>1621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the revision</div>
<div>1623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>1625&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String getRevision() {</div>
<div>1626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return RevisionUtils.extract("$Revision: 13402 $");</div>
<div>1627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1628&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>1629&emsp;&emsp;</div>
<div>1630&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>1631&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns default capabilities of the classifier.</div>
<div>1632&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>1633&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the capabilities of this classifier</div>
<div>1634&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>1635&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>1636&emsp;&emsp;&nbsp;&nbsp;  public Capabilities getCapabilities() {</div>
<div>1637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Capabilities result = super.getCapabilities();</div>
<div>1638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.disableAll();</div>
<div>1639&emsp;&emsp;</div>
<div>1640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // attributes</div>
<div>1641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.enable(Capability.NOMINAL_ATTRIBUTES);</div>
<div>1642&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.enable(Capability.NUMERIC_ATTRIBUTES);</div>
<div>1643&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.enable(Capability.DATE_ATTRIBUTES);</div>
<div>1644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.enable(Capability.MISSING_VALUES);</div>
<div>1645&emsp;&emsp;</div>
<div>1646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // class</div>
<div>1647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.enable(Capability.NOMINAL_CLASS);</div>
<div>1648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.enable(Capability.MISSING_CLASS_VALUES);</div>
<div>1649&emsp;&emsp;</div>
<div>1650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // instances</div>
<div>1651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    result.setMinimumNumberInstances(m_Folds);</div>
<div>1652&emsp;&emsp;</div>
<div>1653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return result;</div>
<div>1654&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>1655&emsp;&emsp;</div>
<div>1656&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>1657&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Builds Ripper in the order of class frequencies. For each class it's built</div>
<div>1658&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * in two stages: building and optimization</div>
<div>1659&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>1660&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param instances the training data</div>
<div>1661&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @throws Exception if classifier can't be built successfully</div>
<div>1662&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>1663&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>1664&emsp;&emsp;&nbsp;&nbsp;  public void buildClassifier(Instances instances) throws Exception {</div>
<div>1665&emsp;&emsp;</div>
<div>1666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // can classifier handle the data?</div>
<div>1667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    getCapabilities().testWithFail(instances);</div>
<div>1668&emsp;&emsp;</div>
<div>1669&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // remove instances with missing class</div>
<div>1670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    instances = new Instances(instances);</div>
<div>1671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    instances.deleteWithMissingClass();</div>
<div>1672&emsp;&emsp;</div>
<div>1673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Random = instances.getRandomNumberGenerator(m_Seed);</div>
<div>1674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Total = RuleStats.numAllConditions(instances);</div>
<div style="background-color:limegreen;">1675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println("Number of all possible conditions = " + m_Total);</div>
<div>1677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1678&emsp;&emsp;</div>
<div>1679&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Instances data = null;</div>
<div>1680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Filter = new ClassOrder();</div>
<div>1681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    ((ClassOrder) m_Filter).setSeed(m_Random.nextInt());</div>
<div>1682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    ((ClassOrder) m_Filter).setClassOrder(ClassOrder.FREQ_ASCEND);</div>
<div>1683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Filter.setInputFormat(instances);</div>
<div>1684&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    data = Filter.useFilter(instances, m_Filter);</div>
<div>1685&emsp;&emsp;</div>
<div style="background-color:limegreen;">1686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (data == null) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      throw new Exception(" Unable to randomize the class orders.");</div>
<div>1688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1689&emsp;&emsp;</div>
<div>1690&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Class = data.classAttribute();</div>
<div>1691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Ruleset = new ArrayList&#60;Rule>();</div>
<div>1692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_RulesetStats = new ArrayList&#60;RuleStats>();</div>
<div>1693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Distributions = new ArrayList&#60;double[]>();</div>
<div>1694&emsp;&emsp;</div>
<div>1695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Sort by classes frequency</div>
<div>1696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    double[] orderedClasses = ((ClassOrder) m_Filter).getClassCounts();</div>
<div style="background-color:limegreen;">1697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println("Sorted classes:");</div>
<div style="background-color:limegreen;">1699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; m_Class.numValues(); x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println(x + ": " + m_Class.value(x) + " has "</div>
<div>1701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + orderedClasses[x] + " instances.");</div>
<div>1702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Iterate from less prevalent class to more frequent one</div>
<div style="background-color:limegreen;">1705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    oneClass: for (int y = 0; y &#60; data.numClasses() - 1; y++) { // For each&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                                // class</div>
<div>1707&emsp;&emsp;</div>
<div>1708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double classIndex = y;</div>
<div style="background-color:limegreen;">1709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1710&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int ci = (int) classIndex;</div>
<div>1711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("\n\nClass " + m_Class.value(ci) + "(" + ci + "): "</div>
<div>1712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + orderedClasses[y] + "instances\n"</div>
<div>1713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + "=====================================\n");</div>
<div>1714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1715&emsp;&emsp;</div>
<div style="background-color:limegreen;">1716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (Utils.eq(orderedClasses[y], 0.0)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        continue oneClass;</div>
<div>1718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1719&emsp;&emsp;</div>
<div>1720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // The expected FP/err is the proportion of the class</div>
<div>1721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double all = 0;</div>
<div style="background-color:limegreen;">1722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int i = y; i &#60; orderedClasses.length; i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1723&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        all += orderedClasses[i];</div>
<div>1724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double expFPRate = orderedClasses[y] / all;</div>
<div>1726&emsp;&emsp;</div>
<div>1727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double classYWeights = 0, totalWeights = 0;</div>
<div style="background-color:limegreen;">1728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int j = 0; j &#60; data.numInstances(); j++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1729&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instance datum = data.instance(j);</div>
<div>1730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        totalWeights += datum.weight();</div>
<div style="background-color:limegreen;">1731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if ((int) datum.classValue() == y) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          classYWeights += datum.weight();</div>
<div>1733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1735&emsp;&emsp;</div>
<div>1736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // DL of default rule, no theory DL, only data DL</div>
<div>1737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      double defDL;</div>
<div style="background-color:limegreen;">1738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (classYWeights > 0) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        defDL = RuleStats.dataDL(expFPRate, 0.0, totalWeights, 0.0,</div>
<div>1740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          classYWeights);</div>
<div>1741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>1742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        continue oneClass; // Subsumed by previous rules</div>
<div>1743&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1744&emsp;&emsp;</div>
<div style="background-color:limegreen;">1745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (Double.isNaN(defDL) || Double.isInfinite(defDL)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throw new Exception("Should never happen: " + "defDL NaN or infinite!");</div>
<div>1747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div style="background-color:limegreen;">1748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1749&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("The default DL = " + defDL);</div>
<div>1750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1751&emsp;&emsp;</div>
<div>1752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      data = rulesetForOneClass(expFPRate, data, classIndex, defDL);</div>
<div>1753&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1754&emsp;&emsp;</div>
<div>1755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Remove redundant numeric tests from the rules</div>
<div style="background-color:limegreen;">1756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    for (Rule rule : m_Ruleset) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ((RipperRule)rule).cleanUp(data);</div>
<div>1758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1759&emsp;&emsp;</div>
<div>1760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Set the default rule</div>
<div>1761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    RipperRule defRule = new RipperRule();</div>
<div>1762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    defRule.setConsequent(data.numClasses() - 1);</div>
<div>1763&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Ruleset.add(defRule);</div>
<div>1764&emsp;&emsp;</div>
<div>1765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    RuleStats defRuleStat = new RuleStats();</div>
<div>1766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    defRuleStat.setData(data);</div>
<div>1767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    defRuleStat.setNumAllConds(m_Total);</div>
<div>1768&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    defRuleStat.addAndUpdate(defRule);</div>
<div>1769&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_RulesetStats.add(defRuleStat);</div>
<div>1770&emsp;&emsp;</div>
<div style="background-color:limegreen;">1771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    for (int z = 0; z &#60; m_RulesetStats.size(); z++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      RuleStats oneClass = m_RulesetStats.get(z);</div>
<div style="background-color:limegreen;">1773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int xyz = 0; xyz &#60; oneClass.getRulesetSize(); xyz++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        double[] classDist = oneClass.getDistributions(xyz);</div>
<div>1775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Utils.normalize(classDist);</div>
<div style="background-color:limegreen;">1776&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (classDist != null) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          m_Distributions.add(((ClassOrder) m_Filter)</div>
<div>1778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            .distributionsByOriginalIndex(classDist));</div>
<div>1779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1782&emsp;&emsp;</div>
<div>1783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // free up memory</div>
<div style="background-color:limegreen;">1784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    for (int i = 0; i &#60; m_RulesetStats.size(); i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      (m_RulesetStats.get(i)).cleanUp();</div>
<div>1786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1787&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>1788&emsp;&emsp;</div>
<div>1789&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>1790&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Classify the test instance with the rule learner and provide the class</div>
<div>1791&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * distributions</div>
<div>1792&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>1793&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param datum the instance to be classified</div>
<div>1794&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the distribution</div>
<div>1795&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>1796&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>1797&emsp;&emsp;&nbsp;&nbsp;  public double[] distributionForInstance(Instance datum) {</div>
<div>1798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    try {</div>
<div style="background-color:limegreen;">1799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int i = 0; i &#60; m_Ruleset.size(); i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Rule rule = m_Ruleset.get(i);</div>
<div style="background-color:limegreen;">1801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (rule.covers(datum)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          return m_Distributions.get(i);</div>
<div>1803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    } catch (Exception e) {</div>
<div>1806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println(e.getMessage());</div>
<div>1807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      e.printStackTrace();</div>
<div>1808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1809&emsp;&emsp;</div>
<div>1810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    System.err.println("Should never happen!");</div>
<div>1811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return new double[datum.classAttribute().numValues()];</div>
<div>1812&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>1813&emsp;&emsp;</div>
<div>1814&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>1815&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Build a ruleset for the given class according to the given data</div>
<div>1816&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>1817&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param expFPRate the expected FP/(FP+FN) used in DL calculation</div>
<div>1818&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param data the given data</div>
<div>1819&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param classIndex the given class index</div>
<div>1820&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param defDL the default DL in the data</div>
<div>1821&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @throws Exception if the ruleset can be built properly</div>
<div>1822&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>1823&emsp;&emsp;&nbsp;&nbsp;  protected Instances rulesetForOneClass(double expFPRate, Instances data,</div>
<div>1824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    double classIndex, double defDL) throws Exception {</div>
<div>1825&emsp;&emsp;</div>
<div>1826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    Instances newData = data, growData, pruneData;</div>
<div>1827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean stop = false;</div>
<div>1828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    ArrayList&#60;Rule> ruleset = new ArrayList&#60;Rule>();</div>
<div>1829&emsp;&emsp;</div>
<div>1830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    double dl = defDL, minDL = defDL;</div>
<div>1831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    RuleStats rstats = null;</div>
<div>1832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    double[] rst;</div>
<div>1833&emsp;&emsp;</div>
<div>1834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Check whether data have positive examples</div>
<div>1835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean defHasPositive = true; // No longer used</div>
<div>1836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean hasPositive = defHasPositive;</div>
<div>1837&emsp;&emsp;</div>
<div>1838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /********************** Building stage ***********************/</div>
<div style="background-color:limegreen;">1839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println("\n*** Building stage ***");</div>
<div>1841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1842&emsp;&emsp;</div>
<div style="background-color:limegreen;">1843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    while ((!stop) && hasPositive) { // Generate new rules until&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // stopping criteria met</div>
<div>1845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      RipperRule oneRule;</div>
<div style="background-color:limegreen;">1846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_UsePruning) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Split data into Grow and Prune */</div>
<div>1848&emsp;&emsp;</div>
<div>1849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // We should have stratified the data, but ripper seems</div>
<div>1850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // to have a bug that makes it not to do so. In order</div>
<div>1851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // to simulate it more precisely, we do the same thing.</div>
<div>1852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // newData.randomize(m_Random);</div>
<div>1853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        newData = RuleStats.stratify(newData, m_Folds, m_Random);</div>
<div>1854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Instances[] part = RuleStats.partition(newData, m_Folds);</div>
<div>1855&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        growData = part[0];</div>
<div>1856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        pruneData = part[1];</div>
<div>1857&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // growData=newData.trainCV(m_Folds, m_Folds-1);</div>
<div>1858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // pruneData=newData.testCV(m_Folds, m_Folds-1);</div>
<div>1859&emsp;&emsp;</div>
<div>1860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule = new RipperRule();</div>
<div>1861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule.setConsequent(classIndex); // Must set first</div>
<div>1862&emsp;&emsp;</div>
<div style="background-color:limegreen;">1863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("\nGrowing a rule ...");</div>
<div>1865&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1866&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule.grow(growData); // Build the rule</div>
<div style="background-color:limegreen;">1867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("One rule found before pruning:"</div>
<div>1869&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            + oneRule.toString(m_Class));</div>
<div>1870&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1871&emsp;&emsp;</div>
<div style="background-color:limegreen;">1872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("\nPruning the rule ...");</div>
<div>1874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule.prune(pruneData, false); // Prune the rule</div>
<div style="background-color:limegreen;">1876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1877&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("One rule found after pruning:"</div>
<div>1878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            + oneRule.toString(m_Class));</div>
<div>1879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>1881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule = new RipperRule();</div>
<div>1882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule.setConsequent(classIndex); // Must set first</div>
<div style="background-color:limegreen;">1883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("\nNo pruning: growing a rule ...");</div>
<div>1885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oneRule.grow(newData); // Build the rule</div>
<div style="background-color:limegreen;">1887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("No pruning: one rule found:\n"</div>
<div>1889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            + oneRule.toString(m_Class));</div>
<div>1890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1892&emsp;&emsp;</div>
<div>1893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // Compute the DL of this ruleset</div>
<div style="background-color:limegreen;">1894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (rstats == null) { // First rule&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1895&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        rstats = new RuleStats();</div>
<div>1896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        rstats.setNumAllConds(m_Total);</div>
<div>1897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        rstats.setData(newData);</div>
<div>1898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1899&emsp;&emsp;</div>
<div>1900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      rstats.addAndUpdate(oneRule);</div>
<div>1901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int last = rstats.getRuleset().size() - 1; // Index of last rule</div>
<div>1902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      dl += rstats.relativeDL(last, expFPRate, m_CheckErr);</div>
<div>1903&emsp;&emsp;</div>
<div style="background-color:limegreen;">1904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (Double.isNaN(dl) || Double.isInfinite(dl)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throw new Exception("Should never happen: dl in "</div>
<div>1906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + "building stage NaN or infinite!");</div>
<div>1907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div style="background-color:limegreen;">1908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("Before optimization(" + last + "): the dl = " + dl</div>
<div>1910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + " | best: " + minDL);</div>
<div>1911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1912&emsp;&emsp;</div>
<div style="background-color:limegreen;">1913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (dl &#60; minDL) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        minDL = dl; // The best dl so far</div>
<div>1915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1916&emsp;&emsp;</div>
<div>1917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      rst = rstats.getSimpleStats(last);</div>
<div style="background-color:limegreen;">1918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("The rule covers: " + rst[0] + " | pos = " + rst[2]</div>
<div>1920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1]</div>
<div>1921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + " | pos = " + rst[5]);</div>
<div>1922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1923&emsp;&emsp;</div>
<div>1924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      stop = checkStop(rst, minDL, dl);</div>
<div>1925&emsp;&emsp;</div>
<div style="background-color:limegreen;">1926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (!stop) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ruleset.add(oneRule); // Accepted</div>
<div>1928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        newData = rstats.getFiltered(last)[1];// Data not covered</div>
<div>1929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        hasPositive = Utils.gr(rst[5], 0.0); // Positives remaining?</div>
<div style="background-color:limegreen;">1930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("One rule added: has positive? " + hasPositive);</div>
<div>1932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div style="background-color:limegreen;">1934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("Quit rule");</div>
<div>1936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        rstats.removeLast(); // Remove last to be re-used</div>
<div>1938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>1939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }// while !stop</div>
<div>1940&emsp;&emsp;</div>
<div>1941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /******************** Optimization stage *******************/</div>
<div>1942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    RuleStats finalRulesetStat = null;</div>
<div style="background-color:limegreen;">1943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_UsePruning) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int z = 0; z &#60; m_Optimizations; z++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("\n*** Optimization: run #" + z + " ***");</div>
<div>1947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1948&emsp;&emsp;</div>
<div>1949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        newData = data;</div>
<div>1950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        finalRulesetStat = new RuleStats();</div>
<div>1951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        finalRulesetStat.setData(newData);</div>
<div>1952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        finalRulesetStat.setNumAllConds(m_Total);</div>
<div>1953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int position = 0;</div>
<div>1954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        stop = false;</div>
<div>1955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean isResidual = false;</div>
<div>1956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        hasPositive = defHasPositive;</div>
<div>1957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        dl = minDL = defDL;</div>
<div>1958&emsp;&emsp;</div>
<div style="background-color:limegreen;">1959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        oneRule: while (!stop && hasPositive) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1960&emsp;&emsp;</div>
<div style="background-color:limegreen;">1961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          isResidual = (position >= ruleset.size()); // Cover residual positive&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                     // examples</div>
<div>1963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // Re-do shuffling and stratification</div>
<div>1964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // newData.randomize(m_Random);</div>
<div>1965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          newData = RuleStats.stratify(newData, m_Folds, m_Random);</div>
<div>1966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          Instances[] part = RuleStats.partition(newData, m_Folds);</div>
<div>1967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          growData = part[0];</div>
<div>1968&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          pruneData = part[1];</div>
<div>1969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // growData=newData.trainCV(m_Folds, m_Folds-1);</div>
<div>1970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // pruneData=newData.testCV(m_Folds, m_Folds-1);</div>
<div>1971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          RipperRule finalRule;</div>
<div>1972&emsp;&emsp;</div>
<div style="background-color:limegreen;">1973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.err.println("\nRule #" + position + "| isResidual?"</div>
<div>1975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              + isResidual + "| data size: " + newData.sumOfWeights());</div>
<div>1976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>1977&emsp;&emsp;</div>
<div style="background-color:limegreen;">1978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (isResidual) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            RipperRule newRule = new RipperRule();</div>
<div>1980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newRule.setConsequent(classIndex);</div>
<div style="background-color:limegreen;">1981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("\nGrowing and pruning" + " a new rule ...");</div>
<div>1983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newRule.grow(growData);</div>
<div>1985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newRule.prune(pruneData, false);</div>
<div>1986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            finalRule = newRule;</div>
<div style="background-color:limegreen;">1987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("\nNew rule found: "</div>
<div>1989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + newRule.toString(m_Class));</div>
<div>1990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          } else {</div>
<div>1992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            RipperRule oldRule = (RipperRule) ruleset.get(position);</div>
<div>1993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean covers = false;</div>
<div>1994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // Test coverage of the next old rule</div>
<div style="background-color:limegreen;">1995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = 0; i &#60; newData.numInstances(); i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">1996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>              if (oldRule.covers(newData.instance(i))) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>1997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                covers = true;</div>
<div>1998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                break;</div>
<div>1999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              }</div>
<div>2000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2001&emsp;&emsp;</div>
<div style="background-color:limegreen;">2002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!covers) {// Null coverage, no variants can be generated&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              finalRulesetStat.addAndUpdate(oldRule);</div>
<div>2004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              position++;</div>
<div>2005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              continue oneRule;</div>
<div>2006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2007&emsp;&emsp;</div>
<div>2008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // 2 variants</div>
<div style="background-color:limegreen;">2009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("\nGrowing and pruning" + " Replace ...");</div>
<div>2011&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            RipperRule replace = new RipperRule();</div>
<div>2013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            replace.setConsequent(classIndex);</div>
<div>2014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            replace.grow(growData);</div>
<div>2015&emsp;&emsp;</div>
<div>2016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // Remove the pruning data covered by the following</div>
<div>2017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // rules, then simply compute the error rate of the</div>
<div>2018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // current rule to prune it. According to Ripper,</div>
<div>2019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // it's equivalent to computing the error of the</div>
<div>2020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // whole ruleset -- is it true?</div>
<div>2021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            pruneData = RuleStats.rmCoveredBySuccessives(pruneData, ruleset,</div>
<div>2022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              position);</div>
<div>2023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            replace.prune(pruneData, true);</div>
<div>2024&emsp;&emsp;</div>
<div style="background-color:limegreen;">2025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("\nGrowing and pruning" + " Revision ...");</div>
<div>2027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            RipperRule revision = (RipperRule) oldRule.copy();</div>
<div>2029&emsp;&emsp;</div>
<div>2030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // For revision, first rm the data covered by the old rule</div>
<div>2031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Instances newGrowData = new Instances(growData, 0);</div>
<div style="background-color:limegreen;">2032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int b = 0; b &#60; growData.numInstances(); b++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              Instance inst = growData.instance(b);</div>
<div style="background-color:limegreen;">2034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>              if (revision.covers(inst)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                newGrowData.add(inst);</div>
<div>2036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              }</div>
<div>2037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            revision.grow(newGrowData);</div>
<div>2039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            revision.prune(pruneData, true);</div>
<div>2040&emsp;&emsp;</div>
<div>2041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            double[][] prevRuleStats = new double[position][6];</div>
<div style="background-color:limegreen;">2042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int c = 0; c &#60; position; c++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              prevRuleStats[c] = finalRulesetStat.getSimpleStats(c);</div>
<div>2044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2045&emsp;&emsp;</div>
<div>2046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // Now compare the relative DL of variants</div>
<div>2047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ArrayList&#60;Rule> tempRules = new ArrayList&#60;Rule>(ruleset.size());</div>
<div style="background-color:limegreen;">2048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (Rule r : ruleset) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2049&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              tempRules.add((Rule) r.copy());</div>
<div>2050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            tempRules.set(position, replace);</div>
<div>2052&emsp;&emsp;</div>
<div>2053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            RuleStats repStat = new RuleStats(data, tempRules);</div>
<div>2054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            repStat.setNumAllConds(m_Total);</div>
<div>2055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            repStat.countData(position, newData, prevRuleStats);</div>
<div>2056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // repStat.countData();</div>
<div>2057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            rst = repStat.getSimpleStats(position);</div>
<div style="background-color:limegreen;">2058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("Replace rule covers: " + rst[0] + " | pos = "</div>
<div>2060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: "</div>
<div>2061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + rst[1] + " | pos = " + rst[5]);</div>
<div>2062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2063&emsp;&emsp;</div>
<div>2064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            double repDL = repStat.relativeDL(position, expFPRate, m_CheckErr);</div>
<div style="background-color:limegreen;">2065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("\nReplace: " + replace.toString(m_Class)</div>
<div>2067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + " |dl = " + repDL);</div>
<div>2068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2069&emsp;&emsp;</div>
<div style="background-color:limegreen;">2070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (Double.isNaN(repDL) || Double.isInfinite(repDL)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              throw new Exception("Should never happen: repDL"</div>
<div>2072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + "in optmz. stage NaN or " + "infinite!");</div>
<div>2073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2074&emsp;&emsp;</div>
<div>2075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            tempRules.set(position, revision);</div>
<div>2076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            RuleStats revStat = new RuleStats(data, tempRules);</div>
<div>2077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            revStat.setNumAllConds(m_Total);</div>
<div>2078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            revStat.countData(position, newData, prevRuleStats);</div>
<div>2079&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // revStat.countData();</div>
<div>2080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            double revDL = revStat.relativeDL(position, expFPRate, m_CheckErr);</div>
<div>2081&emsp;&emsp;</div>
<div style="background-color:limegreen;">2082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("Revision: " + revision.toString(m_Class)</div>
<div>2084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + " |dl = " + revDL);</div>
<div>2085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2086&emsp;&emsp;</div>
<div style="background-color:limegreen;">2087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (Double.isNaN(revDL) || Double.isInfinite(revDL)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              throw new Exception("Should never happen: revDL"</div>
<div>2089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + "in optmz. stage NaN or " + "infinite!");</div>
<div>2090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2091&emsp;&emsp;</div>
<div>2092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            rstats = new RuleStats(data, ruleset);</div>
<div>2093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            rstats.setNumAllConds(m_Total);</div>
<div>2094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            rstats.countData(position, newData, prevRuleStats);</div>
<div>2095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            // rstats.countData();</div>
<div>2096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            double oldDL = rstats.relativeDL(position, expFPRate, m_CheckErr);</div>
<div>2097&emsp;&emsp;</div>
<div style="background-color:limegreen;">2098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (Double.isNaN(oldDL) || Double.isInfinite(oldDL)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              throw new Exception("Should never happen: oldDL"</div>
<div>2100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + "in optmz. stage NaN or " + "infinite!");</div>
<div>2101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">2102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("Old rule: " + oldRule.toString(m_Class)</div>
<div>2104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + " |dl = " + oldDL);</div>
<div>2105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2106&emsp;&emsp;</div>
<div style="background-color:limegreen;">2107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("\nrepDL: " + repDL + "\nrevDL: " + revDL</div>
<div>2109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + "\noldDL: " + oldDL);</div>
<div>2110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2111&emsp;&emsp;</div>
<div style="background-color:limegreen;">2112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if ((oldDL &#60;= revDL) && (oldDL &#60;= repDL)) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES] & [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              finalRule = oldRule; // Old the best</div>
<div style="background-color:limegreen;">2114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            } else if (revDL &#60;= repDL) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              finalRule = revision; // Revision the best</div>
<div>2116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>2117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              finalRule = replace; // Replace the best</div>
<div>2118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>2120&emsp;&emsp;</div>
<div>2121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          finalRulesetStat.addAndUpdate(finalRule);</div>
<div>2122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          rst = finalRulesetStat.getSimpleStats(position);</div>
<div>2123&emsp;&emsp;</div>
<div style="background-color:limegreen;">2124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (isResidual) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2125&emsp;&emsp;</div>
<div>2126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            dl += finalRulesetStat.relativeDL(position, expFPRate, m_CheckErr);</div>
<div style="background-color:limegreen;">2127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("After optimization: the dl" + "=" + dl</div>
<div>2129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + " | best: " + minDL);</div>
<div>2130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2131&emsp;&emsp;</div>
<div style="background-color:limegreen;">2132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (dl &#60; minDL) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              minDL = dl; // The best dl so far</div>
<div>2134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2135&emsp;&emsp;</div>
<div>2136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            stop = checkStop(rst, minDL, dl);</div>
<div style="background-color:limegreen;">2137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!stop) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              ruleset.add(finalRule); // Accepted</div>
<div>2139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>2140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              finalRulesetStat.removeLast(); // Remove last to be re-used</div>
<div>2141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              position--;</div>
<div>2142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          } else {</div>
<div>2144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ruleset.set(position, finalRule); // Accepted</div>
<div>2145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>2146&emsp;&emsp;</div>
<div style="background-color:limegreen;">2147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.err.println("The rule covers: " + rst[0] + " | pos = "</div>
<div>2149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: "</div>
<div>2150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              + rst[1] + " | pos = " + rst[5]);</div>
<div>2151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.err.println("\nRuleset so far: ");</div>
<div style="background-color:limegreen;">2152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int x = 0; x &#60; ruleset.size(); x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println(x + ": "</div>
<div>2154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                + ((RipperRule) ruleset.get(x)).toString(m_Class));</div>
<div>2155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.err.println();</div>
<div>2157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>2158&emsp;&emsp;</div>
<div>2159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          // Data not covered</div>
<div style="background-color:limegreen;">2160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          if (finalRulesetStat.getRulesetSize() > 0) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newData = finalRulesetStat.getFiltered(position)[1];</div>
<div>2162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>2163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          hasPositive = Utils.gr(rst[5], 0.0); // Positives remaining?</div>
<div>2164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          position++;</div>
<div>2165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } // while !stop && hasPositive</div>
<div>2166&emsp;&emsp;</div>
<div style="background-color:limegreen;">2167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ruleset.size() > (position + 1)) { // Hasn't gone through yet&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">2168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>          for (int k = position + 1; k &#60; ruleset.size(); k++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            finalRulesetStat.addAndUpdate(ruleset.get(k));</div>
<div>2170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          }</div>
<div>2171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div style="background-color:limegreen;">2172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("\nDeleting rules to decrease"</div>
<div>2174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            + " DL of the whole ruleset ...");</div>
<div>2175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        finalRulesetStat.reduceDL(expFPRate, m_CheckErr);</div>
<div style="background-color:limegreen;">2177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          int del = ruleset.size() - finalRulesetStat.getRulesetSize();</div>
<div>2179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println(del + " rules are deleted"</div>
<div>2180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            + " after DL reduction procedure");</div>
<div>2181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ruleset = finalRulesetStat.getRuleset();</div>
<div>2183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        rstats = finalRulesetStat;</div>
<div>2184&emsp;&emsp;</div>
<div>2185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } // For each run of optimization</div>
<div>2186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // if pruning is used</div>
<div>2187&emsp;&emsp;</div>
<div>2188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Concatenate the ruleset for this class to the whole ruleset</div>
<div style="background-color:limegreen;">2189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println("\nFinal ruleset: ");</div>
<div style="background-color:limegreen;">2191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int x = 0; x &#60; ruleset.size(); x++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println(x + ": "</div>
<div>2193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + ((RipperRule) ruleset.get(x)).toString(m_Class));</div>
<div>2194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println();</div>
<div>2196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2197&emsp;&emsp;</div>
<div>2198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_Ruleset.addAll(ruleset);</div>
<div>2199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    m_RulesetStats.add(rstats);</div>
<div>2200&emsp;&emsp;</div>
<div style="background-color:limegreen;">2201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (ruleset.size() > 0) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return rstats.getFiltered(ruleset.size() - 1)[1]; // Data not</div>
<div>2203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {</div>
<div>2204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return data;</div>
<div>2205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2206&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>2207&emsp;&emsp;</div>
<div>2208&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>2209&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Check whether the stopping criterion meets</div>
<div>2210&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>2211&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param rst the statistic of the ruleset</div>
<div>2212&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param minDL the min description length so far</div>
<div>2213&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param dl the current description length of the ruleset</div>
<div>2214&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return true if stop criterion meets, false otherwise</div>
<div>2215&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>2216&emsp;&emsp;&nbsp;&nbsp;  private boolean checkStop(double[] rst, double minDL, double dl) {</div>
<div>2217&emsp;&emsp;</div>
<div style="background-color:limegreen;">2218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (dl > minDL + MAX_DL_SURPLUS) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">2219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("DL too large: " + dl + " | " + minDL);</div>
<div>2221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return true;</div>
<div style="background-color:limegreen;">2223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    } else if (!Utils.gr(rst[2], 0.0)) {// Covered positives&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">2224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("Too few positives.");</div>
<div>2226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return true;</div>
<div style="background-color:limegreen;">2228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    } else if ((rst[4] / rst[0]) >= 0.5) {// Err rate&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">2229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_CheckErr) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div style="background-color:limegreen;">2230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          System.err.println("Error too large: " + rst[4] + "/" + rst[0]);</div>
<div>2232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>2234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>2235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>2236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {// Not stops</div>
<div style="background-color:limegreen;">2238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println("Continue.");</div>
<div>2240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return false;</div>
<div>2242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2243&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>2244&emsp;&emsp;</div>
<div>2245&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>2246&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Prints the all the rules of the rule learner.</div>
<div>2247&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>2248&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return a textual description of the classifier</div>
<div>2249&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>2250&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>2251&emsp;&emsp;&nbsp;&nbsp;  public String toString() {</div>
<div style="background-color:limegreen;">2252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_Ruleset == null) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      return "JRIP: No model built yet.";</div>
<div>2254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2255&emsp;&emsp;</div>
<div>2256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    StringBuffer sb = new StringBuffer("JRIP rules:\n" + "===========\n\n");</div>
<div style="background-color:limegreen;">2257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    for (int j = 0; j &#60; m_RulesetStats.size(); j++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      RuleStats rs = m_RulesetStats.get(j);</div>
<div>2259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ArrayList&#60;Rule> rules = rs.getRuleset();</div>
<div style="background-color:limegreen;">2260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int k = 0; k &#60; rules.size(); k++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        double[] simStats = rs.getSimpleStats(k);</div>
<div>2262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(((RipperRule) rules.get(k)).toString(m_Class) + " ("</div>
<div>2263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          + simStats[0] + "/" + simStats[4] + ")\n");</div>
<div>2264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div style="background-color:limegreen;">2266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>    if (m_Debug) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.err.println("Inside m_Ruleset");</div>
<div style="background-color:limegreen;">2268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>      for (int i = 0; i &#60; m_Ruleset.size(); i++) {&nbsp;&#8594; [OPTIMIZATIONS, BATCHSIZE, NUMDECIMAL, PRUNE, SEED, CHECKERROR, MINNO, DEBUG, FOLDS, NOCHECKCAPABILITIES]</b></div>
<div>2269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.err.println(((RipperRule) m_Ruleset.get(i)).toString(m_Class));</div>
<div>2270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    sb.append("\nNumber of Rules : " + m_Ruleset.size() + "\n");</div>
<div>2273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return sb.toString();</div>
<div>2274&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>2275&emsp;&emsp;</div>
<div>2276&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>2277&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Returns the revision string.</div>
<div>2278&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>2279&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @return the revision</div>
<div>2280&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>2281&emsp;&emsp;&nbsp;&nbsp;  @Override</div>
<div>2282&emsp;&emsp;&nbsp;&nbsp;  public String getRevision() {</div>
<div>2283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    return RevisionUtils.extract("$Revision: 13402 $");</div>
<div>2284&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>2285&emsp;&emsp;</div>
<div>2286&emsp;&emsp;&nbsp;&nbsp;  /**</div>
<div>2287&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * Main method.</div>
<div>2288&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * </div>
<div>2289&emsp;&emsp;&nbsp;&nbsp;&nbsp;   * @param args the options for the classifier</div>
<div>2290&emsp;&emsp;&nbsp;&nbsp;&nbsp;   */</div>
<div>2291&emsp;&emsp;&nbsp;&nbsp;  public static void main(String[] args) {</div>
<div>2292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    runClassifier(new JRip(), args);</div>
<div>2293&emsp;&emsp;&nbsp;&nbsp;  }</div>
<div>2294&emsp;&emsp;}</div>
</div>
</div>
</body>
</html>