    public static double dataDL(double, double, double, double, double)
    {
        double expFPOverErr, cover, uncover, fp, fn, totalBits, $d0, $d1, $d2, expErr#15, $d3, coverBits#22, $d4, $d5, uncoverBits#32, $d6, $d7, expErr#40, $d8, $d9, $d10, $d11, $d12;
        boolean $z0, $z1, $z2;

        expFPOverErr := @parameter0: double;

        cover := @parameter1: double;

        uncover := @parameter2: double;

        fp := @parameter3: double;

        fn := @parameter4: double;

        $d0 = cover + uncover;

        $d1 = $d0 + 1.0;

        totalBits = staticinvoke <weka.core.Utils: double log2(double)>($d1);

        $z0 = staticinvoke <weka.core.Utils: boolean gr(double,double)>(cover, uncover);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label3;

        $d2 = fp + fn;

        expErr#15 = expFPOverErr * $d2;

        $d3 = expErr#15 / cover;

        coverBits#22 = staticinvoke <weka.classifiers.rules.RuleStats: double subsetDL(double,double,double)>(cover, fp, $d3);

        $z1 = staticinvoke <weka.core.Utils: boolean gr(double,double)>(uncover, 0.0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z1);

        if $z1 == 0 goto label1;

        $d4 = fn / uncover;

        $d5 = staticinvoke <weka.classifiers.rules.RuleStats: double subsetDL(double,double,double)>(uncover, fn, $d4);

        goto label2;

     label1:
        $d5 = 0.0;

     label2:
        uncoverBits#32 = $d5;

        goto label6;

     label3:
        $d6 = 1.0 - expFPOverErr;

        $d7 = fp + fn;

        expErr#40 = $d6 * $d7;

        $z2 = staticinvoke <weka.core.Utils: boolean gr(double,double)>(cover, 0.0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z2);

        if $z2 == 0 goto label4;

        $d8 = fp / cover;

        $d9 = staticinvoke <weka.classifiers.rules.RuleStats: double subsetDL(double,double,double)>(cover, fp, $d8);

        goto label5;

     label4:
        $d9 = 0.0;

     label5:
        coverBits#22 = $d9;

        $d10 = expErr#40 / uncover;

        uncoverBits#32 = staticinvoke <weka.classifiers.rules.RuleStats: double subsetDL(double,double,double)>(uncover, fn, $d10);

     label6:
        $d11 = totalBits + coverBits#22;

        $d12 = $d11 + uncoverBits#32;

        return $d12;
    }

    public static double numAllConditions(weka.core.Instances)
    {
        weka.core.Instances data;
        java.util.Enumeration attEnum;
        weka.core.Attribute att;
        double total#2, $d0, $d1, $d2;
        boolean $z0, $z1;
        java.lang.Object $r0;
        int $i0, $i1;

        data := @parameter0: weka.core.Instances;

        total#2 = 0.0;

        attEnum = virtualinvoke data.<weka.core.Instances: java.util.Enumeration enumerateAttributes()>();

     label1:
        $z0 = interfaceinvoke attEnum.<java.util.Enumeration: boolean hasMoreElements()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label4;

        $r0 = interfaceinvoke attEnum.<java.util.Enumeration: java.lang.Object nextElement()>();

        att = (weka.core.Attribute) $r0;

        $z1 = virtualinvoke att.<weka.core.Attribute: boolean isNominal()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z1);

        if $z1 == 0 goto label2;

        $i0 = virtualinvoke att.<weka.core.Attribute: int numValues()>();

        $d0 = (double) $i0;

        total#2 = total#2 + $d0;

        goto label3;

     label2:
        $i1 = virtualinvoke data.<weka.core.Instances: int numDistinctValues(weka.core.Attribute)>(att);

        $d1 = (double) $i1;

        $d2 = 2.0 * $d1;

        total#2 = total#2 + $d2;

     label3:
        goto label1;

     label4:
        return total#2;
    }

    static void <clinit>()
    {
        <weka.classifiers.rules.RuleStats: double REDUNDANCY_FACTOR> = 0.5;

        return;
    }

    public static double subsetDL(double, double, double)
    {
        double t, k, p, $d0, $d1, $d2, rt#9, $d3, $d4, $d5, $d6, rt#19;
        boolean $z0;

        t := @parameter0: double;

        k := @parameter1: double;

        p := @parameter2: double;

        $z0 = staticinvoke <weka.core.Utils: boolean gr(double,double)>(p, 0.0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label1;

        $d0 = neg k;

        $d1 = staticinvoke <weka.core.Utils: double log2(double)>(p);

        $d2 = $d0 * $d1;

        goto label2;

     label1:
        $d2 = 0.0;

     label2:
        rt#9 = $d2;

        $d3 = t - k;

        $d4 = 1.0 - p;

        $d5 = staticinvoke <weka.core.Utils: double log2(double)>($d4);

        $d6 = $d3 * $d5;

        rt#19 = rt#9 - $d6;

        return rt#19;
    }

    public void setData(weka.core.Instances)
    {
        weka.classifiers.rules.RuleStats this;
        weka.core.Instances data;

        this := @this: weka.classifiers.rules.RuleStats;

        data := @parameter0: weka.core.Instances;

        this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data> = data;

        return;
    }

    public void setNumAllConds(double)
    {
        weka.classifiers.rules.RuleStats this;
        double total, $d0;
        byte $b0;
        weka.core.Instances $r0;

        this := @this: weka.classifiers.rules.RuleStats;

        total := @parameter0: double;

        $b0 = total cmpg 0.0;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b0);

        if $b0 >= 0 goto label1;

        $r0 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        $d0 = staticinvoke <weka.classifiers.rules.RuleStats: double numAllConditions(weka.core.Instances)>($r0);

        this.<weka.classifiers.rules.RuleStats: double m_Total> = $d0;

        goto label2;

     label1:
        this.<weka.classifiers.rules.RuleStats: double m_Total> = total;

     label2:
        return;
    }

    public void addAndUpdate(weka.classifiers.rules.Rule)
    {
        weka.classifiers.rules.RuleStats this;
        weka.classifiers.rules.Rule lastRule;
        weka.core.Instances data, $r4, $r9;
        double[] stats, classCounts;
        weka.core.Instances[] filtered, $r8;
        java.util.ArrayList $r0, $r1, $r2, $r3, $r5, $r6, $r11, $r12, $r13, $r14, $r15, $r16, $r17, $r18, $r19, $r20;
        int $i0, $i1, $i2, $i3, $i4;
        java.lang.Object $r7;
        weka.core.Attribute $r10;

        this := @this: weka.classifiers.rules.RuleStats;

        lastRule := @parameter0: weka.classifiers.rules.Rule;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r0);

        if $r0 != null goto label1;

        $r1 = new java.util.ArrayList;

        specialinvoke $r1.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset> = $r1;

     label1:
        $r2 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        virtualinvoke $r2.<java.util.ArrayList: boolean add(java.lang.Object)>(lastRule);

        $r3 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r3);

        if $r3 != null goto label2;

        $r4 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        goto label3;

     label2:
        $r5 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        $r6 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        $i0 = virtualinvoke $r6.<java.util.ArrayList: int size()>();

        $i1 = $i0 - 1;

        $r7 = virtualinvoke $r5.<java.util.ArrayList: java.lang.Object get(int)>($i1);

        $r8 = (weka.core.Instances[]) $r7;

        $r4 = $r8[1];

     label3:
        data = $r4;

        stats = newarray (double)[6];

        $r9 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        $r10 = virtualinvoke $r9.<weka.core.Instances: weka.core.Attribute classAttribute()>();

        $i2 = virtualinvoke $r10.<weka.core.Attribute: int numValues()>();

        classCounts = newarray (double)[$i2];

        $r11 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $i3 = virtualinvoke $r11.<java.util.ArrayList: int size()>();

        $i4 = $i3 - 1;

        filtered = specialinvoke this.<weka.classifiers.rules.RuleStats: weka.core.Instances[] computeSimpleStats(int,weka.core.Instances,double[],double[])>($i4, data, stats, classCounts);

        $r12 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r12);

        if $r12 != null goto label4;

        $r13 = new java.util.ArrayList;

        specialinvoke $r13.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered> = $r13;

     label4:
        $r14 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        virtualinvoke $r14.<java.util.ArrayList: boolean add(java.lang.Object)>(filtered);

        $r15 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r15);

        if $r15 != null goto label5;

        $r16 = new java.util.ArrayList;

        specialinvoke $r16.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats> = $r16;

     label5:
        $r17 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        virtualinvoke $r17.<java.util.ArrayList: boolean add(java.lang.Object)>(stats);

        $r18 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r18);

        if $r18 != null goto label6;

        $r19 = new java.util.ArrayList;

        specialinvoke $r19.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions> = $r19;

     label6:
        $r20 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions>;

        virtualinvoke $r20.<java.util.ArrayList: boolean add(java.lang.Object)>(classCounts);

        return;
    }

    private weka.core.Instances[] computeSimpleStats(int, weka.core.Instances, double[], double[])
    {
        weka.classifiers.rules.RuleStats this;
        int index, $i0, $i1, i#23, $i2, $i4, $i5, $i8, $i10, $i11;
        weka.core.Instances insts, $r2, $r3, $r4, $r9;
        double[] stats, dist;
        weka.classifiers.rules.Rule rule;
        weka.core.Instances[] data;
        weka.core.Instance datum;
        double weight, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7, $d8, $d9, $d10, $d11, $d12, $d13, $d14, $d15, $d16, $d17, $d18;
        java.util.ArrayList $r0;
        java.lang.Object $r1;
        boolean $z0;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        insts := @parameter1: weka.core.Instances;

        stats := @parameter2: double[];

        dist := @parameter3: double[];

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $r1 = virtualinvoke $r0.<java.util.ArrayList: java.lang.Object get(int)>(index);

        rule = (weka.classifiers.rules.Rule) $r1;

        data = newarray (weka.core.Instances)[2];

        $r2 = new weka.core.Instances;

        $i0 = virtualinvoke insts.<weka.core.Instances: int numInstances()>();

        specialinvoke $r2.<weka.core.Instances: void <init>(weka.core.Instances,int)>(insts, $i0);

        data[0] = $r2;

        $r3 = new weka.core.Instances;

        $i1 = virtualinvoke insts.<weka.core.Instances: int numInstances()>();

        specialinvoke $r3.<weka.core.Instances: void <init>(weka.core.Instances,int)>(insts, $i1);

        data[1] = $r3;

        i#23 = 0;

     label1:
        $i2 = virtualinvoke insts.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#23);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i2);

        if i#23 >= $i2 goto label7;

        datum = virtualinvoke insts.<weka.core.Instances: weka.core.Instance instance(int)>(i#23);

        weight = interfaceinvoke datum.<weka.core.Instance: double weight()>();

        $z0 = virtualinvoke rule.<weka.classifiers.rules.Rule: boolean covers(weka.core.Instance)>(datum);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label4;

        $r4 = data[0];

        virtualinvoke $r4.<weka.core.Instances: boolean add(weka.core.Instance)>(datum);

        $d0 = stats[0];

        $d1 = $d0 + weight;

        stats[0] = $d1;

        $d2 = interfaceinvoke datum.<weka.core.Instance: double classValue()>();

        $i4 = (int) $d2;

        $d3 = virtualinvoke rule.<weka.classifiers.rules.Rule: double getConsequent()>();

        $i5 = (int) $d3;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i4);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i5);

        if $i4 != $i5 goto label2;

        $d4 = stats[2];

        $d5 = $d4 + weight;

        stats[2] = $d5;

        goto label3;

     label2:
        $d6 = stats[4];

        $d7 = $d6 + weight;

        stats[4] = $d7;

     label3:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(dist);

        if dist == null goto label6;

        $d8 = interfaceinvoke datum.<weka.core.Instance: double classValue()>();

        $i8 = (int) $d8;

        $d9 = dist[$i8];

        $d10 = $d9 + weight;

        dist[$i8] = $d10;

        goto label6;

     label4:
        $r9 = data[1];

        virtualinvoke $r9.<weka.core.Instances: boolean add(weka.core.Instance)>(datum);

        $d11 = stats[1];

        $d12 = $d11 + weight;

        stats[1] = $d12;

        $d13 = interfaceinvoke datum.<weka.core.Instance: double classValue()>();

        $i10 = (int) $d13;

        $d14 = virtualinvoke rule.<weka.classifiers.rules.Rule: double getConsequent()>();

        $i11 = (int) $d14;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i10);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i11);

        if $i10 == $i11 goto label5;

        $d15 = stats[3];

        $d16 = $d15 + weight;

        stats[3] = $d16;

        goto label6;

     label5:
        $d17 = stats[5];

        $d18 = $d17 + weight;

        stats[5] = $d18;

     label6:
        i#23 = i#23 + 1;

        goto label1;

     label7:
        return data;
    }

    public void <init>()
    {
        weka.classifiers.rules.RuleStats this;

        this := @this: weka.classifiers.rules.RuleStats;

        specialinvoke this.<java.lang.Object: void <init>()>();

        this.<weka.classifiers.rules.RuleStats: double MDL_THEORY_WEIGHT> = 1.0;

        this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data> = null;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset> = null;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats> = null;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered> = null;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions> = null;

        this.<weka.classifiers.rules.RuleStats: double m_Total> = -1.0;

        return;
    }

    public static weka.core.Instances rmCoveredBySuccessives(weka.core.Instances, java.util.ArrayList, int)
    {
        weka.core.Instances data, rt, $r0;
        java.util.ArrayList rules;
        int index, i#4, $i0, j#16, $i1;
        weka.core.Instance datum;
        weka.classifiers.rules.Rule rule;
        boolean covered#12, $z0;
        java.lang.Object $r1;

        data := @parameter0: weka.core.Instances;

        rules := @parameter1: java.util.ArrayList;

        index := @parameter2: int;

        $r0 = new weka.core.Instances;

        specialinvoke $r0.<weka.core.Instances: void <init>(weka.core.Instances,int)>(data, 0);

        rt = $r0;

        i#4 = 0;

     label1:
        $i0 = virtualinvoke data.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#4);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if i#4 >= $i0 goto label6;

        datum = virtualinvoke data.<weka.core.Instances: weka.core.Instance instance(int)>(i#4);

        covered#12 = 0;

        j#16 = index + 1;

     label2:
        $i1 = virtualinvoke rules.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#16);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i1);

        if j#16 >= $i1 goto label4;

        $r1 = virtualinvoke rules.<java.util.ArrayList: java.lang.Object get(int)>(j#16);

        rule = (weka.classifiers.rules.Rule) $r1;

        $z0 = virtualinvoke rule.<weka.classifiers.rules.Rule: boolean covers(weka.core.Instance)>(datum);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label3;

        covered#12 = 1;

        goto label4;

     label3:
        j#16 = j#16 + 1;

        goto label2;

     label4:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(covered#12);

        if covered#12 != 0 goto label5;

        virtualinvoke rt.<weka.core.Instances: boolean add(weka.core.Instance)>(datum);

     label5:
        i#4 = i#4 + 1;

        goto label1;

     label6:
        return rt;
    }

    public static final weka.core.Instances[] partition(weka.core.Instances, int)
    {
        weka.core.Instances data, $r0, $r1;
        int numFolds, splits, $i0, $i1, $i2, $i3, $i4;
        weka.core.Instances[] rt;

        data := @parameter0: weka.core.Instances;

        numFolds := @parameter1: int;

        rt = newarray (weka.core.Instances)[2];

        $i0 = virtualinvoke data.<weka.core.Instances: int numInstances()>();

        $i1 = numFolds - 1;

        $i2 = $i0 * $i1;

        splits = $i2 / numFolds;

        $r0 = new weka.core.Instances;

        specialinvoke $r0.<weka.core.Instances: void <init>(weka.core.Instances,int,int)>(data, 0, splits);

        rt[0] = $r0;

        $r1 = new weka.core.Instances;

        $i3 = virtualinvoke data.<weka.core.Instances: int numInstances()>();

        $i4 = $i3 - splits;

        specialinvoke $r1.<weka.core.Instances: void <init>(weka.core.Instances,int,int)>(data, splits, $i4);

        rt[1] = $r1;

        return rt;
    }

    public static final weka.core.Instances stratify(weka.core.Instances, int, java.util.Random)
    {
        weka.core.Instances data, result, bagsByClasse, $r1, $r2, $r3, $r4, $r5, $r6;
        int folds, l6, $i0, i#13, $i1, j#22, $i2, $i3, l7#40, k#49, offset#53, bag#55, $i4, $i5, $i6;
        java.util.Random rand;
        weka.core.Instances[] bagsByClasses, l5;
        weka.core.Instance datum, $r7;
        weka.core.Attribute $r0;
        boolean $z0;
        double $d0;

        data := @parameter0: weka.core.Instances;

        folds := @parameter1: int;

        rand := @parameter2: java.util.Random;

        $r0 = virtualinvoke data.<weka.core.Instances: weka.core.Attribute classAttribute()>();

        $z0 = virtualinvoke $r0.<weka.core.Attribute: boolean isNominal()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 != 0 goto label01;

        return data;

     label01:
        $r1 = new weka.core.Instances;

        specialinvoke $r1.<weka.core.Instances: void <init>(weka.core.Instances,int)>(data, 0);

        result = $r1;

        $i0 = virtualinvoke data.<weka.core.Instances: int numClasses()>();

        bagsByClasses = newarray (weka.core.Instances)[$i0];

        i#13 = 0;

     label02:
        $i1 = lengthof bagsByClasses;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#13);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i1);

        if i#13 >= $i1 goto label03;

        $r2 = new weka.core.Instances;

        specialinvoke $r2.<weka.core.Instances: void <init>(weka.core.Instances,int)>(data, 0);

        bagsByClasses[i#13] = $r2;

        i#13 = i#13 + 1;

        goto label02;

     label03:
        j#22 = 0;

     label04:
        $i2 = virtualinvoke data.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#22);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i2);

        if j#22 >= $i2 goto label05;

        datum = virtualinvoke data.<weka.core.Instances: weka.core.Instance instance(int)>(j#22);

        $d0 = interfaceinvoke datum.<weka.core.Instance: double classValue()>();

        $i3 = (int) $d0;

        $r3 = bagsByClasses[$i3];

        virtualinvoke $r3.<weka.core.Instances: boolean add(weka.core.Instance)>(datum);

        j#22 = j#22 + 1;

        goto label04;

     label05:
        l5 = bagsByClasses;

        l6 = lengthof l5;

        l7#40 = 0;

     label06:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(l7#40);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(l6);

        if l7#40 >= l6 goto label07;

        bagsByClasse = l5[l7#40];

        virtualinvoke bagsByClasse.<weka.core.Instances: void randomize(java.util.Random)>(rand);

        l7#40 = l7#40 + 1;

        goto label06;

     label07:
        k#49 = 0;

     label08:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#49);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(folds);

        if k#49 >= folds goto label12;

        offset#53 = k#49;

        bag#55 = 0;

     label09:
        $r4 = bagsByClasses[bag#55];

        $i4 = virtualinvoke $r4.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(offset#53);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i4);

        if offset#53 < $i4 goto label10;

        $r5 = bagsByClasses[bag#55];

        $i5 = virtualinvoke $r5.<weka.core.Instances: int numInstances()>();

        offset#53 = offset#53 - $i5;

        bag#55 = bag#55 + 1;

        $i6 = lengthof bagsByClasses;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(bag#55);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i6);

        if bag#55 < $i6 goto label09;

        goto label11;

     label10:
        $r6 = bagsByClasses[bag#55];

        $r7 = virtualinvoke $r6.<weka.core.Instances: weka.core.Instance instance(int)>(offset#53);

        virtualinvoke result.<weka.core.Instances: boolean add(weka.core.Instance)>($r7);

        offset#53 = offset#53 + folds;

        goto label09;

     label11:
        k#49 = k#49 + 1;

        goto label08;

     label12:
        return result;
    }

    public void countData(int, weka.core.Instances, double[][])
    {
        weka.classifiers.rules.RuleStats this;
        int index, size, i#23, $i0, j#46;
        weka.core.Instances uncovered, $r10;
        double[][] prevRuleStats;
        double[] stats, $r6;
        weka.core.Instances[] filtered, data#18, $r9;
        java.util.ArrayList $r0, $r1, $r2, $r3, $r4, $r5, $r7, $r8, $r11, $r12;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        uncovered := @parameter1: weka.core.Instances;

        prevRuleStats := @parameter2: double[][];

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r0);

        if $r0 != null goto label1;

        $r1 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r1);

        if $r1 != null goto label2;

     label1:
        return;

     label2:
        $r2 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        size = virtualinvoke $r2.<java.util.ArrayList: int size()>();

        $r3 = new java.util.ArrayList;

        specialinvoke $r3.<java.util.ArrayList: void <init>(int)>(size);

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered> = $r3;

        $r4 = new java.util.ArrayList;

        specialinvoke $r4.<java.util.ArrayList: void <init>(int)>(size);

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats> = $r4;

        data#18 = newarray (weka.core.Instances)[2];

        data#18[1] = uncovered;

        i#23 = 0;

     label3:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#23);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        if i#23 >= index goto label6;

        $r5 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r6 = prevRuleStats[i#23];

        virtualinvoke $r5.<java.util.ArrayList: boolean add(java.lang.Object)>($r6);

        $i0 = i#23 + 1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        if $i0 != index goto label4;

        $r7 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        virtualinvoke $r7.<java.util.ArrayList: boolean add(java.lang.Object)>(data#18);

        goto label5;

     label4:
        $r8 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        $r9 = newarray (weka.core.Instances)[0];

        virtualinvoke $r8.<java.util.ArrayList: boolean add(java.lang.Object)>($r9);

     label5:
        i#23 = i#23 + 1;

        goto label3;

     label6:
        j#46 = index;

     label7:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#46);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(size);

        if j#46 >= size goto label8;

        stats = newarray (double)[6];

        $r10 = data#18[1];

        filtered = specialinvoke this.<weka.classifiers.rules.RuleStats: weka.core.Instances[] computeSimpleStats(int,weka.core.Instances,double[],double[])>(j#46, $r10, stats, null);

        $r11 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        virtualinvoke $r11.<java.util.ArrayList: boolean add(java.lang.Object)>(filtered);

        $r12 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        virtualinvoke $r12.<java.util.ArrayList: boolean add(java.lang.Object)>(stats);

        data#18 = filtered;

        j#46 = j#46 + 1;

        goto label7;

     label8:
        return;
    }

    public double relativeDL(int, double, boolean)
    {
        weka.classifiers.rules.RuleStats this;
        int index;
        double expFPRate, $d0, $d1, $d2, $d3, $d4;
        boolean checkErr;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        expFPRate := @parameter1: double;

        checkErr := @parameter2: boolean;

        $d0 = virtualinvoke this.<weka.classifiers.rules.RuleStats: double minDataDLIfExists(int,double,boolean)>(index, expFPRate, checkErr);

        $d1 = virtualinvoke this.<weka.classifiers.rules.RuleStats: double theoryDL(int)>(index);

        $d2 = $d0 + $d1;

        $d3 = virtualinvoke this.<weka.classifiers.rules.RuleStats: double minDataDLIfDeleted(int,double,boolean)>(index, expFPRate, checkErr);

        $d4 = $d2 - $d3;

        return $d4;
    }

    public double minDataDLIfExists(int, double, boolean)
    {
        weka.classifiers.rules.RuleStats this;
        int index, j#4, $i0, $i4, $i5, k#86, $i6;
        double expFPRate, ifDeleted, dataDLWith, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7, $d8, $d9, $d10, $d11, potential#82, $d12, $d13, $d14, $d15, $d16;
        boolean checkErr, $z0;
        double[] rulesetStat, ruleStat, $r4, $r8, $r12, $r16, $r19, $r22;
        java.util.ArrayList $r0, $r2, $r6, $r10, $r13, $r14, $r17, $r20, $r23;
        java.lang.Object $r3, $r7, $r11, $r15, $r18, $r21;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        expFPRate := @parameter1: double;

        checkErr := @parameter2: boolean;

        rulesetStat = newarray (double)[6];

        j#4 = 0;

     label1:
        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i0 = virtualinvoke $r0.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#4);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if j#4 >= $i0 goto label3;

        $d0 = rulesetStat[0];

        $r2 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r3 = virtualinvoke $r2.<java.util.ArrayList: java.lang.Object get(int)>(j#4);

        $r4 = (double[]) $r3;

        $d1 = $r4[0];

        $d2 = $d0 + $d1;

        rulesetStat[0] = $d2;

        $d3 = rulesetStat[2];

        $r6 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r7 = virtualinvoke $r6.<java.util.ArrayList: java.lang.Object get(int)>(j#4);

        $r8 = (double[]) $r7;

        $d4 = $r8[2];

        $d5 = $d3 + $d4;

        rulesetStat[2] = $d5;

        $d6 = rulesetStat[4];

        $r10 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r11 = virtualinvoke $r10.<java.util.ArrayList: java.lang.Object get(int)>(j#4);

        $r12 = (double[]) $r11;

        $d7 = $r12[4];

        $d8 = $d6 + $d7;

        rulesetStat[4] = $d8;

        $r13 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i4 = virtualinvoke $r13.<java.util.ArrayList: int size()>();

        $i5 = $i4 - 1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#4);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i5);

        if j#4 != $i5 goto label2;

        $r14 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r15 = virtualinvoke $r14.<java.util.ArrayList: java.lang.Object get(int)>(j#4);

        $r16 = (double[]) $r15;

        $d9 = $r16[1];

        rulesetStat[1] = $d9;

        $r17 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r18 = virtualinvoke $r17.<java.util.ArrayList: java.lang.Object get(int)>(j#4);

        $r19 = (double[]) $r18;

        $d10 = $r19[3];

        rulesetStat[3] = $d10;

        $r20 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r21 = virtualinvoke $r20.<java.util.ArrayList: java.lang.Object get(int)>(j#4);

        $r22 = (double[]) $r21;

        $d11 = $r22[5];

        rulesetStat[5] = $d11;

     label2:
        j#4 = j#4 + 1;

        goto label1;

     label3:
        potential#82 = 0.0;

        k#86 = index + 1;

     label4:
        $r23 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i6 = virtualinvoke $r23.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#86);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i6);

        if k#86 >= $i6 goto label6;

        ruleStat = virtualinvoke this.<weka.classifiers.rules.RuleStats: double[] getSimpleStats(int)>(k#86);

        ifDeleted = virtualinvoke this.<weka.classifiers.rules.RuleStats: double potential(int,double,double[],double[],boolean)>(k#86, expFPRate, rulesetStat, ruleStat, checkErr);

        $z0 = staticinvoke <java.lang.Double: boolean isNaN(double)>(ifDeleted);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 != 0 goto label5;

        potential#82 = potential#82 + ifDeleted;

     label5:
        k#86 = k#86 + 1;

        goto label4;

     label6:
        $d12 = rulesetStat[0];

        $d13 = rulesetStat[1];

        $d14 = rulesetStat[4];

        $d15 = rulesetStat[5];

        dataDLWith = staticinvoke <weka.classifiers.rules.RuleStats: double dataDL(double,double,double,double,double)>(expFPRate, $d12, $d13, $d14, $d15);

        $d16 = dataDLWith - potential#82;

        return $d16;
    }

    public double theoryDL(int)
    {
        weka.classifiers.rules.RuleStats this;
        int index;
        double k, tdl#12, $d0, $d1, $d2, $d3, $d4, $d5, tdl#32, $d6, $d7, $d8, $d9;
        java.util.ArrayList $r0;
        java.lang.Object $r1;
        weka.classifiers.rules.Rule $r2;
        byte $b0, $b1;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $r1 = virtualinvoke $r0.<java.util.ArrayList: java.lang.Object get(int)>(index);

        $r2 = (weka.classifiers.rules.Rule) $r1;

        k = virtualinvoke $r2.<weka.classifiers.rules.Rule: double size()>();

        $b0 = k cmpl 0.0;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b0);

        if $b0 != 0 goto label1;

        return 0.0;

     label1:
        tdl#12 = staticinvoke <weka.core.Utils: double log2(double)>(k);

        $b1 = k cmpl 1.0;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b1);

        if $b1 <= 0 goto label2;

        $d0 = staticinvoke <weka.core.Utils: double log2(double)>(tdl#12);

        $d1 = 2.0 * $d0;

        tdl#12 = tdl#12 + $d1;

     label2:
        $d2 = this.<weka.classifiers.rules.RuleStats: double m_Total>;

        $d3 = this.<weka.classifiers.rules.RuleStats: double m_Total>;

        $d4 = k / $d3;

        $d5 = staticinvoke <weka.classifiers.rules.RuleStats: double subsetDL(double,double,double)>($d2, k, $d4);

        tdl#32 = tdl#12 + $d5;

        $d6 = this.<weka.classifiers.rules.RuleStats: double MDL_THEORY_WEIGHT>;

        $d7 = <weka.classifiers.rules.RuleStats: double REDUNDANCY_FACTOR>;

        $d8 = $d6 * $d7;

        $d9 = $d8 * tdl#32;

        return $d9;
    }

    public double minDataDLIfDeleted(int, double, boolean)
    {
        weka.classifiers.rules.RuleStats this;
        int index, more, $i0, $i1, j#14, $i5, j#71, $i6, $i10, $i11, $i12, $i13, $i14, $i15, $i16, $i17, $i18, k#241, $i19, $i20, $i21;
        double expFPRate, ifDeleted, dataDLWithout, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7, $d8, $d9, $d10, $d11, $d12, $d13, $d14, $d15, $d16, $d17, $d18, $d19, $d20, $d21, $d22, $d23, $d24, $d25, $d26, $d27, $d28, $d29, $d30, $d31, $d32, potential#237, $d33, $d34, $d35, $d36, $d37;
        boolean checkErr, $z1;
        double[] rulesetStat, stats, ruleStat, $r5, $r9, $r13, $r23, $r25, $r27, $r30, $r33, $r36, $r39, $r42, $r45, $r48, $r51, $r54;
        java.util.ArrayList indexPlus, $r0, $r1, $r3, $r7, $r11, $r15, $r18, $r28, $r31, $r34, $r37, $r40, $r43, $r46, $r49, $r52, $r55;
        weka.core.Instances[] split, $r17;
        java.lang.Object $r4, $r8, $r12, $r16, $r22, $r24, $r26, $r29, $r32, $r35, $r38, $r41, $r44, $r47, $r50, $r53, $r56;
        weka.core.Instances $r14, data#67;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        expFPRate := @parameter1: double;

        checkErr := @parameter2: boolean;

        rulesetStat = newarray (double)[6];

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $i0 = virtualinvoke $r0.<java.util.ArrayList: int size()>();

        $i1 = $i0 - 1;

        more = $i1 - index;

        $r1 = new java.util.ArrayList;

        specialinvoke $r1.<java.util.ArrayList: void <init>(int)>(more);

        indexPlus = $r1;

        j#14 = 0;

     label01:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#14);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        if j#14 >= index goto label02;

        $d0 = rulesetStat[0];

        $r3 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r4 = virtualinvoke $r3.<java.util.ArrayList: java.lang.Object get(int)>(j#14);

        $r5 = (double[]) $r4;

        $d1 = $r5[0];

        $d2 = $d0 + $d1;

        rulesetStat[0] = $d2;

        $d3 = rulesetStat[2];

        $r7 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r8 = virtualinvoke $r7.<java.util.ArrayList: java.lang.Object get(int)>(j#14);

        $r9 = (double[]) $r8;

        $d4 = $r9[2];

        $d5 = $d3 + $d4;

        rulesetStat[2] = $d5;

        $d6 = rulesetStat[4];

        $r11 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r12 = virtualinvoke $r11.<java.util.ArrayList: java.lang.Object get(int)>(j#14);

        $r13 = (double[]) $r12;

        $d7 = $r13[4];

        $d8 = $d6 + $d7;

        rulesetStat[4] = $d8;

        j#14 = j#14 + 1;

        goto label01;

     label02:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        if index != 0 goto label03;

        $r14 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        goto label04;

     label03:
        $r15 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        $i5 = index - 1;

        $r16 = virtualinvoke $r15.<java.util.ArrayList: java.lang.Object get(int)>($i5);

        $r17 = (weka.core.Instances[]) $r16;

        $r14 = $r17[1];

     label04:
        data#67 = $r14;

        j#71 = index + 1;

     label05:
        $r18 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $i6 = virtualinvoke $r18.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#71);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i6);

        if j#71 >= $i6 goto label06;

        stats = newarray (double)[6];

        split = specialinvoke this.<weka.classifiers.rules.RuleStats: weka.core.Instances[] computeSimpleStats(int,weka.core.Instances,double[],double[])>(j#71, data#67, stats, null);

        virtualinvoke indexPlus.<java.util.ArrayList: boolean add(java.lang.Object)>(stats);

        $d9 = rulesetStat[0];

        $d10 = stats[0];

        $d11 = $d9 + $d10;

        rulesetStat[0] = $d11;

        $d12 = rulesetStat[2];

        $d13 = stats[2];

        $d14 = $d12 + $d13;

        rulesetStat[2] = $d14;

        $d15 = rulesetStat[4];

        $d16 = stats[4];

        $d17 = $d15 + $d16;

        rulesetStat[4] = $d17;

        data#67 = split[1];

        j#71 = j#71 + 1;

        goto label05;

     label06:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(more);

        if more <= 0 goto label07;

        $i10 = virtualinvoke indexPlus.<java.util.ArrayList: int size()>();

        $i11 = $i10 - 1;

        $r22 = virtualinvoke indexPlus.<java.util.ArrayList: java.lang.Object get(int)>($i11);

        $r23 = (double[]) $r22;

        $d18 = $r23[1];

        rulesetStat[1] = $d18;

        $i12 = virtualinvoke indexPlus.<java.util.ArrayList: int size()>();

        $i13 = $i12 - 1;

        $r24 = virtualinvoke indexPlus.<java.util.ArrayList: java.lang.Object get(int)>($i13);

        $r25 = (double[]) $r24;

        $d19 = $r25[3];

        rulesetStat[3] = $d19;

        $i14 = virtualinvoke indexPlus.<java.util.ArrayList: int size()>();

        $i15 = $i14 - 1;

        $r26 = virtualinvoke indexPlus.<java.util.ArrayList: java.lang.Object get(int)>($i15);

        $r27 = (double[]) $r26;

        $d20 = $r27[5];

        rulesetStat[5] = $d20;

        goto label09;

     label07:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        if index <= 0 goto label08;

        $r28 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i16 = index - 1;

        $r29 = virtualinvoke $r28.<java.util.ArrayList: java.lang.Object get(int)>($i16);

        $r30 = (double[]) $r29;

        $d21 = $r30[1];

        rulesetStat[1] = $d21;

        $r31 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i17 = index - 1;

        $r32 = virtualinvoke $r31.<java.util.ArrayList: java.lang.Object get(int)>($i17);

        $r33 = (double[]) $r32;

        $d22 = $r33[3];

        rulesetStat[3] = $d22;

        $r34 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i18 = index - 1;

        $r35 = virtualinvoke $r34.<java.util.ArrayList: java.lang.Object get(int)>($i18);

        $r36 = (double[]) $r35;

        $d23 = $r36[5];

        rulesetStat[5] = $d23;

        goto label09;

     label08:
        $r37 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r38 = virtualinvoke $r37.<java.util.ArrayList: java.lang.Object get(int)>(0);

        $r39 = (double[]) $r38;

        $d24 = $r39[0];

        $r40 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r41 = virtualinvoke $r40.<java.util.ArrayList: java.lang.Object get(int)>(0);

        $r42 = (double[]) $r41;

        $d25 = $r42[1];

        $d26 = $d24 + $d25;

        rulesetStat[1] = $d26;

        $r43 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r44 = virtualinvoke $r43.<java.util.ArrayList: java.lang.Object get(int)>(0);

        $r45 = (double[]) $r44;

        $d27 = $r45[3];

        $r46 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r47 = virtualinvoke $r46.<java.util.ArrayList: java.lang.Object get(int)>(0);

        $r48 = (double[]) $r47;

        $d28 = $r48[4];

        $d29 = $d27 + $d28;

        rulesetStat[3] = $d29;

        $r49 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r50 = virtualinvoke $r49.<java.util.ArrayList: java.lang.Object get(int)>(0);

        $r51 = (double[]) $r50;

        $d30 = $r51[2];

        $r52 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r53 = virtualinvoke $r52.<java.util.ArrayList: java.lang.Object get(int)>(0);

        $r54 = (double[]) $r53;

        $d31 = $r54[5];

        $d32 = $d30 + $d31;

        rulesetStat[5] = $d32;

     label09:
        potential#237 = 0.0;

        k#241 = index + 1;

     label10:
        $r55 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $i19 = virtualinvoke $r55.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#241);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i19);

        if k#241 >= $i19 goto label12;

        $i20 = k#241 - index;

        $i21 = $i20 - 1;

        $r56 = virtualinvoke indexPlus.<java.util.ArrayList: java.lang.Object get(int)>($i21);

        ruleStat = (double[]) $r56;

        ifDeleted = virtualinvoke this.<weka.classifiers.rules.RuleStats: double potential(int,double,double[],double[],boolean)>(k#241, expFPRate, rulesetStat, ruleStat, checkErr);

        $z1 = staticinvoke <java.lang.Double: boolean isNaN(double)>(ifDeleted);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z1);

        if $z1 != 0 goto label11;

        potential#237 = potential#237 + ifDeleted;

     label11:
        k#241 = k#241 + 1;

        goto label10;

     label12:
        $d33 = rulesetStat[0];

        $d34 = rulesetStat[1];

        $d35 = rulesetStat[4];

        $d36 = rulesetStat[5];

        dataDLWithout = staticinvoke <weka.classifiers.rules.RuleStats: double dataDL(double,double,double,double,double)>(expFPRate, $d33, $d34, $d35, $d36);

        $d37 = dataDLWithout - potential#237;

        return $d37;
    }

    public double potential(int, double, double[], double[], boolean)
    {
        weka.classifiers.rules.RuleStats this;
        int index;
        double expFPOverErr, pcov, puncov, pfp, pfn, dataDLWith, theoryDLWith, dataDLWithout, potential, err, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7, $d8, $d9, $d10, $d11, $d12, $d13, $d14;
        double[] rulesetStat, ruleStat;
        boolean checkErr, overErr#64, $z0;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        expFPOverErr := @parameter1: double;

        rulesetStat := @parameter2: double[];

        ruleStat := @parameter3: double[];

        checkErr := @parameter4: boolean;

        $d0 = rulesetStat[0];

        $d1 = ruleStat[0];

        pcov = $d0 - $d1;

        $d2 = rulesetStat[1];

        $d3 = ruleStat[0];

        puncov = $d2 + $d3;

        $d4 = rulesetStat[4];

        $d5 = ruleStat[4];

        pfp = $d4 - $d5;

        $d6 = rulesetStat[5];

        $d7 = ruleStat[2];

        pfn = $d6 + $d7;

        $d8 = rulesetStat[0];

        $d9 = rulesetStat[1];

        $d10 = rulesetStat[4];

        $d11 = rulesetStat[5];

        dataDLWith = staticinvoke <weka.classifiers.rules.RuleStats: double dataDL(double,double,double,double,double)>(expFPOverErr, $d8, $d9, $d10, $d11);

        theoryDLWith = virtualinvoke this.<weka.classifiers.rules.RuleStats: double theoryDL(int)>(index);

        dataDLWithout = staticinvoke <weka.classifiers.rules.RuleStats: double dataDL(double,double,double,double,double)>(expFPOverErr, pcov, puncov, pfp, pfn);

        $d12 = dataDLWith + theoryDLWith;

        potential = $d12 - dataDLWithout;

        $d13 = ruleStat[4];

        $d14 = ruleStat[0];

        err = $d13 / $d14;

        overErr#64 = staticinvoke <weka.core.Utils: boolean grOrEq(double,double)>(err, 0.5);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(checkErr);

        if checkErr != 0 goto label1;

        overErr#64 = 0;

     label1:
        $z0 = staticinvoke <weka.core.Utils: boolean grOrEq(double,double)>(potential, 0.0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 != 0 goto label2;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(overErr#64);

        if overErr#64 == 0 goto label3;

     label2:
        rulesetStat[0] = pcov;

        rulesetStat[1] = puncov;

        rulesetStat[4] = pfp;

        rulesetStat[5] = pfn;

        return potential;

     label3:
        return #NaN;
    }

    public double[] getSimpleStats(int)
    {
        weka.classifiers.rules.RuleStats this;
        int index, $i0;
        java.util.ArrayList $r0, $r1, $r2;
        java.lang.Object $r3;
        double[] $r4;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r0);

        if $r0 == null goto label1;

        $r1 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i0 = virtualinvoke $r1.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if index >= $i0 goto label1;

        $r2 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r3 = virtualinvoke $r2.<java.util.ArrayList: java.lang.Object get(int)>(index);

        $r4 = (double[]) $r3;

        return $r4;

     label1:
        return null;
    }

    public void <init>(weka.core.Instances, java.util.ArrayList)
    {
        weka.classifiers.rules.RuleStats this;
        weka.core.Instances data;
        java.util.ArrayList rules;

        this := @this: weka.classifiers.rules.RuleStats;

        data := @parameter0: weka.core.Instances;

        rules := @parameter1: java.util.ArrayList;

        specialinvoke this.<weka.classifiers.rules.RuleStats: void <init>()>();

        this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data> = data;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset> = rules;

        return;
    }

    public void removeLast()
    {
        weka.classifiers.rules.RuleStats this;
        int last, $i0;
        java.util.ArrayList $r0, $r1, $r3, $r5, $r7, $r8;

        this := @this: weka.classifiers.rules.RuleStats;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $i0 = virtualinvoke $r0.<java.util.ArrayList: int size()>();

        last = $i0 - 1;

        $r1 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        virtualinvoke $r1.<java.util.ArrayList: java.lang.Object remove(int)>(last);

        $r3 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        virtualinvoke $r3.<java.util.ArrayList: java.lang.Object remove(int)>(last);

        $r5 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        virtualinvoke $r5.<java.util.ArrayList: java.lang.Object remove(int)>(last);

        $r7 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r7);

        if $r7 == null goto label1;

        $r8 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions>;

        virtualinvoke $r8.<java.util.ArrayList: java.lang.Object remove(int)>(last);

     label1:
        return;
    }

    public int getRulesetSize()
    {
        weka.classifiers.rules.RuleStats this;
        java.util.ArrayList $r0;
        int $i0;

        this := @this: weka.classifiers.rules.RuleStats;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        $i0 = virtualinvoke $r0.<java.util.ArrayList: int size()>();

        return $i0;
    }

    public weka.core.Instances[] getFiltered(int)
    {
        weka.classifiers.rules.RuleStats this;
        int index, $i0;
        java.util.ArrayList $r0, $r1, $r2;
        java.lang.Object $r3;
        weka.core.Instances[] $r4;

        this := @this: weka.classifiers.rules.RuleStats;

        index := @parameter0: int;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r0);

        if $r0 == null goto label1;

        $r1 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        $i0 = virtualinvoke $r1.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(index);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if index >= $i0 goto label1;

        $r2 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        $r3 = virtualinvoke $r2.<java.util.ArrayList: java.lang.Object get(int)>(index);

        $r4 = (weka.core.Instances[]) $r3;

        return $r4;

     label1:
        return null;
    }

    public void reduceDL(double, boolean)
    {
        weka.classifiers.rules.RuleStats this;
        double expFPRate, ifDeleted, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7, $d8, $d9, $d10, $d11;
        boolean checkErr, needUpdate#2, $z0;
        double[] rulesetStat, ruleStat, $r4, $r8, $r12, $r16, $r19, $r22;
        int j#6, $i0, $i4, $i5, $i6, k#88, $i7, $i8;
        java.util.ArrayList $r0, $r2, $r6, $r10, $r13, $r14, $r17, $r20, $r23, $r24, $r26, $r27;
        java.lang.Object $r3, $r7, $r11, $r15, $r18, $r21, $r25;

        this := @this: weka.classifiers.rules.RuleStats;

        expFPRate := @parameter0: double;

        checkErr := @parameter1: boolean;

        needUpdate#2 = 0;

        rulesetStat = newarray (double)[6];

        j#6 = 0;

     label1:
        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i0 = virtualinvoke $r0.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#6);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if j#6 >= $i0 goto label3;

        $d0 = rulesetStat[0];

        $r2 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r3 = virtualinvoke $r2.<java.util.ArrayList: java.lang.Object get(int)>(j#6);

        $r4 = (double[]) $r3;

        $d1 = $r4[0];

        $d2 = $d0 + $d1;

        rulesetStat[0] = $d2;

        $d3 = rulesetStat[2];

        $r6 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r7 = virtualinvoke $r6.<java.util.ArrayList: java.lang.Object get(int)>(j#6);

        $r8 = (double[]) $r7;

        $d4 = $r8[2];

        $d5 = $d3 + $d4;

        rulesetStat[2] = $d5;

        $d6 = rulesetStat[4];

        $r10 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r11 = virtualinvoke $r10.<java.util.ArrayList: java.lang.Object get(int)>(j#6);

        $r12 = (double[]) $r11;

        $d7 = $r12[4];

        $d8 = $d6 + $d7;

        rulesetStat[4] = $d8;

        $r13 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i4 = virtualinvoke $r13.<java.util.ArrayList: int size()>();

        $i5 = $i4 - 1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#6);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i5);

        if j#6 != $i5 goto label2;

        $r14 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r15 = virtualinvoke $r14.<java.util.ArrayList: java.lang.Object get(int)>(j#6);

        $r16 = (double[]) $r15;

        $d9 = $r16[1];

        rulesetStat[1] = $d9;

        $r17 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r18 = virtualinvoke $r17.<java.util.ArrayList: java.lang.Object get(int)>(j#6);

        $r19 = (double[]) $r18;

        $d10 = $r19[3];

        rulesetStat[3] = $d10;

        $r20 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r21 = virtualinvoke $r20.<java.util.ArrayList: java.lang.Object get(int)>(j#6);

        $r22 = (double[]) $r21;

        $d11 = $r22[5];

        rulesetStat[5] = $d11;

     label2:
        j#6 = j#6 + 1;

        goto label1;

     label3:
        $r23 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i6 = virtualinvoke $r23.<java.util.ArrayList: int size()>();

        k#88 = $i6 - 1;

     label4:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#88);

        if k#88 < 0 goto label7;

        $r24 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $r25 = virtualinvoke $r24.<java.util.ArrayList: java.lang.Object get(int)>(k#88);

        ruleStat = (double[]) $r25;

        ifDeleted = virtualinvoke this.<weka.classifiers.rules.RuleStats: double potential(int,double,double[],double[],boolean)>(k#88, expFPRate, rulesetStat, ruleStat, checkErr);

        $z0 = staticinvoke <java.lang.Double: boolean isNaN(double)>(ifDeleted);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 != 0 goto label6;

        $r26 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        $i7 = virtualinvoke $r26.<java.util.ArrayList: int size()>();

        $i8 = $i7 - 1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#88);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i8);

        if k#88 != $i8 goto label5;

        virtualinvoke this.<weka.classifiers.rules.RuleStats: void removeLast()>();

        goto label6;

     label5:
        $r27 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        virtualinvoke $r27.<java.util.ArrayList: java.lang.Object remove(int)>(k#88);

        needUpdate#2 = 1;

     label6:
        k#88 = k#88 + -1;

        goto label4;

     label7:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(needUpdate#2);

        if needUpdate#2 == 0 goto label8;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered> = null;

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats> = null;

        virtualinvoke this.<weka.classifiers.rules.RuleStats: void countData()>();

     label8:
        return;
    }

    public java.util.ArrayList getRuleset()
    {
        weka.classifiers.rules.RuleStats this;
        java.util.ArrayList $r0;

        this := @this: weka.classifiers.rules.RuleStats;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        return $r0;
    }

    public void countData()
    {
        weka.classifiers.rules.RuleStats this;
        int size, i#28, $i0;
        double[] stats, classCounts;
        weka.core.Instances[] filtered;
        java.util.ArrayList $r0, $r1, $r3, $r4, $r5, $r6, $r11, $r12, $r13;
        weka.core.Instances $r2, $r7, $r8, data#26, $r9;
        weka.core.Attribute $r10;

        this := @this: weka.classifiers.rules.RuleStats;

        $r0 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r0);

        if $r0 != null goto label1;

        $r1 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r1);

        if $r1 == null goto label1;

        $r2 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r2);

        if $r2 != null goto label2;

     label1:
        return;

     label2:
        $r3 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Ruleset>;

        size = virtualinvoke $r3.<java.util.ArrayList: int size()>();

        $r4 = new java.util.ArrayList;

        specialinvoke $r4.<java.util.ArrayList: void <init>(int)>(size);

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered> = $r4;

        $r5 = new java.util.ArrayList;

        specialinvoke $r5.<java.util.ArrayList: void <init>(int)>(size);

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats> = $r5;

        $r6 = new java.util.ArrayList;

        specialinvoke $r6.<java.util.ArrayList: void <init>(int)>(size);

        this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions> = $r6;

        $r7 = new weka.core.Instances;

        $r8 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        specialinvoke $r7.<weka.core.Instances: void <init>(weka.core.Instances)>($r8);

        data#26 = $r7;

        i#28 = 0;

     label3:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#28);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(size);

        if i#28 >= size goto label4;

        stats = newarray (double)[6];

        $r9 = this.<weka.classifiers.rules.RuleStats: weka.core.Instances m_Data>;

        $r10 = virtualinvoke $r9.<weka.core.Instances: weka.core.Attribute classAttribute()>();

        $i0 = virtualinvoke $r10.<weka.core.Attribute: int numValues()>();

        classCounts = newarray (double)[$i0];

        filtered = specialinvoke this.<weka.classifiers.rules.RuleStats: weka.core.Instances[] computeSimpleStats(int,weka.core.Instances,double[],double[])>(i#28, data#26, stats, classCounts);

        $r11 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Filtered>;

        virtualinvoke $r11.<java.util.ArrayList: boolean add(java.lang.Object)>(filtered);

        $r12 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_SimpleStats>;

        virtualinvoke $r12.<java.util.ArrayList: boolean add(java.lang.Object)>(stats);

        $r13 = this.<weka.classifiers.rules.RuleStats: java.util.ArrayList m_Distributions>;

        virtualinvoke $r13.<java.util.ArrayList: boolean add(java.lang.Object)>(classCounts);

        data#26 = filtered[1];

        i#28 = i#28 + 1;

        goto label3;

     label4:
        return;
    }


