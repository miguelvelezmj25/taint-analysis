    static void <clinit>()
    {
        <weka.classifiers.rules.JRip: double MAX_DL_SURPLUS> = 64.0;

        return;
    }

    public void <init>()
    {
        weka.classifiers.rules.JRip this;

        this := @this: weka.classifiers.rules.JRip;

        specialinvoke this.<weka.classifiers.AbstractClassifier: void <init>()>();

        this.<weka.classifiers.rules.JRip: int m_Optimizations> = 2;

        this.<weka.classifiers.rules.JRip: java.util.Random m_Random> = null;

        this.<weka.classifiers.rules.JRip: double m_Total> = 0.0;

        this.<weka.classifiers.rules.JRip: long m_Seed> = 1L;

        this.<weka.classifiers.rules.JRip: int m_Folds> = 3;

        this.<weka.classifiers.rules.JRip: double m_MinNo> = 2.0;

        this.<weka.classifiers.rules.JRip: boolean m_Debug> = 0;

        this.<weka.classifiers.rules.JRip: boolean m_CheckErr> = 1;

        this.<weka.classifiers.rules.JRip: boolean m_UsePruning> = 1;

        this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter> = null;

        return;
    }

    public void setFolds(int)
    {
        weka.classifiers.rules.JRip this;
        int fold;

        this := @this: weka.classifiers.rules.JRip;

        fold := @parameter0: int;

        this.<weka.classifiers.rules.JRip: int m_Folds> = fold;

        return;
    }

    public void setOptimizations(int)
    {
        weka.classifiers.rules.JRip this;
        int run;

        this := @this: weka.classifiers.rules.JRip;

        run := @parameter0: int;

        this.<weka.classifiers.rules.JRip: int m_Optimizations> = run;

        return;
    }

    public void setSeed(long)
    {
        weka.classifiers.rules.JRip this;
        long s;

        this := @this: weka.classifiers.rules.JRip;

        s := @parameter0: long;

        this.<weka.classifiers.rules.JRip: long m_Seed> = s;

        return;
    }

    public void setMinNo(double)
    {
        weka.classifiers.rules.JRip this;
        double m;

        this := @this: weka.classifiers.rules.JRip;

        m := @parameter0: double;

        this.<weka.classifiers.rules.JRip: double m_MinNo> = m;

        return;
    }

    public void setDebug(boolean)
    {
        weka.classifiers.rules.JRip this;
        boolean d;

        this := @this: weka.classifiers.rules.JRip;

        d := @parameter0: boolean;

        this.<weka.classifiers.rules.JRip: boolean m_Debug> = d;

        return;
    }

    public void setCheckErrorRate(boolean)
    {
        weka.classifiers.rules.JRip this;
        boolean d;

        this := @this: weka.classifiers.rules.JRip;

        d := @parameter0: boolean;

        this.<weka.classifiers.rules.JRip: boolean m_CheckErr> = d;

        return;
    }

    public void setUsePruning(boolean)
    {
        weka.classifiers.rules.JRip this;
        boolean d;

        this := @this: weka.classifiers.rules.JRip;

        d := @parameter0: boolean;

        this.<weka.classifiers.rules.JRip: boolean m_UsePruning> = d;

        return;
    }

    public void buildClassifier(weka.core.Instances) throws java.lang.Exception
    {
        weka.classifiers.rules.JRip this;
        double[] orderedClasses, classDist, $r67;
        double classIndex, expFPRate, defDL, $d0, $d1, $d2, $d3, $d4, all#147, $d5, $d6, classYWeights#164, totalWeights#166, $d7, $d8, $d9, $d10, $d11;
        int ci, $i1, x#79, $i3, y#106, $i4, $i5, i#149, $i6, j#168, $i7, $i8, $i10, $i11, z#256, $i12, xyz#267, $i13, i#285, $i14;
        weka.core.Instance datum;
        java.util.Iterator l4;
        weka.classifiers.rules.Rule rule;
        weka.classifiers.rules.JRip$RipperRule defRule, $r56, $r57;
        weka.classifiers.rules.RuleStats defRuleStat, oneClass, $r59, $r71;
        weka.core.Instances instances#1, $r1, instances#8, data#53;
        weka.core.Capabilities $r0;
        long $l0, $l2;
        java.util.Random $r2, $r11;
        boolean $z0, $z1, $z2, $z3, $z4, $z5, $z6, $z7;
        java.io.PrintStream $r3, $r23, $r25, $r36, $r49;
        java.lang.StringBuilder $r4, $r5, $r6, $r26, $r27, $r28, $r31, $r32, $r33, $r34, $r37, $r38, $r41, $r42, $r43, $r44, $r45, $r46, $r50, $r51, $r52;
        java.lang.String $r7, $r30, $r35, $r40, $r47, $r53;
        weka.filters.supervised.attribute.ClassOrder $r8, $r10, $r13, $r22, $r66;
        weka.filters.Filter $r9, $r12, $r14, $r15, $r21, $r65;
        java.lang.Exception $r16, $r48;
        weka.core.Attribute $r17, $r24, $r29, $r39;
        java.util.ArrayList $r18, $r19, $r20, $r54, $r58, $r60, $r61, $r62, $r64, $r68, $r69;
        byte $b9;
        java.lang.Object $r55, $r63, $r70;

        this := @this: weka.classifiers.rules.JRip;

        instances#1 := @parameter0: weka.core.Instances;

        $r0 = virtualinvoke this.<weka.classifiers.rules.JRip: weka.core.Capabilities getCapabilities()>();

        virtualinvoke $r0.<weka.core.Capabilities: void testWithFail(weka.core.Instances)>(instances#1);

        $r1 = new weka.core.Instances;

        specialinvoke $r1.<weka.core.Instances: void <init>(weka.core.Instances)>(instances#1);

        instances#8 = $r1;

        virtualinvoke instances#8.<weka.core.Instances: void deleteWithMissingClass()>();

        $l0 = this.<weka.classifiers.rules.JRip: long m_Seed>;

        $r2 = virtualinvoke instances#8.<weka.core.Instances: java.util.Random getRandomNumberGenerator(long)>($l0);

        this.<weka.classifiers.rules.JRip: java.util.Random m_Random> = $r2;

        $d0 = staticinvoke <weka.classifiers.rules.RuleStats: double numAllConditions(weka.core.Instances)>(instances#8);

        this.<weka.classifiers.rules.JRip: double m_Total> = $d0;

        $z0 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label01;

        $r3 = <java.lang.System: java.io.PrintStream err>;

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Number of all possible conditions = ");

        $d1 = this.<weka.classifiers.rules.JRip: double m_Total>;

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d1);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r3.<java.io.PrintStream: void println(java.lang.String)>($r7);

     label01:
        $r8 = new weka.filters.supervised.attribute.ClassOrder;

        specialinvoke $r8.<weka.filters.supervised.attribute.ClassOrder: void <init>()>();

        this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter> = $r8;

        $r9 = this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter>;

        $r10 = (weka.filters.supervised.attribute.ClassOrder) $r9;

        $r11 = this.<weka.classifiers.rules.JRip: java.util.Random m_Random>;

        $i1 = virtualinvoke $r11.<java.util.Random: int nextInt()>();

        $l2 = (long) $i1;

        virtualinvoke $r10.<weka.filters.supervised.attribute.ClassOrder: void setSeed(long)>($l2);

        $r12 = this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter>;

        $r13 = (weka.filters.supervised.attribute.ClassOrder) $r12;

        virtualinvoke $r13.<weka.filters.supervised.attribute.ClassOrder: void setClassOrder(int)>(0);

        $r14 = this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter>;

        virtualinvoke $r14.<weka.filters.Filter: boolean setInputFormat(weka.core.Instances)>(instances#8);

        $r15 = this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter>;

        data#53 = staticinvoke <weka.filters.Filter: weka.core.Instances useFilter(weka.core.Instances,weka.filters.Filter)>(instances#8, $r15);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(data#53);

        if data#53 != null goto label02;

        $r16 = new java.lang.Exception;

        specialinvoke $r16.<java.lang.Exception: void <init>(java.lang.String)>(" Unable to randomize the class orders.");

        throw $r16;

     label02:
        $r17 = virtualinvoke data#53.<weka.core.Instances: weka.core.Attribute classAttribute()>();

        this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class> = $r17;

        $r18 = new java.util.ArrayList;

        specialinvoke $r18.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset> = $r18;

        $r19 = new java.util.ArrayList;

        specialinvoke $r19.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats> = $r19;

        $r20 = new java.util.ArrayList;

        specialinvoke $r20.<java.util.ArrayList: void <init>()>();

        this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Distributions> = $r20;

        $r21 = this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter>;

        $r22 = (weka.filters.supervised.attribute.ClassOrder) $r21;

        orderedClasses = virtualinvoke $r22.<weka.filters.supervised.attribute.ClassOrder: double[] getClassCounts()>();

        $z1 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z1);

        if $z1 == 0 goto label04;

        $r23 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r23.<java.io.PrintStream: void println(java.lang.String)>("Sorted classes:");

        x#79 = 0;

     label03:
        $r24 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $i3 = virtualinvoke $r24.<weka.core.Attribute: int numValues()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(x#79);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i3);

        if x#79 >= $i3 goto label04;

        $r25 = <java.lang.System: java.io.PrintStream err>;

        $r26 = new java.lang.StringBuilder;

        specialinvoke $r26.<java.lang.StringBuilder: void <init>()>();

        $r27 = virtualinvoke $r26.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(x#79);

        $r28 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(": ");

        $r29 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r30 = virtualinvoke $r29.<weka.core.Attribute: java.lang.String value(int)>(x#79);

        $r31 = virtualinvoke $r28.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r30);

        $r32 = virtualinvoke $r31.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" has ");

        $d2 = orderedClasses[x#79];

        $r33 = virtualinvoke $r32.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d2);

        $r34 = virtualinvoke $r33.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" instances.");

        $r35 = virtualinvoke $r34.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r25.<java.io.PrintStream: void println(java.lang.String)>($r35);

        x#79 = x#79 + 1;

        goto label03;

     label04:
        y#106 = 0;

     label05:
        $i4 = virtualinvoke data#53.<weka.core.Instances: int numClasses()>();

        $i5 = $i4 - 1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(y#106);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i5);

        if y#106 >= $i5 goto label17;

        classIndex = (double) y#106;

        $z2 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z2);

        if $z2 == 0 goto label06;

        ci = (int) classIndex;

        $r36 = <java.lang.System: java.io.PrintStream err>;

        $r37 = new java.lang.StringBuilder;

        specialinvoke $r37.<java.lang.StringBuilder: void <init>()>();

        $r38 = virtualinvoke $r37.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n\nClass ");

        $r39 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r40 = virtualinvoke $r39.<weka.core.Attribute: java.lang.String value(int)>(ci);

        $r41 = virtualinvoke $r38.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r40);

        $r42 = virtualinvoke $r41.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("(");

        $r43 = virtualinvoke $r42.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(ci);

        $r44 = virtualinvoke $r43.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("): ");

        $d3 = orderedClasses[y#106];

        $r45 = virtualinvoke $r44.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d3);

        $r46 = virtualinvoke $r45.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("instances\n=====================================\n");

        $r47 = virtualinvoke $r46.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r36.<java.io.PrintStream: void println(java.lang.String)>($r47);

     label06:
        $d4 = orderedClasses[y#106];

        $z3 = staticinvoke <weka.core.Utils: boolean eq(double,double)>($d4, 0.0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z3);

        if $z3 == 0 goto label07;

        goto label16;

     label07:
        all#147 = 0.0;

        i#149 = y#106;

     label08:
        $i6 = lengthof orderedClasses;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#149);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i6);

        if i#149 >= $i6 goto label09;

        $d5 = orderedClasses[i#149];

        all#147 = all#147 + $d5;

        i#149 = i#149 + 1;

        goto label08;

     label09:
        $d6 = orderedClasses[y#106];

        expFPRate = $d6 / all#147;

        classYWeights#164 = 0.0;

        totalWeights#166 = 0.0;

        j#168 = 0;

     label10:
        $i7 = virtualinvoke data#53.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#168);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i7);

        if j#168 >= $i7 goto label12;

        datum = virtualinvoke data#53.<weka.core.Instances: weka.core.Instance instance(int)>(j#168);

        $d7 = interfaceinvoke datum.<weka.core.Instance: double weight()>();

        totalWeights#166 = totalWeights#166 + $d7;

        $d8 = interfaceinvoke datum.<weka.core.Instance: double classValue()>();

        $i8 = (int) $d8;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i8);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(y#106);

        if $i8 != y#106 goto label11;

        $d9 = interfaceinvoke datum.<weka.core.Instance: double weight()>();

        classYWeights#164 = classYWeights#164 + $d9;

     label11:
        j#168 = j#168 + 1;

        goto label10;

     label12:
        $b9 = classYWeights#164 cmpl 0.0;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b9);

        if $b9 <= 0 goto label16;

        defDL = staticinvoke <weka.classifiers.rules.RuleStats: double dataDL(double,double,double,double,double)>(expFPRate, 0.0, totalWeights#166, 0.0, classYWeights#164);

        $z4 = staticinvoke <java.lang.Double: boolean isNaN(double)>(defDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z4);

        if $z4 != 0 goto label13;

        $z5 = staticinvoke <java.lang.Double: boolean isInfinite(double)>(defDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z5);

        if $z5 == 0 goto label14;

     label13:
        $r48 = new java.lang.Exception;

        specialinvoke $r48.<java.lang.Exception: void <init>(java.lang.String)>("Should never happen: defDL NaN or infinite!");

        throw $r48;

     label14:
        $z6 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z6);

        if $z6 == 0 goto label15;

        $r49 = <java.lang.System: java.io.PrintStream err>;

        $r50 = new java.lang.StringBuilder;

        specialinvoke $r50.<java.lang.StringBuilder: void <init>()>();

        $r51 = virtualinvoke $r50.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The default DL = ");

        $r52 = virtualinvoke $r51.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(defDL);

        $r53 = virtualinvoke $r52.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r49.<java.io.PrintStream: void println(java.lang.String)>($r53);

     label15:
        data#53 = virtualinvoke this.<weka.classifiers.rules.JRip: weka.core.Instances rulesetForOneClass(double,weka.core.Instances,double,double)>(expFPRate, data#53, classIndex, defDL);

     label16:
        y#106 = y#106 + 1;

        goto label05;

     label17:
        $r54 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        l4 = virtualinvoke $r54.<java.util.ArrayList: java.util.Iterator iterator()>();

     label18:
        $z7 = interfaceinvoke l4.<java.util.Iterator: boolean hasNext()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z7);

        if $z7 == 0 goto label19;

        $r55 = interfaceinvoke l4.<java.util.Iterator: java.lang.Object next()>();

        rule = (weka.classifiers.rules.Rule) $r55;

        $r56 = (weka.classifiers.rules.JRip$RipperRule) rule;

        virtualinvoke $r56.<weka.classifiers.rules.JRip$RipperRule: void cleanUp(weka.core.Instances)>(data#53);

        goto label18;

     label19:
        $r57 = new weka.classifiers.rules.JRip$RipperRule;

        specialinvoke $r57.<weka.classifiers.rules.JRip$RipperRule: void <init>(weka.classifiers.rules.JRip)>(this);

        defRule = $r57;

        $i10 = virtualinvoke data#53.<weka.core.Instances: int numClasses()>();

        $i11 = $i10 - 1;

        $d10 = (double) $i11;

        virtualinvoke defRule.<weka.classifiers.rules.JRip$RipperRule: void setConsequent(double)>($d10);

        $r58 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        virtualinvoke $r58.<java.util.ArrayList: boolean add(java.lang.Object)>(defRule);

        $r59 = new weka.classifiers.rules.RuleStats;

        specialinvoke $r59.<weka.classifiers.rules.RuleStats: void <init>()>();

        defRuleStat = $r59;

        virtualinvoke defRuleStat.<weka.classifiers.rules.RuleStats: void setData(weka.core.Instances)>(data#53);

        $d11 = this.<weka.classifiers.rules.JRip: double m_Total>;

        virtualinvoke defRuleStat.<weka.classifiers.rules.RuleStats: void setNumAllConds(double)>($d11);

        virtualinvoke defRuleStat.<weka.classifiers.rules.RuleStats: void addAndUpdate(weka.classifiers.rules.Rule)>(defRule);

        $r60 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        virtualinvoke $r60.<java.util.ArrayList: boolean add(java.lang.Object)>(defRuleStat);

        z#256 = 0;

     label20:
        $r61 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        $i12 = virtualinvoke $r61.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(z#256);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i12);

        if z#256 >= $i12 goto label24;

        $r62 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        $r63 = virtualinvoke $r62.<java.util.ArrayList: java.lang.Object get(int)>(z#256);

        oneClass = (weka.classifiers.rules.RuleStats) $r63;

        xyz#267 = 0;

     label21:
        $i13 = virtualinvoke oneClass.<weka.classifiers.rules.RuleStats: int getRulesetSize()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(xyz#267);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i13);

        if xyz#267 >= $i13 goto label23;

        classDist = virtualinvoke oneClass.<weka.classifiers.rules.RuleStats: double[] getDistributions(int)>(xyz#267);

        staticinvoke <weka.core.Utils: void normalize(double[])>(classDist);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(classDist);

        if classDist == null goto label22;

        $r64 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Distributions>;

        $r65 = this.<weka.classifiers.rules.JRip: weka.filters.Filter m_Filter>;

        $r66 = (weka.filters.supervised.attribute.ClassOrder) $r65;

        $r67 = virtualinvoke $r66.<weka.filters.supervised.attribute.ClassOrder: double[] distributionsByOriginalIndex(double[])>(classDist);

        virtualinvoke $r64.<java.util.ArrayList: boolean add(java.lang.Object)>($r67);

     label22:
        xyz#267 = xyz#267 + 1;

        goto label21;

     label23:
        z#256 = z#256 + 1;

        goto label20;

     label24:
        i#285 = 0;

     label25:
        $r68 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        $i14 = virtualinvoke $r68.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#285);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i14);

        if i#285 >= $i14 goto label26;

        $r69 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        $r70 = virtualinvoke $r69.<java.util.ArrayList: java.lang.Object get(int)>(i#285);

        $r71 = (weka.classifiers.rules.RuleStats) $r70;

        virtualinvoke $r71.<weka.classifiers.rules.RuleStats: void cleanUp()>();

        i#285 = i#285 + 1;

        goto label25;

     label26:
        return;
    }

    public java.lang.String toString()
    {
        weka.classifiers.rules.JRip this;
        java.lang.StringBuffer sb, $r1;
        weka.classifiers.rules.RuleStats rs;
        java.util.ArrayList rules, $r0, $r2, $r3, $r19, $r21, $r28;
        double[] simStats;
        int j#8, $i0, k#21, $i1, i#60, $i2, $i3;
        java.lang.Object $r4, $r6, $r22;
        java.lang.StringBuilder $r5, $r10, $r11, $r12, $r13, $r14, $r15, $r26, $r27, $r29, $r30;
        weka.classifiers.rules.JRip$RipperRule $r7, $r23;
        weka.core.Attribute $r8, $r24;
        java.lang.String $r9, $r16, $r25, $r31, $r33;
        double $d0, $d1;
        boolean $z0;
        java.io.PrintStream $r18, $r20;

        this := @this: weka.classifiers.rules.JRip;

        $r0 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($r0);

        if $r0 != null goto label1;

        return "JRIP: No model built yet.";

     label1:
        $r1 = new java.lang.StringBuffer;

        specialinvoke $r1.<java.lang.StringBuffer: void <init>(java.lang.String)>("JRIP rules:\n===========\n\n");

        sb = $r1;

        j#8 = 0;

     label2:
        $r2 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        $i0 = virtualinvoke $r2.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(j#8);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if j#8 >= $i0 goto label5;

        $r3 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        $r4 = virtualinvoke $r3.<java.util.ArrayList: java.lang.Object get(int)>(j#8);

        rs = (weka.classifiers.rules.RuleStats) $r4;

        rules = virtualinvoke rs.<weka.classifiers.rules.RuleStats: java.util.ArrayList getRuleset()>();

        k#21 = 0;

     label3:
        $i1 = virtualinvoke rules.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#21);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i1);

        if k#21 >= $i1 goto label4;

        simStats = virtualinvoke rs.<weka.classifiers.rules.RuleStats: double[] getSimpleStats(int)>(k#21);

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke rules.<java.util.ArrayList: java.lang.Object get(int)>(k#21);

        $r7 = (weka.classifiers.rules.JRip$RipperRule) $r6;

        $r8 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r9 = virtualinvoke $r7.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r8);

        $r10 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r9);

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" (");

        $d0 = simStats[0];

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d0);

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("/");

        $d1 = simStats[4];

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d1);

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")\n");

        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke sb.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>($r16);

        k#21 = k#21 + 1;

        goto label3;

     label4:
        j#8 = j#8 + 1;

        goto label2;

     label5:
        $z0 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label7;

        $r18 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r18.<java.io.PrintStream: void println(java.lang.String)>("Inside m_Ruleset");

        i#60 = 0;

     label6:
        $r19 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        $i2 = virtualinvoke $r19.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#60);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i2);

        if i#60 >= $i2 goto label7;

        $r20 = <java.lang.System: java.io.PrintStream err>;

        $r21 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        $r22 = virtualinvoke $r21.<java.util.ArrayList: java.lang.Object get(int)>(i#60);

        $r23 = (weka.classifiers.rules.JRip$RipperRule) $r22;

        $r24 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r25 = virtualinvoke $r23.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r24);

        virtualinvoke $r20.<java.io.PrintStream: void println(java.lang.String)>($r25);

        i#60 = i#60 + 1;

        goto label6;

     label7:
        $r26 = new java.lang.StringBuilder;

        specialinvoke $r26.<java.lang.StringBuilder: void <init>()>();

        $r27 = virtualinvoke $r26.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nNumber of Rules : ");

        $r28 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        $i3 = virtualinvoke $r28.<java.util.ArrayList: int size()>();

        $r29 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i3);

        $r30 = virtualinvoke $r29.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        $r31 = virtualinvoke $r30.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke sb.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>($r31);

        $r33 = virtualinvoke sb.<java.lang.StringBuffer: java.lang.String toString()>();

        return $r33;
    }

    public weka.core.Capabilities getCapabilities()
    {
        weka.classifiers.rules.JRip this;
        weka.core.Capabilities result;
        weka.core.Capabilities$Capability $r0, $r1, $r2, $r3, $r4, $r5;
        int $i0;

        this := @this: weka.classifiers.rules.JRip;

        result = specialinvoke this.<weka.classifiers.AbstractClassifier: weka.core.Capabilities getCapabilities()>();

        virtualinvoke result.<weka.core.Capabilities: void disableAll()>();

        $r0 = <weka.core.Capabilities$Capability: weka.core.Capabilities$Capability NOMINAL_ATTRIBUTES>;

        virtualinvoke result.<weka.core.Capabilities: void enable(weka.core.Capabilities$Capability)>($r0);

        $r1 = <weka.core.Capabilities$Capability: weka.core.Capabilities$Capability NUMERIC_ATTRIBUTES>;

        virtualinvoke result.<weka.core.Capabilities: void enable(weka.core.Capabilities$Capability)>($r1);

        $r2 = <weka.core.Capabilities$Capability: weka.core.Capabilities$Capability DATE_ATTRIBUTES>;

        virtualinvoke result.<weka.core.Capabilities: void enable(weka.core.Capabilities$Capability)>($r2);

        $r3 = <weka.core.Capabilities$Capability: weka.core.Capabilities$Capability MISSING_VALUES>;

        virtualinvoke result.<weka.core.Capabilities: void enable(weka.core.Capabilities$Capability)>($r3);

        $r4 = <weka.core.Capabilities$Capability: weka.core.Capabilities$Capability NOMINAL_CLASS>;

        virtualinvoke result.<weka.core.Capabilities: void enable(weka.core.Capabilities$Capability)>($r4);

        $r5 = <weka.core.Capabilities$Capability: weka.core.Capabilities$Capability MISSING_CLASS_VALUES>;

        virtualinvoke result.<weka.core.Capabilities: void enable(weka.core.Capabilities$Capability)>($r5);

        $i0 = this.<weka.classifiers.rules.JRip: int m_Folds>;

        virtualinvoke result.<weka.core.Capabilities: void setMinimumNumberInstances(int)>($i0);

        return result;
    }

    protected weka.core.Instances rulesetForOneClass(double, weka.core.Instances, double, double) throws java.lang.Exception
    {
        weka.classifiers.rules.JRip this;
        double expFPRate, classIndex, defDL, repDL, revDL, oldDL, dl#9, minDL#11, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7, $d8, minDL#279, dl#280, $d10, $d11, $d12, $d13, $d14, $d15, $d16, $d17, $d18, $d19, $d20, $d21, $d22, $d23, $d24, $d25;
        weka.core.Instances data, newGrowData, newData#2, growData#38, pruneData#42, newData#260, growData#301, pruneData#305, pruneData#390, $r93, $r210;
        weka.core.Instances[] part, part, $r54, $r186, $r209;
        int last, del, $i0, $i1, $i2, z#243, $i4, position#270, $i5, $i6, $i7, i#362, $i8, b#406, $i9, c#428, $i10, x#740, $i15, $i16, $i17, $i18, k#781, $i19, $i20, $i21, x#821, $i22, $i23, $i24, $i25;
        weka.classifiers.rules.JRip$RipperRule newRule, oldRule, replace, revision, $r3, oneRule#46, $r20, $r78, finalRule#341, $r90, $r180, $r201;
        weka.core.Instance inst, $r88;
        double[][] prevRuleStats;
        java.util.ArrayList tempRules, $r0, ruleset#7, $r30, $r95, $r207, $r208;
        java.util.Iterator l34;
        weka.classifiers.rules.Rule r, $r98, $r188;
        weka.classifiers.rules.RuleStats repStat, revStat, rstats#13, $r29, $r67, finalRulesetStat#263, $r99, $r123, $r134, rstats#586;
        boolean stop#4, hasPositive#16, $z0, $z1, $z2, $z3, $z4, $z5, $z6, $z7, $z8, $z9, $z10, $z11, $z12, $z13, $z14, $z15, $z16, stop#272, hasPositive#276, $z17, isResidual#287, $z18, $z19, $z20, covers#360, $z21, $z22, $z23, $z24, $z25, $z26, $z27, $z28, $z29, $z30, $z31, $z32, $z33, $z34, $z35, $z36, $z37, $z38, $z39, $z40, $z41, $z42, $z43, $z44, $z45, $z46;
        java.io.PrintStream $r1, $r4, $r5, $r12, $r13, $r21, $r22, $r32, $r41, $r55, $r60, $r61, $r69, $r79, $r80, $r89, $r91, $r100, $r113, $r124, $r136, $r145, $r154, $r161, $r174, $r175, $r185, $r189, $r190, $r195, $r196, $r206;
        java.util.Random $r2, $r68;
        java.lang.StringBuilder $r6, $r7, $r10, $r14, $r15, $r18, $r23, $r24, $r27, $r33, $r34, $r35, $r36, $r37, $r38, $r39, $r42, $r43, $r44, $r45, $r46, $r47, $r48, $r49, $r50, $r51, $r52, $r56, $r57, $r58, $r62, $r63, $r64, $r65, $r70, $r71, $r72, $r73, $r74, $r75, $r76, $r81, $r82, $r85, $r101, $r102, $r103, $r104, $r105, $r106, $r107, $r108, $r109, $r110, $r111, $r114, $r115, $r118, $r119, $r120, $r125, $r126, $r129, $r130, $r131, $r137, $r138, $r141, $r142, $r143, $r146, $r147, $r148, $r149, $r150, $r151, $r152, $r155, $r156, $r157, $r158, $r159, $r162, $r163, $r164, $r165, $r166, $r167, $r168, $r169, $r170, $r171, $r172, $r176, $r177, $r178, $r183, $r191, $r192, $r193, $r197, $r198, $r199, $r204;
        weka.core.Attribute $r8, $r16, $r25, $r83, $r116, $r127, $r139, $r181, $r202;
        java.lang.String $r9, $r11, $r17, $r19, $r26, $r28, $r40, $r53, $r59, $r66, $r77, $r84, $r86, $r112, $r117, $r121, $r128, $r132, $r140, $r144, $r153, $r160, $r173, $r182, $r184, $r194, $r203, $r205;
        java.lang.Exception $r31, $r122, $r133, $r135;
        byte $b3, $b11, $b12, $b13, $b14;
        double[] rst#167, $r94, rst#470, rst#659;
        java.lang.Object $r87, $r92, $r96, $r97, $r179, $r187, $r200;

        this := @this: weka.classifiers.rules.JRip;

        expFPRate := @parameter0: double;

        data := @parameter1: weka.core.Instances;

        classIndex := @parameter2: double;

        defDL := @parameter3: double;

        newData#2 = data;

        stop#4 = 0;

        $r0 = new java.util.ArrayList;

        specialinvoke $r0.<java.util.ArrayList: void <init>()>();

        ruleset#7 = $r0;

        dl#9 = defDL;

        minDL#11 = defDL;

        rstats#13 = null;

        hasPositive#16 = 1;

        $z0 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label01;

        $r1 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r1.<java.io.PrintStream: void println(java.lang.String)>("\n*** Building stage ***");

     label01:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(stop#4);

        if stop#4 != 0 goto label18;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(hasPositive#16);

        if hasPositive#16 == 0 goto label18;

        $z1 = this.<weka.classifiers.rules.JRip: boolean m_UsePruning>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z1);

        if $z1 == 0 goto label06;

        $i0 = this.<weka.classifiers.rules.JRip: int m_Folds>;

        $r2 = this.<weka.classifiers.rules.JRip: java.util.Random m_Random>;

        newData#2 = staticinvoke <weka.classifiers.rules.RuleStats: weka.core.Instances stratify(weka.core.Instances,int,java.util.Random)>(newData#2, $i0, $r2);

        $i1 = this.<weka.classifiers.rules.JRip: int m_Folds>;

        part = staticinvoke <weka.classifiers.rules.RuleStats: weka.core.Instances[] partition(weka.core.Instances,int)>(newData#2, $i1);

        growData#38 = part[0];

        pruneData#42 = part[1];

        $r3 = new weka.classifiers.rules.JRip$RipperRule;

        specialinvoke $r3.<weka.classifiers.rules.JRip$RipperRule: void <init>(weka.classifiers.rules.JRip)>(this);

        oneRule#46 = $r3;

        virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: void setConsequent(double)>(classIndex);

        $z2 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z2);

        if $z2 == 0 goto label02;

        $r4 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r4.<java.io.PrintStream: void println(java.lang.String)>("\nGrowing a rule ...");

     label02:
        virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: void grow(weka.core.Instances)>(growData#38);

        $z3 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z3);

        if $z3 == 0 goto label03;

        $r5 = <java.lang.System: java.io.PrintStream err>;

        $r6 = new java.lang.StringBuilder;

        specialinvoke $r6.<java.lang.StringBuilder: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("One rule found before pruning:");

        $r8 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r9 = virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r8);

        $r10 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r9);

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r5.<java.io.PrintStream: void println(java.lang.String)>($r11);

     label03:
        $z4 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z4);

        if $z4 == 0 goto label04;

        $r12 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r12.<java.io.PrintStream: void println(java.lang.String)>("\nPruning the rule ...");

     label04:
        virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: void prune(weka.core.Instances,boolean)>(pruneData#42, 0);

        $z5 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z5);

        if $z5 == 0 goto label05;

        $r13 = <java.lang.System: java.io.PrintStream err>;

        $r14 = new java.lang.StringBuilder;

        specialinvoke $r14.<java.lang.StringBuilder: void <init>()>();

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("One rule found after pruning:");

        $r16 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r17 = virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r16);

        $r18 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r17);

        $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r13.<java.io.PrintStream: void println(java.lang.String)>($r19);

     label05:
        goto label08;

     label06:
        $r20 = new weka.classifiers.rules.JRip$RipperRule;

        specialinvoke $r20.<weka.classifiers.rules.JRip$RipperRule: void <init>(weka.classifiers.rules.JRip)>(this);

        oneRule#46 = $r20;

        virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: void setConsequent(double)>(classIndex);

        $z6 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z6);

        if $z6 == 0 goto label07;

        $r21 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r21.<java.io.PrintStream: void println(java.lang.String)>("\nNo pruning: growing a rule ...");

     label07:
        virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: void grow(weka.core.Instances)>(newData#2);

        $z7 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z7);

        if $z7 == 0 goto label08;

        $r22 = <java.lang.System: java.io.PrintStream err>;

        $r23 = new java.lang.StringBuilder;

        specialinvoke $r23.<java.lang.StringBuilder: void <init>()>();

        $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("No pruning: one rule found:\n");

        $r25 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r26 = virtualinvoke oneRule#46.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r25);

        $r27 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r26);

        $r28 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r22.<java.io.PrintStream: void println(java.lang.String)>($r28);

     label08:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(rstats#13);

        if rstats#13 != null goto label09;

        $r29 = new weka.classifiers.rules.RuleStats;

        specialinvoke $r29.<weka.classifiers.rules.RuleStats: void <init>()>();

        rstats#13 = $r29;

        $d0 = this.<weka.classifiers.rules.JRip: double m_Total>;

        virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: void setNumAllConds(double)>($d0);

        virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: void setData(weka.core.Instances)>(newData#2);

     label09:
        virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: void addAndUpdate(weka.classifiers.rules.Rule)>(oneRule#46);

        $r30 = virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: java.util.ArrayList getRuleset()>();

        $i2 = virtualinvoke $r30.<java.util.ArrayList: int size()>();

        last = $i2 - 1;

        $z8 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        $d1 = virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: double relativeDL(int,double,boolean)>(last, expFPRate, $z8);

        dl#9 = dl#9 + $d1;

        $z9 = staticinvoke <java.lang.Double: boolean isNaN(double)>(dl#9);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z9);

        if $z9 != 0 goto label10;

        $z10 = staticinvoke <java.lang.Double: boolean isInfinite(double)>(dl#9);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z10);

        if $z10 == 0 goto label11;

     label10:
        $r31 = new java.lang.Exception;

        specialinvoke $r31.<java.lang.Exception: void <init>(java.lang.String)>("Should never happen: dl in building stage NaN or infinite!");

        throw $r31;

     label11:
        $z11 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z11);

        if $z11 == 0 goto label12;

        $r32 = <java.lang.System: java.io.PrintStream err>;

        $r33 = new java.lang.StringBuilder;

        specialinvoke $r33.<java.lang.StringBuilder: void <init>()>();

        $r34 = virtualinvoke $r33.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Before optimization(");

        $r35 = virtualinvoke $r34.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(last);

        $r36 = virtualinvoke $r35.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("): the dl = ");

        $r37 = virtualinvoke $r36.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(dl#9);

        $r38 = virtualinvoke $r37.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | best: ");

        $r39 = virtualinvoke $r38.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(minDL#11);

        $r40 = virtualinvoke $r39.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r32.<java.io.PrintStream: void println(java.lang.String)>($r40);

     label12:
        $b3 = dl#9 cmpg minDL#11;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b3);

        if $b3 >= 0 goto label13;

        minDL#11 = dl#9;

     label13:
        rst#167 = virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: double[] getSimpleStats(int)>(last);

        $z12 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z12);

        if $z12 == 0 goto label14;

        $r41 = <java.lang.System: java.io.PrintStream err>;

        $r42 = new java.lang.StringBuilder;

        specialinvoke $r42.<java.lang.StringBuilder: void <init>()>();

        $r43 = virtualinvoke $r42.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The rule covers: ");

        $d2 = rst#167[0];

        $r44 = virtualinvoke $r43.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d2);

        $r45 = virtualinvoke $r44.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | pos = ");

        $d3 = rst#167[2];

        $r46 = virtualinvoke $r45.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d3);

        $r47 = virtualinvoke $r46.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | neg = ");

        $d4 = rst#167[4];

        $r48 = virtualinvoke $r47.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d4);

        $r49 = virtualinvoke $r48.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nThe rule doesn\'t cover: ");

        $d5 = rst#167[1];

        $r50 = virtualinvoke $r49.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d5);

        $r51 = virtualinvoke $r50.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | pos = ");

        $d6 = rst#167[5];

        $r52 = virtualinvoke $r51.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d6);

        $r53 = virtualinvoke $r52.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r41.<java.io.PrintStream: void println(java.lang.String)>($r53);

     label14:
        stop#4 = specialinvoke this.<weka.classifiers.rules.JRip: boolean checkStop(double[],double,double)>(rst#167, minDL#11, dl#9);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(stop#4);

        if stop#4 != 0 goto label15;

        virtualinvoke ruleset#7.<java.util.ArrayList: boolean add(java.lang.Object)>(oneRule#46);

        $r54 = virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: weka.core.Instances[] getFiltered(int)>(last);

        newData#2 = $r54[1];

        $d7 = rst#167[5];

        hasPositive#16 = staticinvoke <weka.core.Utils: boolean gr(double,double)>($d7, 0.0);

        $z13 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z13);

        if $z13 == 0 goto label17;

        $r55 = <java.lang.System: java.io.PrintStream err>;

        $r56 = new java.lang.StringBuilder;

        specialinvoke $r56.<java.lang.StringBuilder: void <init>()>();

        $r57 = virtualinvoke $r56.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("One rule added: has positive? ");

        $r58 = virtualinvoke $r57.<java.lang.StringBuilder: java.lang.StringBuilder append(boolean)>(hasPositive#16);

        $r59 = virtualinvoke $r58.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r55.<java.io.PrintStream: void println(java.lang.String)>($r59);

        goto label17;

     label15:
        $z14 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z14);

        if $z14 == 0 goto label16;

        $r60 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r60.<java.io.PrintStream: void println(java.lang.String)>("Quit rule");

     label16:
        virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: void removeLast()>();

     label17:
        goto label01;

     label18:
        $z15 = this.<weka.classifiers.rules.JRip: boolean m_UsePruning>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z15);

        if $z15 == 0 goto label69;

        z#243 = 0;

     label19:
        $i4 = this.<weka.classifiers.rules.JRip: int m_Optimizations>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(z#243);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i4);

        if z#243 >= $i4 goto label69;

        $z16 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z16);

        if $z16 == 0 goto label20;

        $r61 = <java.lang.System: java.io.PrintStream err>;

        $r62 = new java.lang.StringBuilder;

        specialinvoke $r62.<java.lang.StringBuilder: void <init>()>();

        $r63 = virtualinvoke $r62.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n*** Optimization: run #");

        $r64 = virtualinvoke $r63.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(z#243);

        $r65 = virtualinvoke $r64.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" ***");

        $r66 = virtualinvoke $r65.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r61.<java.io.PrintStream: void println(java.lang.String)>($r66);

     label20:
        newData#260 = data;

        $r67 = new weka.classifiers.rules.RuleStats;

        specialinvoke $r67.<weka.classifiers.rules.RuleStats: void <init>()>();

        finalRulesetStat#263 = $r67;

        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void setData(weka.core.Instances)>(newData#260);

        $d8 = this.<weka.classifiers.rules.JRip: double m_Total>;

        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void setNumAllConds(double)>($d8);

        position#270 = 0;

        stop#272 = 0;

        hasPositive#276 = 1;

        minDL#279 = defDL;

        dl#280 = defDL;

     label21:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(stop#272);

        if stop#272 != 0 goto label64;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(hasPositive#276);

        if hasPositive#276 == 0 goto label64;

        $i5 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(position#270);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i5);

        if position#270 < $i5 goto label22;

        $z17 = 1;

        goto label23;

     label22:
        $z17 = 0;

     label23:
        isResidual#287 = $z17;

        $i6 = this.<weka.classifiers.rules.JRip: int m_Folds>;

        $r68 = this.<weka.classifiers.rules.JRip: java.util.Random m_Random>;

        newData#260 = staticinvoke <weka.classifiers.rules.RuleStats: weka.core.Instances stratify(weka.core.Instances,int,java.util.Random)>(newData#260, $i6, $r68);

        $i7 = this.<weka.classifiers.rules.JRip: int m_Folds>;

        part = staticinvoke <weka.classifiers.rules.RuleStats: weka.core.Instances[] partition(weka.core.Instances,int)>(newData#260, $i7);

        growData#301 = part[0];

        pruneData#305 = part[1];

        $z18 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z18);

        if $z18 == 0 goto label24;

        $r69 = <java.lang.System: java.io.PrintStream err>;

        $r70 = new java.lang.StringBuilder;

        specialinvoke $r70.<java.lang.StringBuilder: void <init>()>();

        $r71 = virtualinvoke $r70.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nRule #");

        $r72 = virtualinvoke $r71.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(position#270);

        $r73 = virtualinvoke $r72.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("| isResidual?");

        $r74 = virtualinvoke $r73.<java.lang.StringBuilder: java.lang.StringBuilder append(boolean)>(isResidual#287);

        $r75 = virtualinvoke $r74.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("| data size: ");

        $d10 = virtualinvoke newData#260.<weka.core.Instances: double sumOfWeights()>();

        $r76 = virtualinvoke $r75.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d10);

        $r77 = virtualinvoke $r76.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r69.<java.io.PrintStream: void println(java.lang.String)>($r77);

     label24:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(isResidual#287);

        if isResidual#287 == 0 goto label27;

        $r78 = new weka.classifiers.rules.JRip$RipperRule;

        specialinvoke $r78.<weka.classifiers.rules.JRip$RipperRule: void <init>(weka.classifiers.rules.JRip)>(this);

        newRule = $r78;

        virtualinvoke newRule.<weka.classifiers.rules.JRip$RipperRule: void setConsequent(double)>(classIndex);

        $z19 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z19);

        if $z19 == 0 goto label25;

        $r79 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r79.<java.io.PrintStream: void println(java.lang.String)>("\nGrowing and pruning a new rule ...");

     label25:
        virtualinvoke newRule.<weka.classifiers.rules.JRip$RipperRule: void grow(weka.core.Instances)>(growData#301);

        virtualinvoke newRule.<weka.classifiers.rules.JRip$RipperRule: void prune(weka.core.Instances,boolean)>(pruneData#305, 0);

        finalRule#341 = newRule;

        $z20 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z20);

        if $z20 == 0 goto label26;

        $r80 = <java.lang.System: java.io.PrintStream err>;

        $r81 = new java.lang.StringBuilder;

        specialinvoke $r81.<java.lang.StringBuilder: void <init>()>();

        $r82 = virtualinvoke $r81.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nNew rule found: ");

        $r83 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r84 = virtualinvoke newRule.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r83);

        $r85 = virtualinvoke $r82.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r84);

        $r86 = virtualinvoke $r85.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r80.<java.io.PrintStream: void println(java.lang.String)>($r86);

     label26:
        goto label54;

     label27:
        $r87 = virtualinvoke ruleset#7.<java.util.ArrayList: java.lang.Object get(int)>(position#270);

        oldRule = (weka.classifiers.rules.JRip$RipperRule) $r87;

        covers#360 = 0;

        i#362 = 0;

     label28:
        $i8 = virtualinvoke newData#260.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#362);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i8);

        if i#362 >= $i8 goto label30;

        $r88 = virtualinvoke newData#260.<weka.core.Instances: weka.core.Instance instance(int)>(i#362);

        $z21 = virtualinvoke oldRule.<weka.classifiers.rules.JRip$RipperRule: boolean covers(weka.core.Instance)>($r88);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z21);

        if $z21 == 0 goto label29;

        covers#360 = 1;

        goto label30;

     label29:
        i#362 = i#362 + 1;

        goto label28;

     label30:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(covers#360);

        if covers#360 != 0 goto label31;

        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void addAndUpdate(weka.classifiers.rules.Rule)>(oldRule);

        position#270 = position#270 + 1;

        goto label21;

     label31:
        $z22 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z22);

        if $z22 == 0 goto label32;

        $r89 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r89.<java.io.PrintStream: void println(java.lang.String)>("\nGrowing and pruning Replace ...");

     label32:
        $r90 = new weka.classifiers.rules.JRip$RipperRule;

        specialinvoke $r90.<weka.classifiers.rules.JRip$RipperRule: void <init>(weka.classifiers.rules.JRip)>(this);

        replace = $r90;

        virtualinvoke replace.<weka.classifiers.rules.JRip$RipperRule: void setConsequent(double)>(classIndex);

        virtualinvoke replace.<weka.classifiers.rules.JRip$RipperRule: void grow(weka.core.Instances)>(growData#301);

        pruneData#390 = staticinvoke <weka.classifiers.rules.RuleStats: weka.core.Instances rmCoveredBySuccessives(weka.core.Instances,java.util.ArrayList,int)>(pruneData#305, ruleset#7, position#270);

        virtualinvoke replace.<weka.classifiers.rules.JRip$RipperRule: void prune(weka.core.Instances,boolean)>(pruneData#390, 1);

        $z23 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z23);

        if $z23 == 0 goto label33;

        $r91 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r91.<java.io.PrintStream: void println(java.lang.String)>("\nGrowing and pruning Revision ...");

     label33:
        $r92 = virtualinvoke oldRule.<weka.classifiers.rules.JRip$RipperRule: java.lang.Object copy()>();

        revision = (weka.classifiers.rules.JRip$RipperRule) $r92;

        $r93 = new weka.core.Instances;

        specialinvoke $r93.<weka.core.Instances: void <init>(weka.core.Instances,int)>(growData#301, 0);

        newGrowData = $r93;

        b#406 = 0;

     label34:
        $i9 = virtualinvoke growData#301.<weka.core.Instances: int numInstances()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(b#406);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i9);

        if b#406 >= $i9 goto label36;

        inst = virtualinvoke growData#301.<weka.core.Instances: weka.core.Instance instance(int)>(b#406);

        $z24 = virtualinvoke revision.<weka.classifiers.rules.JRip$RipperRule: boolean covers(weka.core.Instance)>(inst);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z24);

        if $z24 == 0 goto label35;

        virtualinvoke newGrowData.<weka.core.Instances: boolean add(weka.core.Instance)>(inst);

     label35:
        b#406 = b#406 + 1;

        goto label34;

     label36:
        virtualinvoke revision.<weka.classifiers.rules.JRip$RipperRule: void grow(weka.core.Instances)>(newGrowData);

        virtualinvoke revision.<weka.classifiers.rules.JRip$RipperRule: void prune(weka.core.Instances,boolean)>(pruneData#390, 1);

        prevRuleStats = newmultiarray (double)[position#270][6];

        c#428 = 0;

     label37:
        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(c#428);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(position#270);

        if c#428 >= position#270 goto label38;

        $r94 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: double[] getSimpleStats(int)>(c#428);

        prevRuleStats[c#428] = $r94;

        c#428 = c#428 + 1;

        goto label37;

     label38:
        $r95 = new java.util.ArrayList;

        $i10 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        specialinvoke $r95.<java.util.ArrayList: void <init>(int)>($i10);

        tempRules = $r95;

        l34 = virtualinvoke ruleset#7.<java.util.ArrayList: java.util.Iterator iterator()>();

     label39:
        $z25 = interfaceinvoke l34.<java.util.Iterator: boolean hasNext()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z25);

        if $z25 == 0 goto label40;

        $r96 = interfaceinvoke l34.<java.util.Iterator: java.lang.Object next()>();

        r = (weka.classifiers.rules.Rule) $r96;

        $r97 = virtualinvoke r.<weka.classifiers.rules.Rule: java.lang.Object copy()>();

        $r98 = (weka.classifiers.rules.Rule) $r97;

        virtualinvoke tempRules.<java.util.ArrayList: boolean add(java.lang.Object)>($r98);

        goto label39;

     label40:
        virtualinvoke tempRules.<java.util.ArrayList: java.lang.Object set(int,java.lang.Object)>(position#270, replace);

        $r99 = new weka.classifiers.rules.RuleStats;

        specialinvoke $r99.<weka.classifiers.rules.RuleStats: void <init>(weka.core.Instances,java.util.ArrayList)>(data, tempRules);

        repStat = $r99;

        $d11 = this.<weka.classifiers.rules.JRip: double m_Total>;

        virtualinvoke repStat.<weka.classifiers.rules.RuleStats: void setNumAllConds(double)>($d11);

        virtualinvoke repStat.<weka.classifiers.rules.RuleStats: void countData(int,weka.core.Instances,double[][])>(position#270, newData#260, prevRuleStats);

        rst#470 = virtualinvoke repStat.<weka.classifiers.rules.RuleStats: double[] getSimpleStats(int)>(position#270);

        $z26 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z26);

        if $z26 == 0 goto label41;

        $r100 = <java.lang.System: java.io.PrintStream err>;

        $r101 = new java.lang.StringBuilder;

        specialinvoke $r101.<java.lang.StringBuilder: void <init>()>();

        $r102 = virtualinvoke $r101.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Replace rule covers: ");

        $d12 = rst#470[0];

        $r103 = virtualinvoke $r102.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d12);

        $r104 = virtualinvoke $r103.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | pos = ");

        $d13 = rst#470[2];

        $r105 = virtualinvoke $r104.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d13);

        $r106 = virtualinvoke $r105.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | neg = ");

        $d14 = rst#470[4];

        $r107 = virtualinvoke $r106.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d14);

        $r108 = virtualinvoke $r107.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nThe rule doesn\'t cover: ");

        $d15 = rst#470[1];

        $r109 = virtualinvoke $r108.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d15);

        $r110 = virtualinvoke $r109.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | pos = ");

        $d16 = rst#470[5];

        $r111 = virtualinvoke $r110.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d16);

        $r112 = virtualinvoke $r111.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r100.<java.io.PrintStream: void println(java.lang.String)>($r112);

     label41:
        $z27 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        repDL = virtualinvoke repStat.<weka.classifiers.rules.RuleStats: double relativeDL(int,double,boolean)>(position#270, expFPRate, $z27);

        $z28 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z28);

        if $z28 == 0 goto label42;

        $r113 = <java.lang.System: java.io.PrintStream err>;

        $r114 = new java.lang.StringBuilder;

        specialinvoke $r114.<java.lang.StringBuilder: void <init>()>();

        $r115 = virtualinvoke $r114.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nReplace: ");

        $r116 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r117 = virtualinvoke replace.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r116);

        $r118 = virtualinvoke $r115.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r117);

        $r119 = virtualinvoke $r118.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" |dl = ");

        $r120 = virtualinvoke $r119.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(repDL);

        $r121 = virtualinvoke $r120.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r113.<java.io.PrintStream: void println(java.lang.String)>($r121);

     label42:
        $z29 = staticinvoke <java.lang.Double: boolean isNaN(double)>(repDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z29);

        if $z29 != 0 goto label43;

        $z30 = staticinvoke <java.lang.Double: boolean isInfinite(double)>(repDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z30);

        if $z30 == 0 goto label44;

     label43:
        $r122 = new java.lang.Exception;

        specialinvoke $r122.<java.lang.Exception: void <init>(java.lang.String)>("Should never happen: repDLin optmz. stage NaN or infinite!");

        throw $r122;

     label44:
        virtualinvoke tempRules.<java.util.ArrayList: java.lang.Object set(int,java.lang.Object)>(position#270, revision);

        $r123 = new weka.classifiers.rules.RuleStats;

        specialinvoke $r123.<weka.classifiers.rules.RuleStats: void <init>(weka.core.Instances,java.util.ArrayList)>(data, tempRules);

        revStat = $r123;

        $d17 = this.<weka.classifiers.rules.JRip: double m_Total>;

        virtualinvoke revStat.<weka.classifiers.rules.RuleStats: void setNumAllConds(double)>($d17);

        virtualinvoke revStat.<weka.classifiers.rules.RuleStats: void countData(int,weka.core.Instances,double[][])>(position#270, newData#260, prevRuleStats);

        $z31 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        revDL = virtualinvoke revStat.<weka.classifiers.rules.RuleStats: double relativeDL(int,double,boolean)>(position#270, expFPRate, $z31);

        $z32 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z32);

        if $z32 == 0 goto label45;

        $r124 = <java.lang.System: java.io.PrintStream err>;

        $r125 = new java.lang.StringBuilder;

        specialinvoke $r125.<java.lang.StringBuilder: void <init>()>();

        $r126 = virtualinvoke $r125.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Revision: ");

        $r127 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r128 = virtualinvoke revision.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r127);

        $r129 = virtualinvoke $r126.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r128);

        $r130 = virtualinvoke $r129.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" |dl = ");

        $r131 = virtualinvoke $r130.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(revDL);

        $r132 = virtualinvoke $r131.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r124.<java.io.PrintStream: void println(java.lang.String)>($r132);

     label45:
        $z33 = staticinvoke <java.lang.Double: boolean isNaN(double)>(revDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z33);

        if $z33 != 0 goto label46;

        $z34 = staticinvoke <java.lang.Double: boolean isInfinite(double)>(revDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z34);

        if $z34 == 0 goto label47;

     label46:
        $r133 = new java.lang.Exception;

        specialinvoke $r133.<java.lang.Exception: void <init>(java.lang.String)>("Should never happen: revDLin optmz. stage NaN or infinite!");

        throw $r133;

     label47:
        $r134 = new weka.classifiers.rules.RuleStats;

        specialinvoke $r134.<weka.classifiers.rules.RuleStats: void <init>(weka.core.Instances,java.util.ArrayList)>(data, ruleset#7);

        rstats#586 = $r134;

        $d18 = this.<weka.classifiers.rules.JRip: double m_Total>;

        virtualinvoke rstats#586.<weka.classifiers.rules.RuleStats: void setNumAllConds(double)>($d18);

        virtualinvoke rstats#586.<weka.classifiers.rules.RuleStats: void countData(int,weka.core.Instances,double[][])>(position#270, newData#260, prevRuleStats);

        $z35 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        oldDL = virtualinvoke rstats#586.<weka.classifiers.rules.RuleStats: double relativeDL(int,double,boolean)>(position#270, expFPRate, $z35);

        $z36 = staticinvoke <java.lang.Double: boolean isNaN(double)>(oldDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z36);

        if $z36 != 0 goto label48;

        $z37 = staticinvoke <java.lang.Double: boolean isInfinite(double)>(oldDL);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z37);

        if $z37 == 0 goto label49;

     label48:
        $r135 = new java.lang.Exception;

        specialinvoke $r135.<java.lang.Exception: void <init>(java.lang.String)>("Should never happen: oldDLin optmz. stage NaN or infinite!");

        throw $r135;

     label49:
        $z38 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z38);

        if $z38 == 0 goto label50;

        $r136 = <java.lang.System: java.io.PrintStream err>;

        $r137 = new java.lang.StringBuilder;

        specialinvoke $r137.<java.lang.StringBuilder: void <init>()>();

        $r138 = virtualinvoke $r137.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Old rule: ");

        $r139 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r140 = virtualinvoke oldRule.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r139);

        $r141 = virtualinvoke $r138.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r140);

        $r142 = virtualinvoke $r141.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" |dl = ");

        $r143 = virtualinvoke $r142.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(oldDL);

        $r144 = virtualinvoke $r143.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r136.<java.io.PrintStream: void println(java.lang.String)>($r144);

     label50:
        $z39 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z39);

        if $z39 == 0 goto label51;

        $r145 = <java.lang.System: java.io.PrintStream err>;

        $r146 = new java.lang.StringBuilder;

        specialinvoke $r146.<java.lang.StringBuilder: void <init>()>();

        $r147 = virtualinvoke $r146.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nrepDL: ");

        $r148 = virtualinvoke $r147.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(repDL);

        $r149 = virtualinvoke $r148.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nrevDL: ");

        $r150 = virtualinvoke $r149.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(revDL);

        $r151 = virtualinvoke $r150.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\noldDL: ");

        $r152 = virtualinvoke $r151.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(oldDL);

        $r153 = virtualinvoke $r152.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r145.<java.io.PrintStream: void println(java.lang.String)>($r153);

     label51:
        $b11 = oldDL cmpg revDL;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b11);

        if $b11 > 0 goto label52;

        $b12 = oldDL cmpg repDL;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b12);

        if $b12 > 0 goto label52;

        finalRule#341 = oldRule;

        goto label54;

     label52:
        $b13 = revDL cmpg repDL;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b13);

        if $b13 > 0 goto label53;

        finalRule#341 = revision;

        goto label54;

     label53:
        finalRule#341 = replace;

     label54:
        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void addAndUpdate(weka.classifiers.rules.Rule)>(finalRule#341);

        rst#659 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: double[] getSimpleStats(int)>(position#270);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(isResidual#287);

        if isResidual#287 == 0 goto label58;

        $z40 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        $d19 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: double relativeDL(int,double,boolean)>(position#270, expFPRate, $z40);

        dl#280 = dl#280 + $d19;

        $z41 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z41);

        if $z41 == 0 goto label55;

        $r154 = <java.lang.System: java.io.PrintStream err>;

        $r155 = new java.lang.StringBuilder;

        specialinvoke $r155.<java.lang.StringBuilder: void <init>()>();

        $r156 = virtualinvoke $r155.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("After optimization: the dl=");

        $r157 = virtualinvoke $r156.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(dl#280);

        $r158 = virtualinvoke $r157.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | best: ");

        $r159 = virtualinvoke $r158.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(minDL#279);

        $r160 = virtualinvoke $r159.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r154.<java.io.PrintStream: void println(java.lang.String)>($r160);

     label55:
        $b14 = dl#280 cmpg minDL#279;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b14);

        if $b14 >= 0 goto label56;

        minDL#279 = dl#280;

     label56:
        stop#272 = specialinvoke this.<weka.classifiers.rules.JRip: boolean checkStop(double[],double,double)>(rst#659, minDL#279, dl#280);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(stop#272);

        if stop#272 != 0 goto label57;

        virtualinvoke ruleset#7.<java.util.ArrayList: boolean add(java.lang.Object)>(finalRule#341);

        goto label59;

     label57:
        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void removeLast()>();

        position#270 = position#270 + -1;

        goto label59;

     label58:
        virtualinvoke ruleset#7.<java.util.ArrayList: java.lang.Object set(int,java.lang.Object)>(position#270, finalRule#341);

     label59:
        $z42 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z42);

        if $z42 == 0 goto label62;

        $r161 = <java.lang.System: java.io.PrintStream err>;

        $r162 = new java.lang.StringBuilder;

        specialinvoke $r162.<java.lang.StringBuilder: void <init>()>();

        $r163 = virtualinvoke $r162.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The rule covers: ");

        $d20 = rst#659[0];

        $r164 = virtualinvoke $r163.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d20);

        $r165 = virtualinvoke $r164.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | pos = ");

        $d21 = rst#659[2];

        $r166 = virtualinvoke $r165.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d21);

        $r167 = virtualinvoke $r166.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | neg = ");

        $d22 = rst#659[4];

        $r168 = virtualinvoke $r167.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d22);

        $r169 = virtualinvoke $r168.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nThe rule doesn\'t cover: ");

        $d23 = rst#659[1];

        $r170 = virtualinvoke $r169.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d23);

        $r171 = virtualinvoke $r170.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | pos = ");

        $d24 = rst#659[5];

        $r172 = virtualinvoke $r171.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d24);

        $r173 = virtualinvoke $r172.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r161.<java.io.PrintStream: void println(java.lang.String)>($r173);

        $r174 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r174.<java.io.PrintStream: void println(java.lang.String)>("\nRuleset so far: ");

        x#740 = 0;

     label60:
        $i15 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(x#740);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i15);

        if x#740 >= $i15 goto label61;

        $r175 = <java.lang.System: java.io.PrintStream err>;

        $r176 = new java.lang.StringBuilder;

        specialinvoke $r176.<java.lang.StringBuilder: void <init>()>();

        $r177 = virtualinvoke $r176.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(x#740);

        $r178 = virtualinvoke $r177.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(": ");

        $r179 = virtualinvoke ruleset#7.<java.util.ArrayList: java.lang.Object get(int)>(x#740);

        $r180 = (weka.classifiers.rules.JRip$RipperRule) $r179;

        $r181 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r182 = virtualinvoke $r180.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r181);

        $r183 = virtualinvoke $r178.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r182);

        $r184 = virtualinvoke $r183.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r175.<java.io.PrintStream: void println(java.lang.String)>($r184);

        x#740 = x#740 + 1;

        goto label60;

     label61:
        $r185 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r185.<java.io.PrintStream: void println()>();

     label62:
        $i16 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: int getRulesetSize()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i16);

        if $i16 <= 0 goto label63;

        $r186 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: weka.core.Instances[] getFiltered(int)>(position#270);

        newData#260 = $r186[1];

     label63:
        $d25 = rst#659[5];

        hasPositive#276 = staticinvoke <weka.core.Utils: boolean gr(double,double)>($d25, 0.0);

        position#270 = position#270 + 1;

        goto label21;

     label64:
        $i17 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        $i18 = position#270 + 1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i17);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i18);

        if $i17 <= $i18 goto label66;

        k#781 = position#270 + 1;

     label65:
        $i19 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(k#781);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i19);

        if k#781 >= $i19 goto label66;

        $r187 = virtualinvoke ruleset#7.<java.util.ArrayList: java.lang.Object get(int)>(k#781);

        $r188 = (weka.classifiers.rules.Rule) $r187;

        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void addAndUpdate(weka.classifiers.rules.Rule)>($r188);

        k#781 = k#781 + 1;

        goto label65;

     label66:
        $z43 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z43);

        if $z43 == 0 goto label67;

        $r189 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r189.<java.io.PrintStream: void println(java.lang.String)>("\nDeleting rules to decrease DL of the whole ruleset ...");

     label67:
        $z44 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: void reduceDL(double,boolean)>(expFPRate, $z44);

        $z45 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z45);

        if $z45 == 0 goto label68;

        $i20 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        $i21 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: int getRulesetSize()>();

        del = $i20 - $i21;

        $r190 = <java.lang.System: java.io.PrintStream err>;

        $r191 = new java.lang.StringBuilder;

        specialinvoke $r191.<java.lang.StringBuilder: void <init>()>();

        $r192 = virtualinvoke $r191.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(del);

        $r193 = virtualinvoke $r192.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" rules are deleted after DL reduction procedure");

        $r194 = virtualinvoke $r193.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r190.<java.io.PrintStream: void println(java.lang.String)>($r194);

     label68:
        ruleset#7 = virtualinvoke finalRulesetStat#263.<weka.classifiers.rules.RuleStats: java.util.ArrayList getRuleset()>();

        rstats#13 = finalRulesetStat#263;

        z#243 = z#243 + 1;

        goto label19;

     label69:
        $z46 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z46);

        if $z46 == 0 goto label72;

        $r195 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r195.<java.io.PrintStream: void println(java.lang.String)>("\nFinal ruleset: ");

        x#821 = 0;

     label70:
        $i22 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(x#821);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i22);

        if x#821 >= $i22 goto label71;

        $r196 = <java.lang.System: java.io.PrintStream err>;

        $r197 = new java.lang.StringBuilder;

        specialinvoke $r197.<java.lang.StringBuilder: void <init>()>();

        $r198 = virtualinvoke $r197.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(x#821);

        $r199 = virtualinvoke $r198.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(": ");

        $r200 = virtualinvoke ruleset#7.<java.util.ArrayList: java.lang.Object get(int)>(x#821);

        $r201 = (weka.classifiers.rules.JRip$RipperRule) $r200;

        $r202 = this.<weka.classifiers.rules.JRip: weka.core.Attribute m_Class>;

        $r203 = virtualinvoke $r201.<weka.classifiers.rules.JRip$RipperRule: java.lang.String toString(weka.core.Attribute)>($r202);

        $r204 = virtualinvoke $r199.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r203);

        $r205 = virtualinvoke $r204.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r196.<java.io.PrintStream: void println(java.lang.String)>($r205);

        x#821 = x#821 + 1;

        goto label70;

     label71:
        $r206 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r206.<java.io.PrintStream: void println()>();

     label72:
        $r207 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        virtualinvoke $r207.<java.util.ArrayList: boolean addAll(java.util.Collection)>(ruleset#7);

        $r208 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_RulesetStats>;

        virtualinvoke $r208.<java.util.ArrayList: boolean add(java.lang.Object)>(rstats#13);

        $i23 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i23);

        if $i23 <= 0 goto label73;

        $i24 = virtualinvoke ruleset#7.<java.util.ArrayList: int size()>();

        $i25 = $i24 - 1;

        $r209 = virtualinvoke rstats#13.<weka.classifiers.rules.RuleStats: weka.core.Instances[] getFiltered(int)>($i25);

        $r210 = $r209[1];

        return $r210;

     label73:
        return data;
    }

    static double access$100(weka.classifiers.rules.JRip)
    {
        weka.classifiers.rules.JRip x0;
        double $d0;

        x0 := @parameter0: weka.classifiers.rules.JRip;

        $d0 = x0.<weka.classifiers.rules.JRip: double m_MinNo>;

        return $d0;
    }

    static boolean access$000(weka.classifiers.rules.JRip)
    {
        weka.classifiers.rules.JRip x0;
        boolean $z0;

        x0 := @parameter0: weka.classifiers.rules.JRip;

        $z0 = x0.<weka.classifiers.rules.JRip: boolean m_Debug>;

        return $z0;
    }

    private boolean checkStop(double[], double, double)
    {
        weka.classifiers.rules.JRip this;
        double[] rst;
        double minDL, dl, $d0, $d1, $d2, $d3, $d4, $d5, $d6, $d7;
        byte $b0, $b1;
        boolean $z0, $z1, $z2, $z3, $z4, $z5;
        java.io.PrintStream $r0, $r7, $r8, $r15;
        java.lang.StringBuilder $r1, $r2, $r3, $r4, $r5, $r9, $r10, $r11, $r12, $r13;
        java.lang.String $r6, $r14;

        this := @this: weka.classifiers.rules.JRip;

        rst := @parameter0: double[];

        minDL := @parameter1: double;

        dl := @parameter2: double;

        $d0 = <weka.classifiers.rules.JRip: double MAX_DL_SURPLUS>;

        $d1 = minDL + $d0;

        $b0 = dl cmpl $d1;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b0);

        if $b0 <= 0 goto label2;

        $z0 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label1;

        $r0 = <java.lang.System: java.io.PrintStream err>;

        $r1 = new java.lang.StringBuilder;

        specialinvoke $r1.<java.lang.StringBuilder: void <init>()>();

        $r2 = virtualinvoke $r1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("DL too large: ");

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(dl);

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" | ");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>(minDL);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>($r6);

     label1:
        return 1;

     label2:
        $d2 = rst[2];

        $z1 = staticinvoke <weka.core.Utils: boolean gr(double,double)>($d2, 0.0);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z1);

        if $z1 != 0 goto label4;

        $z2 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z2);

        if $z2 == 0 goto label3;

        $r7 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r7.<java.io.PrintStream: void println(java.lang.String)>("Too few positives.");

     label3:
        return 1;

     label4:
        $d3 = rst[4];

        $d4 = rst[0];

        $d5 = $d3 / $d4;

        $b1 = $d5 cmpl 0.5;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($b1);

        if $b1 < 0 goto label7;

        $z3 = this.<weka.classifiers.rules.JRip: boolean m_CheckErr>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z3);

        if $z3 == 0 goto label6;

        $z4 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z4);

        if $z4 == 0 goto label5;

        $r8 = <java.lang.System: java.io.PrintStream err>;

        $r9 = new java.lang.StringBuilder;

        specialinvoke $r9.<java.lang.StringBuilder: void <init>()>();

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Error too large: ");

        $d6 = rst[4];

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d6);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("/");

        $d7 = rst[0];

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d7);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r8.<java.io.PrintStream: void println(java.lang.String)>($r14);

     label5:
        return 1;

     label6:
        return 0;

     label7:
        $z5 = this.<weka.classifiers.rules.JRip: boolean m_Debug>;

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z5);

        if $z5 == 0 goto label8;

        $r15 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r15.<java.io.PrintStream: void println(java.lang.String)>("Continue.");

     label8:
        return 0;
    }

    public double[] distributionForInstance(weka.core.Instance)
    {
        weka.classifiers.rules.JRip this;
        weka.core.Instance datum;
        weka.classifiers.rules.Rule rule;
        java.lang.Throwable e, $r6;
        int i#2, $i0, $i1;
        java.util.ArrayList $r0, $r1, $r3;
        java.lang.Object $r2, $r4;
        boolean $z0;
        double[] $r5, $r11;
        java.io.PrintStream $r7, $r9;
        java.lang.String $r8;
        weka.core.Attribute $r10;
        java.lang.Exception tmp$517441220, tmp$1855001503;

        this := @this: weka.classifiers.rules.JRip;

        datum := @parameter0: weka.core.Instance;

     label1:
        i#2 = 0;

     label2:
        $r0 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        $i0 = virtualinvoke $r0.<java.util.ArrayList: int size()>();

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>(i#2);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($i0);

        if i#2 >= $i0 goto label5;

        $r1 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Ruleset>;

        $r2 = virtualinvoke $r1.<java.util.ArrayList: java.lang.Object get(int)>(i#2);

        rule = (weka.classifiers.rules.Rule) $r2;

        $z0 = virtualinvoke rule.<weka.classifiers.rules.Rule: boolean covers(weka.core.Instance)>(datum);

        staticinvoke <edu.cmu.cs.mvelezce.analysis.option.Sink: void sink(java.lang.Object)>($z0);

        if $z0 == 0 goto label4;

        $r3 = this.<weka.classifiers.rules.JRip: java.util.ArrayList m_Distributions>;

        $r4 = virtualinvoke $r3.<java.util.ArrayList: java.lang.Object get(int)>(i#2);

        $r5 = (double[]) $r4;

     label3:
        return $r5;

     label4:
        i#2 = i#2 + 1;

        goto label2;

     label5:
        goto label7;

     label6:
        $r6 := @caughtexception;

        e = $r6;

        $r7 = <java.lang.System: java.io.PrintStream err>;

        tmp$517441220 = (java.lang.Exception) e;

        $r8 = virtualinvoke tmp$517441220.<java.lang.Exception: java.lang.String getMessage()>();

        virtualinvoke $r7.<java.io.PrintStream: void println(java.lang.String)>($r8);

        tmp$1855001503 = (java.lang.Exception) e;

        virtualinvoke tmp$1855001503.<java.lang.Exception: void printStackTrace()>();

     label7:
        $r9 = <java.lang.System: java.io.PrintStream err>;

        virtualinvoke $r9.<java.io.PrintStream: void println(java.lang.String)>("Should never happen!");

        $r10 = interfaceinvoke datum.<weka.core.Instance: weka.core.Attribute classAttribute()>();

        $i1 = virtualinvoke $r10.<weka.core.Attribute: int numValues()>();

        $r11 = newarray (double)[$i1];

        return $r11;

        catch java.lang.Exception from label1 to label3 with label6;
        catch java.lang.Exception from label4 to label5 with label6;
    }

    public void setOptions(java.lang.String[]) throws java.lang.Exception
    {
        weka.classifiers.rules.JRip this;
        java.lang.String[] options;

        this := @this: weka.classifiers.rules.JRip;

        options := @parameter0: java.lang.String[];

        return;
    }

    public java.util.Enumeration listOptions()
    {
        weka.classifiers.rules.JRip this;
        java.util.Vector newVector, $r0;
        weka.core.Option $r1, $r2, $r3, $r4, $r5, $r6, $r7;
        java.util.Enumeration $r8, $r10;
        java.util.ArrayList $r9;

        this := @this: weka.classifiers.rules.JRip;

        $r0 = new java.util.Vector;

        specialinvoke $r0.<java.util.Vector: void <init>(int)>(7);

        newVector = $r0;

        $r1 = new weka.core.Option;

        specialinvoke $r1.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tSet number of folds for REP\n\tOne fold is used as pruning set.\n\t(default 3)", "F", 1, "-F <number of folds>");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r1);

        $r2 = new weka.core.Option;

        specialinvoke $r2.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tSet the minimal weights of instances\n\twithin a split.\n\t(default 2.0)", "N", 1, "-N <min. weights>");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r2);

        $r3 = new weka.core.Option;

        specialinvoke $r3.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tSet the number of runs of\n\toptimizations. (Default: 2)", "O", 1, "-O <number of runs>");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r3);

        $r4 = new weka.core.Option;

        specialinvoke $r4.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tSet whether turn on the\n\tdebug mode (Default: false)", "D", 0, "-D");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r4);

        $r5 = new weka.core.Option;

        specialinvoke $r5.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tThe seed of randomization\n\t(Default: 1)", "S", 1, "-S <seed>");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r5);

        $r6 = new weka.core.Option;

        specialinvoke $r6.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tWhether NOT check the error rate>=0.5\n\tin stopping criteria \t(default: check)", "E", 0, "-E");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r6);

        $r7 = new weka.core.Option;

        specialinvoke $r7.<weka.core.Option: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>("\tWhether NOT use pruning\n\t(default: use pruning)", "P", 0, "-P");

        virtualinvoke newVector.<java.util.Vector: boolean add(java.lang.Object)>($r7);

        $r8 = specialinvoke this.<weka.classifiers.AbstractClassifier: java.util.Enumeration listOptions()>();

        $r9 = staticinvoke <java.util.Collections: java.util.ArrayList list(java.util.Enumeration)>($r8);

        virtualinvoke newVector.<java.util.Vector: boolean addAll(java.util.Collection)>($r9);

        $r10 = virtualinvoke newVector.<java.util.Vector: java.util.Enumeration elements()>();

        return $r10;
    }


