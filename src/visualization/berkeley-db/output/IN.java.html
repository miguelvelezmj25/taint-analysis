<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>IN.java</title>
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700" rel="stylesheet">
</head>
<body>

<div class="container">
    <div id="code_area" class="container_0">
<div>1&emsp;&emsp;/*-</div>
<div>2&emsp;&emsp;&nbsp; * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</div>
<div>3&emsp;&emsp;&nbsp; *</div>
<div>4&emsp;&emsp;&nbsp; * This file was distributed by Oracle as part of a version of Oracle Berkeley</div>
<div>5&emsp;&emsp;&nbsp; * DB Java Edition made available at:</div>
<div>6&emsp;&emsp;&nbsp; *</div>
<div>7&emsp;&emsp;&nbsp; * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</div>
<div>8&emsp;&emsp;&nbsp; *</div>
<div>9&emsp;&emsp;&nbsp; * Please see the LICENSE file included in the top-level directory of the</div>
<div>10&emsp;&emsp;&nbsp; * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</div>
<div>11&emsp;&emsp;&nbsp; * license and additional information.</div>
<div>12&emsp;&emsp;&nbsp; */</div>
<div>13&emsp;&emsp;</div>
<div>14&emsp;&emsp;package berkeley.com.sleepycat.je.tree;</div>
<div>15&emsp;&emsp;</div>
<div>16&emsp;&emsp;import static berkeley.com.sleepycat.je.EnvironmentFailureException.unexpectedState;</div>
<div>17&emsp;&emsp;</div>
<div>18&emsp;&emsp;import java.io.FileNotFoundException;</div>
<div>19&emsp;&emsp;import java.nio.ByteBuffer;</div>
<div>20&emsp;&emsp;import java.util.Arrays;</div>
<div>21&emsp;&emsp;import java.util.Comparator;</div>
<div>22&emsp;&emsp;import java.util.logging.Level;</div>
<div>23&emsp;&emsp;import java.util.logging.Logger;</div>
<div>24&emsp;&emsp;</div>
<div>25&emsp;&emsp;import berkeley.com.sleepycat.je.CacheMode;</div>
<div>26&emsp;&emsp;import berkeley.com.sleepycat.je.DatabaseException;</div>
<div>27&emsp;&emsp;import berkeley.com.sleepycat.je.EnvironmentFailureException;</div>
<div>28&emsp;&emsp;import berkeley.com.sleepycat.je.cleaner.PackedObsoleteInfo;</div>
<div>29&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.DatabaseId;</div>
<div>30&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.DatabaseImpl;</div>
<div>31&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.DbTree;</div>
<div>32&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.EnvironmentFailureReason;</div>
<div>33&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.EnvironmentImpl;</div>
<div>34&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.INList;</div>
<div>35&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.MemoryBudget;</div>
<div>36&emsp;&emsp;import berkeley.com.sleepycat.je.dbi.TTL;</div>
<div>37&emsp;&emsp;import berkeley.com.sleepycat.je.evictor.Evictor;</div>
<div>38&emsp;&emsp;import berkeley.com.sleepycat.je.evictor.OffHeapCache;</div>
<div>39&emsp;&emsp;import berkeley.com.sleepycat.je.latch.LatchContext;</div>
<div>40&emsp;&emsp;import berkeley.com.sleepycat.je.latch.LatchFactory;</div>
<div>41&emsp;&emsp;import berkeley.com.sleepycat.je.latch.LatchSupport;</div>
<div>42&emsp;&emsp;import berkeley.com.sleepycat.je.latch.LatchTable;</div>
<div>43&emsp;&emsp;import berkeley.com.sleepycat.je.latch.SharedLatch;</div>
<div>44&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogEntryType;</div>
<div>45&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogItem;</div>
<div>46&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogParams;</div>
<div>47&emsp;&emsp;import berkeley.com.sleepycat.je.log.LogUtils;</div>
<div>48&emsp;&emsp;import berkeley.com.sleepycat.je.log.Loggable;</div>
<div>49&emsp;&emsp;import berkeley.com.sleepycat.je.log.Provisional;</div>
<div>50&emsp;&emsp;import berkeley.com.sleepycat.je.log.ReplicationContext;</div>
<div>51&emsp;&emsp;import berkeley.com.sleepycat.je.log.WholeEntry;</div>
<div>52&emsp;&emsp;import berkeley.com.sleepycat.je.log.entry.BINDeltaLogEntry;</div>
<div>53&emsp;&emsp;import berkeley.com.sleepycat.je.log.entry.INLogEntry;</div>
<div>54&emsp;&emsp;import berkeley.com.sleepycat.je.log.entry.LNLogEntry;</div>
<div>55&emsp;&emsp;import berkeley.com.sleepycat.je.log.entry.LogEntry;</div>
<div>56&emsp;&emsp;import berkeley.com.sleepycat.je.tree.dupConvert.DBIN;</div>
<div>57&emsp;&emsp;import berkeley.com.sleepycat.je.tree.dupConvert.DIN;</div>
<div>58&emsp;&emsp;import berkeley.com.sleepycat.je.tree.dupConvert.DupConvert;</div>
<div>59&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.DbLsn;</div>
<div>60&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.LoggerUtils;</div>
<div>61&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.SizeofMarker;</div>
<div>62&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.TestHook;</div>
<div>63&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.TestHookExecute;</div>
<div>64&emsp;&emsp;import berkeley.com.sleepycat.je.utilint.VLSN;</div>
<div>65&emsp;&emsp;</div>
<div>66&emsp;&emsp;/**</div>
<div>67&emsp;&emsp;&nbsp; * An IN represents an Internal Node in the JE tree.</div>
<div>68&emsp;&emsp;&nbsp; *</div>
<div>69&emsp;&emsp;&nbsp; * Explanation of KD (KnownDeleted) and PD (PendingDelete) entry flags</div>
<div>70&emsp;&emsp;&nbsp; * ===================================================================</div>
<div>71&emsp;&emsp;&nbsp; *</div>
<div>72&emsp;&emsp;&nbsp; * PD: set for all LN entries that are deleted, even before the LN is</div>
<div>73&emsp;&emsp;&nbsp; * committed.  Is used as an authoritative (transactionally correct) indication</div>
<div>74&emsp;&emsp;&nbsp; * that an LN is deleted. PD will be cleared if the txn for the deleted LN is</div>
<div>75&emsp;&emsp;&nbsp; * aborted.</div>
<div>76&emsp;&emsp;&nbsp; *</div>
<div>77&emsp;&emsp;&nbsp; * KD: set under special conditions for entries containing LNs which are known</div>
<div>78&emsp;&emsp;&nbsp; * to be obsolete.  Not used for entries in an active/uncommitted transaction.</div>
<div>79&emsp;&emsp;&nbsp; *</div>
<div>80&emsp;&emsp;&nbsp; * First notice that IN.fetchLN will allow a FileNotFoundException when the</div>
<div>81&emsp;&emsp;&nbsp; * PD or KD flag is set on the entry.  And it will allow a NULL_LSN when the KD</div>
<div>82&emsp;&emsp;&nbsp; * flag is set.</div>
<div>83&emsp;&emsp;&nbsp; *</div>
<div>84&emsp;&emsp;&nbsp; * KD was implemented first, and was originally used when the cleaner attempts</div>
<div>85&emsp;&emsp;&nbsp; * to migrate an LN and discovers it is deleted (see Cleaner.migrateLN). We</div>
<div>86&emsp;&emsp;&nbsp; * need KD because the INCompressor may not have run, and may not have</div>
<div>87&emsp;&emsp;&nbsp; * compressed the BIN. There's the danger that we'll try to fetch that entry,</div>
<div>88&emsp;&emsp;&nbsp; * and that the file was deleted by the cleaner.</div>
<div>89&emsp;&emsp;&nbsp; *</div>
<div>90&emsp;&emsp;&nbsp; * KD was used more recently when an unexpected exception occurs while logging</div>
<div>91&emsp;&emsp;&nbsp; * an LN, after inserting the entry.  Rather than delete the entry to clean up,</div>
<div>92&emsp;&emsp;&nbsp; * we mark the entry KD so it won't cause a fetch error later.  In this case</div>
<div>93&emsp;&emsp;&nbsp; * the entry LSN is NULL_LSN. See Tree.insertNewSlot.</div>
<div>94&emsp;&emsp;&nbsp; *</div>
<div>95&emsp;&emsp;&nbsp; * PD is closely related to the first use of KD above (for cleaned deleted LNs)</div>
<div>96&emsp;&emsp;&nbsp; * and came about because of a cleaner optimization we make. The cleaner</div>
<div>97&emsp;&emsp;&nbsp; * considers all deleted LN log entries to be obsolete, without doing a tree</div>
<div>98&emsp;&emsp;&nbsp; * lookup, and without any record of an obsolete offset.  This makes the cost</div>
<div>99&emsp;&emsp;&nbsp; * of cleaning of deleted LNs very low.  For example, if the log looks like</div>
<div>100&emsp;&emsp;&nbsp; * this:</div>
<div>101&emsp;&emsp;&nbsp; *</div>
<div>102&emsp;&emsp;&nbsp; * 100  LNA</div>
<div>103&emsp;&emsp;&nbsp; * 200  delete of LNA</div>
<div>104&emsp;&emsp;&nbsp; *</div>
<div>105&emsp;&emsp;&nbsp; * then LSN 200 will be considered obsolete when this file is processed by the</div>
<div>106&emsp;&emsp;&nbsp; * cleaner. After all, only two things can happen: (1) the txn commits, and we</div>
<div>107&emsp;&emsp;&nbsp; * don't need LSN 200, because we can wipe this LN out of the tree, or (2) the</div>
<div>108&emsp;&emsp;&nbsp; * txn aborts, and we don't need LSN 200, because we are going to revert to LSN</div>
<div>109&emsp;&emsp;&nbsp; * 100/LNA.</div>
<div>110&emsp;&emsp;&nbsp; *</div>
<div>111&emsp;&emsp;&nbsp; * We set PD for the entry of a deleted LN at the time of the operation, and we</div>
<div>112&emsp;&emsp;&nbsp; * clear PD if the transaction aborts.  There is no real danger that this log</div>
<div>113&emsp;&emsp;&nbsp; * entry will be processed by the cleaner before it's committed, because</div>
<div>114&emsp;&emsp;&nbsp; * cleaning can only happen after the first active LSN.</div>
<div>115&emsp;&emsp;&nbsp; *</div>
<div>116&emsp;&emsp;&nbsp; * Just as in the first use of KD above, setting PD is necessary to avoid a</div>
<div>117&emsp;&emsp;&nbsp; * fetch error, when the file is deleted by the cleaner but the entry</div>
<div>118&emsp;&emsp;&nbsp; * containing the deleted LN has not been deleted by the INCompressor.</div>
<div>119&emsp;&emsp;&nbsp; *</div>
<div>120&emsp;&emsp;&nbsp; * PD is also set in replication rollback, when LNs are marked as</div>
<div>121&emsp;&emsp;&nbsp; * invisible.</div>
<div>122&emsp;&emsp;&nbsp; *</div>
<div>123&emsp;&emsp;&nbsp; * When LSN locking was implemented (see CursorImpl.lockLN), the PD flag took</div>
<div>124&emsp;&emsp;&nbsp; * on additional meaning.  PD is used to determine whether an LN is deleted</div>
<div>125&emsp;&emsp;&nbsp; * without fetching it, and therefore is relied on to be transactionally</div>
<div>126&emsp;&emsp;&nbsp; * correct.</div>
<div>127&emsp;&emsp;&nbsp; *</div>
<div>128&emsp;&emsp;&nbsp; * In addition to the setting and use of the KD/PD flags described above, the</div>
<div>129&emsp;&emsp;&nbsp; * situation is complicated by the fact that we must restore the state of these</div>
<div>130&emsp;&emsp;&nbsp; * flags during abort, recovery, and set them properly during slot reuse.</div>
<div>131&emsp;&emsp;&nbsp; *</div>
<div>132&emsp;&emsp;&nbsp; * We have been meaning to consider whether PD and KD can be consolidated into</div>
<div>133&emsp;&emsp;&nbsp; * one flag: simply the Deleted flag.  The Deleted flag would be set in the</div>
<div>134&emsp;&emsp;&nbsp; * same way as PD is currently set, as well as the second use of KD described</div>
<div>135&emsp;&emsp;&nbsp; * above (when the LSN is NULL_LSN after an insertion error).  The use of KD</div>
<div>136&emsp;&emsp;&nbsp; * and PD for invisible entries and recovery rollback should also be</div>
<div>137&emsp;&emsp;&nbsp; * considered.</div>
<div>138&emsp;&emsp;&nbsp; *</div>
<div>139&emsp;&emsp;&nbsp; * If we consolidate the two flags and set the Deleted flag during a delete</div>
<div>140&emsp;&emsp;&nbsp; * operation (like PD), we'll have to remove optimizations (in CursorImpl for</div>
<div>141&emsp;&emsp;&nbsp; * example) that consider a slot deleted when KD is set.  Since KD is rarely</div>
<div>142&emsp;&emsp;&nbsp; * set currently, this shouldn't have a noticeable performance impact.</div>
<div>143&emsp;&emsp;&nbsp; */</div>
<div style="background-color:limegreen;">144&emsp;&emsp;<b>public class IN extends Node implements Comparable&#60;IN>, LatchContext {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>145&emsp;&emsp;</div>
<div>146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String BEGIN_TAG = "&#60;in>";</div>
<div>147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String END_TAG = "&#60;/in>";</div>
<div>148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String TRACE_SPLIT = "Split:";</div>
<div>149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final String TRACE_DELETE = "Delete:";</div>
<div>150&emsp;&emsp;</div>
<div>151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int BYTES_PER_LSN_ENTRY = 4;</div>
<div>152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int MAX_FILE_OFFSET = 0xfffffe;</div>
<div>153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int THREE_BYTE_NEGATIVE_ONE = 0xffffff;</div>
<div>154&emsp;&emsp;</div>
<div>155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used as the "empty rep" for the INLongRep offHeapBINIds field.</div>
<div>157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minLength is 3 because BIN IDs are LRU list indexes. Initially 100k</div>
<div>159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * indexes are allocated and the largest values are used first.</div>
<div>160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * allowSparseRep is true because some workloads will only load BIN IDs for</div>
<div>162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a subset of the BINs in the IN.</div>
<div>163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final INLongRep.EmptyRep EMPTY_OFFHEAP_BIN_IDS =</div>
<div>165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        new INLongRep.EmptyRep(3, true);</div>
<div>166&emsp;&emsp;</div>
<div>167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Levels:</div>
<div>169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The mapping tree has levels in the 0x20000 -> 0x2ffff number space.</div>
<div>170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The main tree has levels in the 0x10000 -> 0x1ffff number space.</div>
<div>171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The duplicate tree levels are in 0-> 0xffff number space.</div>
<div>172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int DBMAP_LEVEL = 0x20000;</div>
<div>174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int MAIN_LEVEL = 0x10000;</div>
<div>175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int LEVEL_MASK = 0x0ffff;</div>
<div>176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int MIN_LEVEL = -1;</div>
<div>177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int BIN_LEVEL = MAIN_LEVEL | 1;</div>
<div>178&emsp;&emsp;</div>
<div>179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Used to indicate that an exact match was found in findEntry. */</div>
<div>180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int EXACT_MATCH = (1 &#60;&#60; 16);</div>
<div>181&emsp;&emsp;</div>
<div>182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Used to indicate that an insert was successful. */</div>
<div>183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int INSERT_SUCCESS = (1 &#60;&#60; 17);</div>
<div>184&emsp;&emsp;</div>
<div>185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * A bit flag set in the return value of partialEviction() to indicate</div>
<div>187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * whether the IN is evictable or not.</div>
<div>188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final long NON_EVICTABLE_IN = (1L &#60;&#60; 62);</div>
<div>190&emsp;&emsp;</div>
<div>191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Boolean properties of an IN, encoded as bits inside the flags</div>
<div>193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * data member.</div>
<div>194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_DIRTY_BIT = 0x1;</div>
<div>196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_RECALC_TOGGLE_BIT = 0x2;</div>
<div>197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_IS_ROOT_BIT = 0x4;</div>
<div>198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_HAS_CACHED_CHILDREN_BIT = 0x8;</div>
<div>199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_PRI2_LRU_BIT = 0x10;</div>
<div>200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_DELTA_BIT = 0x20;</div>
<div>201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_FETCHED_COLD_BIT = 0x40;</div>
<div>202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_FETCHED_COLD_OFFHEAP_BIT = 0x80;</div>
<div>203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_RESIDENT_BIT = 0x100;</div>
<div>204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_PROHIBIT_NEXT_DELTA_BIT = 0x200;</div>
<div>205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final int IN_EXPIRATION_IN_HOURS = 0x400;</div>
<div>206&emsp;&emsp;</div>
<div>207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Tracing for LRU-related ops */</div>
<div>208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final boolean traceLRU = false;</div>
<div>209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final boolean traceDeltas = false;</div>
<div>210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static final Level traceLevel = Level.INFO;</div>
<div>211&emsp;&emsp;</div>
<div>212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    DatabaseImpl databaseImpl;</div>
<div>213&emsp;&emsp;</div>
<div>214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int level;</div>
<div>215&emsp;&emsp;</div>
<div>216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* The unique id of this node. */</div>
<div>217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long nodeId;</div>
<div>218&emsp;&emsp;</div>
<div>219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Some bits are persistent and some are not, see serialize. */</div>
<div>220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int flags;</div>
<div>221&emsp;&emsp;</div>
<div>222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The identifier key is a key that can be used used to search for this IN.</div>
<div>224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Initially it is the key of the zeroth slot, but insertions prior to slot</div>
<div>225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * zero make this no longer true.  It is always equal to some key in the</div>
<div>226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * IN, and therefore it is changed by BIN.compress when removing slots.</div>
<div>227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private byte[] identifierKey;</div>
<div>229&emsp;&emsp;</div>
<div>230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int nEntries;</div>
<div>231&emsp;&emsp;</div>
<div>232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    byte[] entryStates;</div>
<div>233&emsp;&emsp;</div>
<div>234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * entryKeys contains the keys in their entirety if key prefixing is not</div>
<div>236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * being used. If prefixing is enabled, then keyPrefix contains the prefix</div>
<div>237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and entryKeys contains the suffixes. Records with small enough data</div>
<div>238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (smaller than the value je.tree.maxEmbeddedLN param) are stored in</div>
<div>239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * their entirity (both key (or key suffix) and data) inside BINs. This is</div>
<div>240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * done by combining the record key and data as a two-part key (see the</div>
<div>241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * dbi/DupKeyData class) and storing the resulting array in entryKeys.</div>
<div>242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * A special case is when the record to be embedded has no data. Then,</div>
<div>243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the two-part key format is not used, but instead the NO_DATA_LN_BIT</div>
<div>244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is turned on in the slot's state. This saves the space overhead of</div>
<div>245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * using the two-part key format.</div>
<div>246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    INKeyRep entryKeys;</div>
<div>248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    byte[] keyPrefix;</div>
<div>249&emsp;&emsp;</div>
<div>250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The following entryLsnXXX fields are used for storing LSNs.  There are</div>
<div>252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * two possible representations: a byte array based rep, and a long array</div>
<div>253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * based one.  For compactness, the byte array rep is used initially.  A</div>
<div>254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * single byte[] that uses four bytes per LSN is used. The baseFileNumber</div>
<div>255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * field contains the lowest file number of any LSN in the array.  Then for</div>
<div>256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * each entry (four bytes each), the first byte contains the offset from</div>
<div>257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the baseFileNumber of that LSN's file number.  The remaining three bytes</div>
<div>258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * contain the file offset portion of the LSN.  Three bytes will hold a</div>
<div>259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * maximum offset of 16,777,214 (0xfffffe), so with the default JE log file</div>
<div>260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * size of 10,000,000 bytes this works well.</div>
<div>261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If either (1) the difference in file numbers exceeds 127</div>
<div>263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (Byte.MAX_VALUE) or (2) the file offset is greater than 16,777,214, then</div>
<div>264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the byte[] based rep mutates to a long[] based rep.</div>
<div>265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In the byte[] rep, DbLsn.NULL_LSN is represented by setting the file</div>
<div>267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * offset bytes for a given entry to -1 (0xffffff).</div>
<div>268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note: A compact representation will be changed to the non-compact one,</div>
<div>270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if needed, but in the current implementation, the reverse mutation</div>
<div>271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (from long to compact) never takes place.</div>
<div>272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long baseFileNumber;</div>
<div>274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    byte[] entryLsnByteArray;</div>
<div>275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long[] entryLsnLongArray;</div>
<div>276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static boolean disableCompactLsns; // DbCacheSize only</div>
<div>277&emsp;&emsp;</div>
<div>278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The children of this IN. Only the ones that are actually in the cache</div>
<div>280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * have non-null entries. Specialized sparse array represents are used to</div>
<div>281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * represent the entries. The representation can mutate as modifications</div>
<div>282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * are made to it.</div>
<div>283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    INTargetRep entryTargets;</div>
<div>285&emsp;&emsp;</div>
<div>286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In a level 2 IN, the LRU IDs of the child BINs.</div>
<div>288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private INLongRep offHeapBINIds = EMPTY_OFFHEAP_BIN_IDS;</div>
<div>290&emsp;&emsp;</div>
<div>291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long inMemorySize;</div>
<div>292&emsp;&emsp;</div>
<div>293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * accumluted memory budget delta.  Once this exceeds</div>
<div>295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * MemoryBudget.ACCUMULATED_LIMIT we inform the MemoryBudget that a change</div>
<div>296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * has occurred.  See SR 12273.</div>
<div>297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int accumulatedDelta = 0;</div>
<div>299&emsp;&emsp;</div>
<div>300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Max allowable accumulation of memory budget changes before MemoryBudget</div>
<div>302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * should be updated. This allows for consolidating multiple calls to</div>
<div>303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * updateXXXMemoryBudget() into one call.  Not declared final so that the</div>
<div>304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * unit tests can modify it.  See SR 12273.</div>
<div>305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static final int ACCUMULATED_LIMIT_DEFAULT = 1000;</div>
<div>307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static int ACCUMULATED_LIMIT = ACCUMULATED_LIMIT_DEFAULT;</div>
<div>308&emsp;&emsp;</div>
<div>309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * References to the next and previous nodes in an LRU list. If the node</div>
<div>311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is not in any LRUList, both of these will be null. If the node is at</div>
<div>312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the front/back of an LRUList, prevLRUNode/nextLRUNode will point to</div>
<div>313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the node itself.</div>
<div>314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private IN nextLRUNode = null;</div>
<div>316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private IN prevLRUNode = null;</div>
<div>317&emsp;&emsp;</div>
<div>318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Let L be the most recently written logrec for this IN instance.</div>
<div>320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (a) If this is a UIN, lastFullVersion is the lsn of L.</div>
<div>321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (b) If this is a BIN instance and L is a full-version logrec,</div>
<div>322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *     lastFullVersion is the lsn of L.</div>
<div>323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (c) If this is a BIN instance and L is a delta logrec, lastFullVersion</div>
<div>324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *     is the lsn of the most recently written full-version logrec for the</div>
<div>325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *     same BIN.</div>
<div>326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It is set in 2 cases:</div>
<div>328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (a) after "this" is created via reading a logrec L, lastFullVersion is</div>
<div>330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * set to L's lsn, if L is a UIN or a full BIN. (this is done in</div>
<div>331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * IN.postFetch/RecoveryInit(), via IN.setLastLoggedLsn()). If L is a BIN</div>
<div>332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * delta, lastFullVersion is set by BINDeltaLogEntry.readEntry() to</div>
<div>333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * L.prevFullLsn.</div>
<div>334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (b) After logging a UIN or a full-BIN logrec, it is set to the LSN of</div>
<div>336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the logrec written. This is done in IN.afterLog().</div>
<div>337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Notice that this is a persistent field, but except from case (c), when</div>
<div>339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * reading a logrec L, it is set not to the value found in L, but to the</div>
<div>340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * lsn of L. This is why its read/write is managed by the INLogEntry class</div>
<div>341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * rather than the IN readFromLog/writeFromLog methods.</div>
<div>342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long lastFullVersion = DbLsn.NULL_LSN;</div>
<div>344&emsp;&emsp;</div>
<div>345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BINs have a lastDeltaVersion data field as well, which is defined as</div>
<div>347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * follows:</div>
<div>348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Let L be the most recently written logrec for this BIN instance. If</div>
<div>350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * L is a full-version logrec, lastDeltaVersion is NULL; otherwise it</div>
<div>351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is the lsn of L.</div>
<div>352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It is used for obsolete tracking.</div>
<div>354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It is set in 2 cases:</div>
<div>356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (a) after "this" is created via reading a logrec L, lastDeltaVersion</div>
<div>358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is set to L's lsn, if L is a BIN-delta logrec, or to NULL if L is a</div>
<div>359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * full-BIN logrec (this is done in IN.postFetch/RecoveryInit(), via</div>
<div>360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN.setLastLoggedLsn()).</div>
<div>361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (b) After we write a logrec L for this BIN instance, lastDeltaVersion</div>
<div>363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is set to NULL if L is a full-BIN logrec, or to L's lsn, if L is a</div>
<div>364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN-delta logrec (this is done in BIN.afterLog()).</div>
<div>365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Notice that this is a persistent field, but when reading a logrec L,</div>
<div>367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * it is set not to the value found in L, but to the lsn of L. This is why</div>
<div>368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * its read/write is managed by the INLogEntry class rather than the IN</div>
<div>369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * readFromLog/writeFromLog methods.</div>
<div>370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * private long lastDeltaVersion = DbLsn.NULL_LSN;</div>
<div>372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>373&emsp;&emsp;</div>
<div>374&emsp;&emsp;</div>
<div>375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * A sequence of obsolete info that cannot be counted as obsolete until an</div>
<div>377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * ancestor IN is logged non-provisionally.</div>
<div>378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private PackedObsoleteInfo provisionalObsolete;</div>
<div>380&emsp;&emsp;</div>
<div>381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* See convertDupKeys. */</div>
<div>382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean needDupKeyConversion;</div>
<div>383&emsp;&emsp;</div>
<div>384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int pinCount = 0;</div>
<div>385&emsp;&emsp;</div>
<div>386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private SharedLatch latch;</div>
<div>387&emsp;&emsp;</div>
<div>388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private IN parent;</div>
<div>389&emsp;&emsp;</div>
<div>390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private TestHook fetchINHook;</div>
<div>391&emsp;&emsp;</div>
<div>392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Create an empty IN, with no node ID, to be filled in from the log.</div>
<div>394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN() {</div>
<div>396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        init(null, Key.EMPTY_KEY, 0, 0);</div>
<div>397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>398&emsp;&emsp;</div>
<div>399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Create a new IN.</div>
<div>401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN(</div>
<div>403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        DatabaseImpl dbImpl,</div>
<div>404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] identifierKey,</div>
<div>405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int capacity,</div>
<div>406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int level) {</div>
<div>407&emsp;&emsp;</div>
<div>408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nodeId = dbImpl.getEnv().getNodeSequence().getNextLocalNodeId();</div>
<div>409&emsp;&emsp;</div>
<div>410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        init(dbImpl, identifierKey, capacity,</div>
<div>411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            generateLevel(dbImpl.getId(), level));</div>
<div>412&emsp;&emsp;</div>
<div>413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        initMemorySize();</div>
<div>414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>415&emsp;&emsp;</div>
<div>416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For Sizeof.</div>
<div>418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN(@SuppressWarnings("unused") SizeofMarker marker) {</div>
<div>420&emsp;&emsp;</div>
<div>421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Set all variable fields to null, since they are not part of the</div>
<div>423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * fixed overhead.</div>
<div>424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = null;</div>
<div>426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = null;</div>
<div>427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        keyPrefix = null;</div>
<div>428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray = null;</div>
<div>429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnLongArray = null;</div>
<div>430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates = null;</div>
<div>431&emsp;&emsp;</div>
<div>432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch = LatchFactory.createSharedLatch(</div>
<div>433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LatchSupport.DUMMY_LATCH_CONTEXT, isAlwaysLatchedExclusively());</div>
<div>434&emsp;&emsp;</div>
<div>435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Use the latch to force it to grow to "runtime size".</div>
<div>437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.acquireExclusive();</div>
<div>439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.release();</div>
<div>440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.acquireExclusive();</div>
<div>441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.release();</div>
<div>442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>443&emsp;&emsp;</div>
<div>444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Create a new IN.  Need this because we can't call newInstance() without</div>
<div>446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * getting a 0 for nodeId.</div>
<div>447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    IN createNewInstance(</div>
<div>449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] identifierKey,</div>
<div>450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int maxEntries,</div>
<div>451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int level) {</div>
<div>452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return new IN(databaseImpl, identifierKey, maxEntries, level);</div>
<div>453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>454&emsp;&emsp;</div>
<div>455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Initialize IN object.</div>
<div>457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected void init(</div>
<div>459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        DatabaseImpl db,</div>
<div>460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        @SuppressWarnings("hiding")</div>
<div>461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] identifierKey,</div>
<div>462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int initialCapacity,</div>
<div>463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        @SuppressWarnings("hiding")</div>
<div>464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int level) {</div>
<div>465&emsp;&emsp;</div>
<div>466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDatabase(db);</div>
<div>467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch = LatchFactory.createSharedLatch(</div>
<div>468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            this, isAlwaysLatchedExclusively());</div>
<div>469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        flags = 0;</div>
<div>470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nEntries = 0;</div>
<div>471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.identifierKey = identifierKey;</div>
<div>472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = INTargetRep.NONE;</div>
<div>473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = new INKeyRep.Default(initialCapacity);</div>
<div>474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        keyPrefix = null;</div>
<div>475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        baseFileNumber = -1;</div>
<div>476&emsp;&emsp;</div>
<div>477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Normally we start out with the compact LSN rep and then mutate to</div>
<div>479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the long rep when needed.  But for some purposes (DbCacheSize) we</div>
<div>480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * start out with the long rep and never use the compact rep.</div>
<div>481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (disableCompactLsns) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = null;</div>
<div>484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = new long[initialCapacity];</div>
<div>485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = new byte[initialCapacity &#60;&#60; 2];</div>
<div>487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = null;</div>
<div>488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>489&emsp;&emsp;</div>
<div>490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates = new byte[initialCapacity];</div>
<div>491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.level = level;</div>
<div>492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>493&emsp;&emsp;</div>
<div>494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isIN() {</div>
<div>496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>498&emsp;&emsp;</div>
<div>499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isUpperIN() {</div>
<div style="background-color:limegreen;">501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return !isBIN();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>503&emsp;&emsp;</div>
<div>504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final String getLatchName() {</div>
<div>506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return shortClassName() + getNodeId();</div>
<div>507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>508&emsp;&emsp;</div>
<div>509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getLatchTimeoutMs() {</div>
<div>511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getEnv().getLatchTimeoutMs();</div>
<div>512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>513&emsp;&emsp;</div>
<div>514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final LatchTable getLatchTable() {</div>
<div>516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return LatchSupport.btreeLatchTable;</div>
<div>517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>518&emsp;&emsp;</div>
<div>519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return whether the shared latch for this kind of node should be of the</div>
<div>521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * "always exclusive" variety.  Presently, only IN's are actually latched</div>
<div>522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * shared.  BINs are latched exclusive only.</div>
<div>523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isAlwaysLatchedExclusively() {</div>
<div>525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>527&emsp;&emsp;</div>
<div>528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node if it is not latched by another thread. Update the LRU</div>
<div>530&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * using the given cacheMode if the latch succeeds.</div>
<div>531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean latchNoWait(CacheMode cacheMode) {</div>
<div>533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (!latch.acquireExclusiveNoWait()) {</div>
<div>534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateLRU(cacheMode);</div>
<div>537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>539&emsp;&emsp;</div>
<div>540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node exclusive and update the LRU using the given cacheMode.</div>
<div>542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void latch(CacheMode cacheMode) {</div>
<div>544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.acquireExclusive();</div>
<div>545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateLRU(cacheMode);</div>
<div>546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>547&emsp;&emsp;</div>
<div>548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node exclusive and update the LRU using the default cacheMode.</div>
<div>550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void latch() {</div>
<div>552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch(CacheMode.DEFAULT);</div>
<div>553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>554&emsp;&emsp;</div>
<div>555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node shared and update the LRU using the given cacheMode.</div>
<div>557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void latchShared(CacheMode cacheMode) {</div>
<div>560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.acquireShared();</div>
<div>561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateLRU(cacheMode);</div>
<div>562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>563&emsp;&emsp;</div>
<div>564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node shared and update the LRU using the default cacheMode.</div>
<div>566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void latchShared() {</div>
<div>569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latchShared(CacheMode.DEFAULT);</div>
<div>570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>571&emsp;&emsp;</div>
<div>572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node exclusive and do not update the LRU or cause other</div>
<div>574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * related side effects.</div>
<div>575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param db is passed in order to initialize the database for an</div>
<div>577&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * uninitialized node, which is necessary in order to latch it.</div>
<div>578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void latchNoUpdateLRU(DatabaseImpl db) {</div>
<div style="background-color:limegreen;">580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (databaseImpl == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>581&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            databaseImpl = db;</div>
<div>582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.acquireExclusive();</div>
<div>584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>585&emsp;&emsp;</div>
<div>586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latch this node exclusive and do not update the LRU or cause other</div>
<div>588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * related side effects.</div>
<div>589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void latchNoUpdateLRU() {</div>
<div style="background-color:limegreen;">591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert databaseImpl != null;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.acquireExclusive();</div>
<div>593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>594&emsp;&emsp;</div>
<div>595&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Release the latch on this node.</div>
<div>597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>598&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void releaseLatch() {</div>
<div>600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.release();</div>
<div>601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>602&emsp;&emsp;</div>
<div>603&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Release the latch on this node if it is owned.</div>
<div>605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void releaseLatchIfOwner() {</div>
<div>607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        latch.releaseIfOwner();</div>
<div>608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>609&emsp;&emsp;</div>
<div>610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if this thread holds the IN's latch</div>
<div>612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>613&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isLatchOwner() {</div>
<div>614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return latch.isOwner();</div>
<div>615&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>616&emsp;&emsp;</div>
<div>617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isLatchExclusiveOwner() {</div>
<div>618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return latch.isExclusiveOwner();</div>
<div>619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>620&emsp;&emsp;</div>
<div>621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit testing. */</div>
<div>622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getLatchNWaiters() {</div>
<div>623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return latch.getNWaiters();</div>
<div>624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>625&emsp;&emsp;</div>
<div>626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void updateLRU(CacheMode cacheMode) {</div>
<div>627&emsp;&emsp;</div>
<div style="background-color:limegreen;">628&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!getInListResident()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>630&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>631&emsp;&emsp;</div>
<div style="background-color:limegreen;">632&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        switch (cacheMode) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>633&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        case UNCHANGED:</div>
<div>634&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        case MAKE_COLD:</div>
<div>635&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            break;</div>
<div>636&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        case DEFAULT:</div>
<div>637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        case EVICT_LN:</div>
<div>638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        case EVICT_BIN:</div>
<div>639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        case KEEP_HOT:</div>
<div>640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFetchedCold(false);</div>
<div>641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFetchedColdOffHeap(false);</div>
<div>642&emsp;&emsp;</div>
<div style="background-color:limegreen;">643&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isBIN() || !hasCachedChildrenFlag()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                assert(isBIN() || !hasCachedChildren());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>645&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getEvictor().moveBack(this);</div>
<div>646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            break;</div>
<div>648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        default:</div>
<div style="background-color:limegreen;">649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert false;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>652&emsp;&emsp;</div>
<div>653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>654&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method should be used carefully. Unless this node and the parent</div>
<div>655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * are already known to be latched, call latchParent instead to access the</div>
<div>656&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parent safely.</div>
<div>657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN getParent() {</div>
<div>659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return parent;</div>
<div>660&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>661&emsp;&emsp;</div>
<div>662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setParent(IN in) {</div>
<div style="background-color:limegreen;">663&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert in != null;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>664&emsp;&emsp;</div>
<div>665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Must hold EX-latch when changing a non-null parent. But when setting</div>
<div>667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the parent initially (it is currently null), we assume it is being</div>
<div>668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * attached and no other threads have access to it.</div>
<div>669&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (parent != null && !isLatchExclusiveOwner()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw unexpectedState();</div>
<div>672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>673&emsp;&emsp;</div>
<div>674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        parent = in;</div>
<div>675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>676&emsp;&emsp;</div>
<div>677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Latches the parent exclusively, leaving this node latched. The parent</div>
<div>679&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * must not already be latched.</div>
<div>680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This node must be latched on entry and will be latched on exit. This</div>
<div>682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * node's latch may be released temporarily, in which case it will be</div>
<div>683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * ex-latched (since the parent is ex-latched, this isn't a drawback).</div>
<div>684&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Does not perform cache mode processing, since this node is already</div>
<div>686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * latched.</div>
<div>687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the ex-latched parent, for which calling getKnownChildIndex with</div>
<div>689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * this node is guaranteed to succeed.</div>
<div>690&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @throws EnvironmentFailureException (fatal) if the parent latch is</div>
<div>692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * already held.</div>
<div>693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final IN latchParent() {</div>
<div>695&emsp;&emsp;</div>
<div>696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert latch.isOwner();</div>
<div>697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert !isRoot();</div>
<div>698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert getParent() != null;</div>
<div>699&emsp;&emsp;</div>
<div>700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        while (true) {</div>
<div>701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final IN p = getParent();</div>
<div>702&emsp;&emsp;</div>
<div>703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (p.latch.acquireExclusiveNoWait()) {</div>
<div>704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return p;</div>
<div>705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>706&emsp;&emsp;</div>
<div>707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            pin();</div>
<div>708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                latch.release();</div>
<div>710&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                p.latch.acquireExclusive();</div>
<div>711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                latch.acquireExclusive();</div>
<div>712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } finally {</div>
<div>713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                unpin();</div>
<div>714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>715&emsp;&emsp;</div>
<div>716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (getParent() == p) {</div>
<div>717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return p;</div>
<div>718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>719&emsp;&emsp;</div>
<div>720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            p.latch.release();</div>
<div>721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>723&emsp;&emsp;</div>
<div>724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the index of the given child. Should only be called when the</div>
<div>726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * caller knows that the given child is resident.</div>
<div>727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getKnownChildIndex(final Node child) {</div>
<div>729&emsp;&emsp;</div>
<div>730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; nEntries; i += 1) {</div>
<div>731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (getTarget(i) == child) {</div>
<div>732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return i;</div>
<div>733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>735&emsp;&emsp;</div>
<div>736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throw unexpectedState();</div>
<div>737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>738&emsp;&emsp;</div>
<div>739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final synchronized void pin() {</div>
<div style="background-color:limegreen;">740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isLatchOwner());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(pinCount >= 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ++pinCount;</div>
<div>743&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>744&emsp;&emsp;</div>
<div>745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final synchronized void unpin() {</div>
<div style="background-color:limegreen;">746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(pinCount > 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        --pinCount;</div>
<div>748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>749&emsp;&emsp;</div>
<div>750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final synchronized boolean isPinned() {</div>
<div style="background-color:limegreen;">751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isLatchExclusiveOwner());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(pinCount >= 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">753&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return pinCount > 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>755&emsp;&emsp;</div>
<div>756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the database for this IN.</div>
<div>758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>759&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final DatabaseImpl getDatabase() {</div>
<div>760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl;</div>
<div>761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>762&emsp;&emsp;</div>
<div>763&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set the database reference for this node.</div>
<div>765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setDatabase(DatabaseImpl db) {</div>
<div>767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        databaseImpl = db;</div>
<div>768&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>769&emsp;&emsp;</div>
<div>770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the database id for this node.</div>
<div>772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final DatabaseId getDatabaseId() {</div>
<div>774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getId();</div>
<div>775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>776&emsp;&emsp;</div>
<div>777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final EnvironmentImpl getEnvImplForFatalException() {</div>
<div>779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getEnv();</div>
<div>780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>781&emsp;&emsp;</div>
<div>782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final EnvironmentImpl getEnv() {</div>
<div>783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getEnv();</div>
<div>784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>785&emsp;&emsp;</div>
<div>786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final Evictor getEvictor() {</div>
<div>787&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getEnv().getEvictor();</div>
<div>788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>789&emsp;&emsp;</div>
<div>790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final OffHeapCache getOffHeapCache() {</div>
<div>791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getEnv().getOffHeapCache();</div>
<div>792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>793&emsp;&emsp;</div>
<div>794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Convenience method to return the database key comparator.</div>
<div>796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final Comparator&#60;byte[]> getKeyComparator() {</div>
<div>798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return databaseImpl.getKeyComparator();</div>
<div>799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>800&emsp;&emsp;</div>
<div>801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getLevel() {</div>
<div>803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return level;</div>
<div>804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>805&emsp;&emsp;</div>
<div>806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getNormalizedLevel() {</div>
<div>807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return level & LEVEL_MASK;</div>
<div>808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>809&emsp;&emsp;</div>
<div>810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static int generateLevel(DatabaseId dbId, int newLevel) {</div>
<div style="background-color:limegreen;">811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (dbId.equals(DbTree.ID_DB_ID)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return newLevel | DBMAP_LEVEL;</div>
<div>813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return newLevel | MAIN_LEVEL;</div>
<div>815&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>817&emsp;&emsp;</div>
<div>818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long getNodeId() {</div>
<div>819&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return nodeId;</div>
<div>820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>821&emsp;&emsp;</div>
<div>822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit tests only. */</div>
<div>823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void setNodeId(long nid) {</div>
<div>824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nodeId = nid;</div>
<div>825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>826&emsp;&emsp;</div>
<div>827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * We would like as even a hash distribution as possible so that the</div>
<div>829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Evictor's LRU is as accurate as possible.  ConcurrentHashMap takes the</div>
<div>830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * value returned by this method and runs its own hash algorithm on it.</div>
<div>831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * So a bit complement of the node ID is sufficient as the return value and</div>
<div>832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is a little better than returning just the node ID.  If we use a</div>
<div>833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * different container in the future that does not re-hash the return</div>
<div>834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * value, we should probably implement the Wang-Jenkins hash function here.</div>
<div>835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int hashCode() {</div>
<div>838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (int) ~getNodeId();</div>
<div>839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>840&emsp;&emsp;</div>
<div>841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean equals(Object obj) {</div>
<div>843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (!(obj instanceof IN)) {</div>
<div>844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN in = (IN) obj;</div>
<div>847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (this.getNodeId() == in.getNodeId());</div>
<div>848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>849&emsp;&emsp;</div>
<div>850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sort based on equality key.</div>
<div>852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int compareTo(IN argIN) {</div>
<div>854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long argNodeId = argIN.getNodeId();</div>
<div>855&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long myNodeId = getNodeId();</div>
<div>856&emsp;&emsp;</div>
<div>857&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (myNodeId &#60; argNodeId) {</div>
<div>858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return -1;</div>
<div>859&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else if (myNodeId > argNodeId) {</div>
<div>860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 1;</div>
<div>861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return 0;</div>
<div>863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>865&emsp;&emsp;</div>
<div>866&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean getDirty() {</div>
<div style="background-color:limegreen;">867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_DIRTY_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>869&emsp;&emsp;</div>
<div>870&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setDirty(boolean dirty) {</div>
<div style="background-color:limegreen;">871&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (dirty) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_DIRTY_BIT;</div>
<div>873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_DIRTY_BIT;</div>
<div>875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>877&emsp;&emsp;</div>
<div>878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isBINDelta() {</div>
<div style="background-color:limegreen;">880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isUpperIN() || isLatchOwner());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_DELTA_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>883&emsp;&emsp;</div>
<div>884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This version of isBINDelta() takes a checkLatched param to allow</div>
<div>886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for cases where it is ok to call the method without holding the</div>
<div>887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN latch (e.g. in single-threaded tests, or when the BIN is not</div>
<div>888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * attached to the tree (and thus inaccessible from other threads)).</div>
<div>889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isBINDelta(boolean checkLatched) {</div>
<div style="background-color:limegreen;">892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!checkLatched || isUpperIN() || isLatchOwner());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_DELTA_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>895&emsp;&emsp;</div>
<div>896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void setBINDelta(boolean delta) {</div>
<div style="background-color:limegreen;">897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (delta) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_DELTA_BIT;</div>
<div>899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_DELTA_BIT;</div>
<div>901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>903&emsp;&emsp;</div>
<div>904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Indicates that the BIN was fetched from disk, or loaded from the</div>
<div>906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * off-heap cache, using CacheMode.UNCHANGED, and has not been accessed</div>
<div>907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * with another CacheMode. BINs in this state should be evicted from main</div>
<div>908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cache as soon as they are no longer referenced by a cursor. If they were</div>
<div>909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * loaded from off-heap cache, they should be stored off-heap when they are</div>
<div>910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * evicted from main. The FetchedColdOffHeap flag indicates whether the</div>
<div>911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN was loaded from off-heap cache.</div>
<div>912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean getFetchedCold() {</div>
<div style="background-color:limegreen;">914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_FETCHED_COLD_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>916&emsp;&emsp;</div>
<div>917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** @see #getFetchedCold() */</div>
<div>918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setFetchedCold(boolean val) {</div>
<div style="background-color:limegreen;">919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (val) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_FETCHED_COLD_BIT;</div>
<div>921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_FETCHED_COLD_BIT;</div>
<div>923&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>925&emsp;&emsp;</div>
<div>926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** @see #getFetchedCold() */</div>
<div>927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean getFetchedColdOffHeap() {</div>
<div style="background-color:limegreen;">928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_FETCHED_COLD_OFFHEAP_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>930&emsp;&emsp;</div>
<div>931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /** @see #getFetchedCold() */</div>
<div>932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setFetchedColdOffHeap(boolean val) {</div>
<div style="background-color:limegreen;">933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (val) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_FETCHED_COLD_OFFHEAP_BIT;</div>
<div>935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_FETCHED_COLD_OFFHEAP_BIT;</div>
<div>937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>939&emsp;&emsp;</div>
<div>940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean getRecalcToggle() {</div>
<div style="background-color:limegreen;">941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_RECALC_TOGGLE_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>943&emsp;&emsp;</div>
<div>944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setRecalcToggle(boolean toggle) {</div>
<div style="background-color:limegreen;">945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (toggle) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_RECALC_TOGGLE_BIT;</div>
<div>947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_RECALC_TOGGLE_BIT;</div>
<div>949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>951&emsp;&emsp;</div>
<div>952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isRoot() {</div>
<div style="background-color:limegreen;">953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_IS_ROOT_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>955&emsp;&emsp;</div>
<div>956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void setIsRoot(boolean isRoot) {</div>
<div>957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setIsRootFlag(isRoot);</div>
<div>958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>960&emsp;&emsp;</div>
<div>961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setIsRootFlag(boolean isRoot) {</div>
<div style="background-color:limegreen;">962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isRoot) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_IS_ROOT_BIT;</div>
<div>964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_IS_ROOT_BIT;</div>
<div>966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>968&emsp;&emsp;</div>
<div>969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean hasCachedChildrenFlag() {</div>
<div style="background-color:limegreen;">970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_HAS_CACHED_CHILDREN_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>972&emsp;&emsp;</div>
<div>973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setHasCachedChildrenFlag(boolean value) {</div>
<div style="background-color:limegreen;">974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (value) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_HAS_CACHED_CHILDREN_BIT;</div>
<div>976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_HAS_CACHED_CHILDREN_BIT;</div>
<div>978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>980&emsp;&emsp;</div>
<div>981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isInPri2LRU() {</div>
<div style="background-color:limegreen;">982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_PRI2_LRU_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>984&emsp;&emsp;</div>
<div>985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* public for unit tests */</div>
<div>986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setInPri2LRU(boolean value) {</div>
<div style="background-color:limegreen;">987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (value) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_PRI2_LRU_BIT;</div>
<div>989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_PRI2_LRU_BIT;</div>
<div>991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>993&emsp;&emsp;</div>
<div>994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isExpirationInHours() {</div>
<div style="background-color:limegreen;">995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_EXPIRATION_IN_HOURS) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>997&emsp;&emsp;</div>
<div>998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setExpirationInHours(boolean value) {</div>
<div style="background-color:limegreen;">999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (value) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_EXPIRATION_IN_HOURS;</div>
<div>1001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_EXPIRATION_IN_HOURS;</div>
<div>1003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1005&emsp;&emsp;</div>
<div>1006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the identifier key for this node.</div>
<div>1008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final byte[] getIdentifierKey() {</div>
<div>1010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return identifierKey;</div>
<div>1011&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1012&emsp;&emsp;</div>
<div>1013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set the identifier key for this node.</div>
<div>1015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param key - the new identifier key for this node.</div>
<div>1017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param makeDirty should normally be true, but may be false when an</div>
<div>1019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * expired slot containing the identifier key has been deleted.</div>
<div>1020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setIdentifierKey(byte[] key, boolean makeDirty) {</div>
<div>1022&emsp;&emsp;</div>
<div style="background-color:limegreen;">1023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1024&emsp;&emsp;</div>
<div>1025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * The identifierKey is "intentionally" not kept track of in the</div>
<div>1027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * memory budget.  If we did, then it would look like this:</div>
<div>1028&emsp;&emsp;</div>
<div>1029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         int oldIDKeySz = (identifierKey == null) ?</div>
<div>1030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           0 :</div>
<div>1031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           MemoryBudget.byteArraySize(identifierKey.length);</div>
<div>1032&emsp;&emsp;</div>
<div>1033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         int newIDKeySz = (key == null) ?</div>
<div>1034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           0 :</div>
<div>1035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           MemoryBudget.byteArraySize(key.length);</div>
<div>1036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         updateMemorySize(newIDKeySz - oldIDKeySz);</div>
<div>1037&emsp;&emsp;</div>
<div>1038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>1039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        identifierKey = key;</div>
<div>1040&emsp;&emsp;</div>
<div style="background-color:limegreen;">1041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (makeDirty) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>1043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1045&emsp;&emsp;</div>
<div>1046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the number of entries in this node.</div>
<div>1048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1049&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getNEntries() {</div>
<div>1050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return nEntries;</div>
<div>1051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1052&emsp;&emsp;</div>
<div>1053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the maximum number of entries in this node.</div>
<div>1055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overriden by TestIN in INEntryTestBase.java</div>
<div>1057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getMaxEntries() {</div>
<div>1059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryStates.length;</div>
<div>1060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1061&emsp;&emsp;</div>
<div>1062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final byte getState(int idx) {</div>
<div>1063&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryStates[idx];</div>
<div>1064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1065&emsp;&emsp;</div>
<div>1066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if the object is dirty.</div>
<div>1068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final boolean isDirty(int idx) {</div>
<div style="background-color:limegreen;">1070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((entryStates[idx] & EntryStates.DIRTY_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1072&emsp;&emsp;</div>
<div>1073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if the idx'th entry has been deleted, although the</div>
<div>1075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * transaction that performed the deletion may not be committed.</div>
<div>1076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isEntryPendingDeleted(int idx) {</div>
<div style="background-color:limegreen;">1078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((entryStates[idx] & EntryStates.PENDING_DELETED_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1079&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1080&emsp;&emsp;</div>
<div>1081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set pendingDeleted to true.</div>
<div>1083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setPendingDeleted(int idx) {</div>
<div>1085&emsp;&emsp;</div>
<div>1086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.PENDING_DELETED_BIT;</div>
<div>1087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1090&emsp;&emsp;</div>
<div>1091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set pendingDeleted to false.</div>
<div>1093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void clearPendingDeleted(int idx) {</div>
<div>1095&emsp;&emsp;</div>
<div>1096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] &= EntryStates.CLEAR_PENDING_DELETED_BIT;</div>
<div>1097&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1100&emsp;&emsp;</div>
<div>1101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if the idx'th entry is deleted for sure.  If a transaction</div>
<div>1103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * performed the deletion, it has been committed.</div>
<div>1104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isEntryKnownDeleted(int idx) {</div>
<div style="background-color:limegreen;">1106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((entryStates[idx] & EntryStates.KNOWN_DELETED_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1108&emsp;&emsp;</div>
<div>1109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set KD flag to true and clear the PD flag (PD does not need to be on</div>
<div>1111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if KD is on).</div>
<div>1112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setKnownDeleted(int idx) {</div>
<div>1114&emsp;&emsp;</div>
<div style="background-color:limegreen;">1115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1116&emsp;&emsp;</div>
<div>1117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.KNOWN_DELETED_BIT;</div>
<div>1118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] &= EntryStates.CLEAR_PENDING_DELETED_BIT;</div>
<div>1119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1122&emsp;&emsp;</div>
<div>1123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set knownDeleted flag to true and evict the child LN if cached. The</div>
<div>1125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * child LN is evicted to save memory, since it will never be fetched</div>
<div>1126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * again.</div>
<div>1127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setKnownDeletedAndEvictLN(int index) {</div>
<div>1129&emsp;&emsp;</div>
<div style="background-color:limegreen;">1130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1131&emsp;&emsp;</div>
<div>1132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setKnownDeleted(index);</div>
<div>1133&emsp;&emsp;</div>
<div>1134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LN oldLN = (LN) getTarget(index);</div>
<div style="background-color:limegreen;">1135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oldLN != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldLN, null /* newNode */);</div>
<div>1137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            oldLN.releaseMemoryBudget();</div>
<div>1138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(index, null);</div>
<div>1140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1141&emsp;&emsp;</div>
<div>1142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set knownDeleted to false.</div>
<div>1144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void clearKnownDeleted(int idx) {</div>
<div>1146&emsp;&emsp;</div>
<div style="background-color:limegreen;">1147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1148&emsp;&emsp;</div>
<div>1149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] &= EntryStates.CLEAR_KNOWN_DELETED_BIT;</div>
<div>1150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1153&emsp;&emsp;</div>
<div>1154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In the future we may want to move the following static methods to an</div>
<div>1156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * EntryState utility class and share all state bit twidling among IN,</div>
<div>1157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * ChildReference, and DeltaInfo.</div>
<div>1158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1159&emsp;&emsp;</div>
<div>1160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns true if the given state is known deleted.</div>
<div>1162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static boolean isStateKnownDeleted(byte state) {</div>
<div>1164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ((state & EntryStates.KNOWN_DELETED_BIT) != 0);</div>
<div>1165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1166&emsp;&emsp;</div>
<div>1167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns true if the given state is pending deleted.</div>
<div>1169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static boolean isStatePendingDeleted(byte state) {</div>
<div>1171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ((state & EntryStates.PENDING_DELETED_BIT) != 0);</div>
<div>1172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1173&emsp;&emsp;</div>
<div>1174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return true if the LN at the given slot is embedded.</div>
<div>1176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isEmbeddedLN(int idx) {</div>
<div style="background-color:limegreen;">1178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((entryStates[idx] & EntryStates.EMBEDDED_LN_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1180&emsp;&emsp;</div>
<div>1181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static boolean isEmbeddedLN(byte state) {</div>
<div style="background-color:limegreen;">1182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((state & EntryStates.EMBEDDED_LN_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1184&emsp;&emsp;</div>
<div>1185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set embeddedLN to true.</div>
<div>1187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setEmbeddedLN(int idx) {</div>
<div>1189&emsp;&emsp;</div>
<div>1190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.EMBEDDED_LN_BIT;</div>
<div>1191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1194&emsp;&emsp;</div>
<div>1195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set embeddedLN to false.</div>
<div>1197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void clearEmbeddedLN(int idx) {</div>
<div>1199&emsp;&emsp;</div>
<div>1200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] &= EntryStates.CLEAR_EMBEDDED_LN_BIT;</div>
<div>1201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1204&emsp;&emsp;</div>
<div>1205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return true if the LN at the given slot is an embedded LN with no data.</div>
<div>1207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isNoDataLN(int idx) {</div>
<div style="background-color:limegreen;">1209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((entryStates[idx] & EntryStates.NO_DATA_LN_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1211&emsp;&emsp;</div>
<div>1212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static boolean isNoDataLN(byte state) {</div>
<div style="background-color:limegreen;">1213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((state & EntryStates.NO_DATA_LN_BIT) != 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1215&emsp;&emsp;</div>
<div>1216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set noDataLN to true.</div>
<div>1218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setNoDataLN(int idx) {</div>
<div>1220&emsp;&emsp;</div>
<div>1221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.NO_DATA_LN_BIT;</div>
<div>1222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1225&emsp;&emsp;</div>
<div>1226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set noDataLN to false.</div>
<div>1228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void clearNoDataLN(int idx) {</div>
<div>1230&emsp;&emsp;</div>
<div>1231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] &= EntryStates.CLEAR_NO_DATA_LN_BIT;</div>
<div>1232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1235&emsp;&emsp;</div>
<div>1236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean haveEmbeddedData(int idx) {</div>
<div style="background-color:limegreen;">1240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (isEmbeddedLN(idx) && !isNoDataLN(idx));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1242&emsp;&emsp;</div>
<div>1243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit testing */</div>
<div>1244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getNumEmbeddedLNs() {</div>
<div>1245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int res = 0;</div>
<div>1246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; getNEntries(); ++i) {</div>
<div>1247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (isEmbeddedLN(i)) {</div>
<div>1248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ++res;</div>
<div>1249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1251&emsp;&emsp;</div>
<div>1252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return res;</div>
<div>1253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1254&emsp;&emsp;</div>
<div>1255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit testing */</div>
<div>1256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final INKeyRep getKeyVals() {</div>
<div>1257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryKeys;</div>
<div>1258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1259&emsp;&emsp;</div>
<div>1260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final byte[] getKeyPrefix() {</div>
<div>1261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return keyPrefix;</div>
<div>1262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1263&emsp;&emsp;</div>
<div>1264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For unit testing only</div>
<div>1266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean hasKeyPrefix() {</div>
<div>1268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return keyPrefix != null;</div>
<div>1269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1270&emsp;&emsp;</div>
<div>1271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* This has default protection for access by the unit tests. */</div>
<div>1272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void setKeyPrefix(byte[] keyPrefix) {</div>
<div>1273&emsp;&emsp;</div>
<div style="background-color:limegreen;">1274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert databaseImpl != null;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1275&emsp;&emsp;</div>
<div style="background-color:limegreen;">1276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        int prevLength = (this.keyPrefix == null) ? 0 : this.keyPrefix.length;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        this.keyPrefix = keyPrefix;</div>
<div>1278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Update the memory budgeting to reflect changes in the key prefix. */</div>
<div style="background-color:limegreen;">1279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        int currLength = (keyPrefix == null) ? 0 : keyPrefix.length;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(prevLength, currLength);</div>
<div>1281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1282&emsp;&emsp;</div>
<div>1283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return the idx'th key. If prefixing is enabled, construct a new byte[]</div>
<div>1285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * containing the prefix and suffix. If prefixing is not enabled, just</div>
<div>1286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * return the current byte[] in entryKeys.</div>
<div>1287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final byte[] getKey(int idx) {</div>
<div>1289&emsp;&emsp;</div>
<div style="background-color:limegreen;">1290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert idx &#60; nEntries;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1291&emsp;&emsp;</div>
<div>1292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key = entryKeys.getFullKey(</div>
<div>1293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            keyPrefix, idx, haveEmbeddedData(idx));</div>
<div>1294&emsp;&emsp;</div>
<div style="background-color:limegreen;">1295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(key != null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1296&emsp;&emsp;</div>
<div>1297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return key;</div>
<div>1298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1299&emsp;&emsp;</div>
<div>1300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final byte[] getData(int idx) {</div>
<div>1301&emsp;&emsp;</div>
<div style="background-color:limegreen;">1302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (haveEmbeddedData(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return entryKeys.getData(idx);</div>
<div>1304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1305&emsp;&emsp;</div>
<div style="background-color:limegreen;">1306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isNoDataLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return Key.EMPTY_KEY;</div>
<div>1308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1309&emsp;&emsp;</div>
<div>1310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return null;</div>
<div>1311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1312&emsp;&emsp;</div>
<div>1313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the size of the key that is stored persistently, which will be</div>
<div>1315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the combined key-data for an embedded LN or duplicated DB record.</div>
<div>1316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    int getStoredKeySize(int idx) {</div>
<div>1318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryKeys.size(idx);</div>
<div>1319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1320&emsp;&emsp;</div>
<div>1321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Updates the key in the idx-th slot of this BIN, if the DB allows key</div>
<div>1323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * updates and the new key is not identical to the current key in the slot.</div>
<div>1324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It also updates the data (if any) that is embedded with the key in the</div>
<div>1325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * idx-slot, or embeds new data in that slot, is the "data" param is</div>
<div>1326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * non-null, or removes embedded data, if "data" is null. Finally, it</div>
<div>1327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * sets the EMBEDDED_LN_BIT and NO_DATA_LN_BIT flags in the slot's state.</div>
<div>1328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param key is the key to set in the slot and is the LN key.</div>
<div>1330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data If the data portion of a record must be embedded in this</div>
<div>1332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN, "data" stores the record's data. Null otherwise. See also comment</div>
<div>1333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the keyEntries field. </div>
<div>1334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * </div>
<div>1335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if a multi-slot change was made and the complete IN memory</div>
<div>1336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * size must be updated.</div>
<div>1337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean updateLNSlotKey(int idx, byte[] key, byte[] data) {</div>
<div>1339&emsp;&emsp;</div>
<div style="background-color:limegreen;">1340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1341&emsp;&emsp;</div>
<div>1342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean haveEmbeddedData = haveEmbeddedData(idx);</div>
<div>1343&emsp;&emsp;</div>
<div style="background-color:limegreen;">1344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (data == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                clearEmbeddedLN(idx); </div>
<div>1347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                clearNoDataLN(idx);</div>
<div>1348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">1350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setEmbeddedLN(idx);</div>
<div>1352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">1353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (data.length == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setNoDataLN(idx);</div>
<div>1355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>1356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                clearNoDataLN(idx);</div>
<div>1357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1359&emsp;&emsp;</div>
<div>1360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * The new key may be null if a dup LN was deleted, in which case there</div>
<div>1362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * is no need to update it.  There is no need to compare keys if there</div>
<div>1363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * is no comparator configured, since a key cannot be changed when the</div>
<div>1364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * default comparator is used.</div>
<div>1365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (key != null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            (databaseImpl.allowsKeyUpdates() ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>             DupConvert.needsConversion(databaseImpl)) &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            !Arrays.equals(key, getKey(idx))) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1370&emsp;&emsp;</div>
<div>1371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>1372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return setKey(idx, key, data, false);</div>
<div>1373&emsp;&emsp;</div>
<div style="background-color:limegreen;">1374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (haveEmbeddedData) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1375&emsp;&emsp;</div>
<div>1376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The key does not change, but the slot contains embedded data,</div>
<div>1378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * which must now either be removed (if data == null or</div>
<div>1379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * data.length == 0) or updated.</div>
<div>1380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * TODO #21488: update the data only if it actually changes.</div>
<div>1381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>1383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1384&emsp;&emsp;</div>
<div>1385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            INKeyRep.Type oldRepType = entryKeys.getType();</div>
<div>1386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.setData(idx, data, this);</div>
<div style="background-color:limegreen;">1387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            return oldRepType != entryKeys.getType();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1388&emsp;&emsp;</div>
<div style="background-color:limegreen;">1389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (data != null && data.length != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1390&emsp;&emsp;</div>
<div>1391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The key does not change, but we now have to embed data in a slot</div>
<div>1393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * that does not currently have embedded data.</div>
<div>1394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>1396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1397&emsp;&emsp;</div>
<div>1398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            key = entryKeys.getKey(idx, false);</div>
<div>1399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            INKeyRep.Type oldRepType = entryKeys.getType();</div>
<div>1400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.set(idx, key, data, this);</div>
<div style="background-color:limegreen;">1401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            return oldRepType != entryKeys.getType();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1402&emsp;&emsp;</div>
<div>1403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1407&emsp;&emsp;</div>
<div>1408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Convenience wrapper for setKey() method below</div>
<div>1410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean insertKey(</div>
<div>1412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>1413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>1414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data) {</div>
<div>1415&emsp;&emsp;</div>
<div>1416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Set the id key when inserting the first entry. This is important</div>
<div>1418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * when compression removes all entries from a BIN, and then an entry</div>
<div>1419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * is inserted before the empty BIN is purged.</div>
<div>1420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (nEntries == 1 && !isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setIdentifierKey(key, true /*makeDirty*/);</div>
<div>1423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1424&emsp;&emsp;</div>
<div>1425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return setKey(idx, key, data, true);</div>
<div>1426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1427&emsp;&emsp;</div>
<div>1428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO re-enable this and figure out why it is firing</div>
<div>1429&emsp;&emsp;</div>
<div>1430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean idKeyIsSlotKey() {</div>
<div>1431&emsp;&emsp;</div>
<div>1432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (true) {</div>
<div>1433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1435&emsp;&emsp;</div>
<div>1436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (!isBIN() || nEntries == 0) {</div>
<div>1437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1439&emsp;&emsp;</div>
<div>1440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; nEntries; i += 1) {</div>
<div>1441&emsp;&emsp;</div>
<div>1442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (entryKeys.compareKeys(</div>
<div>1443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                identifierKey,  keyPrefix, i, haveEmbeddedData(i),</div>
<div>1444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                databaseImpl.getKeyComparator()) == 0) {</div>
<div>1445&emsp;&emsp;</div>
<div>1446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return true;</div>
<div>1447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1449&emsp;&emsp;</div>
<div>1450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>1451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1452&emsp;&emsp;</div>
<div>1453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Convenience wrapper for setKey() method below. It is used for</div>
<div>1455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * upper INs only, so no need to worry about the EMBEDDED_LN_BIT</div>
<div>1456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and NO_DATA_LN_BIT flags.</div>
<div>1457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean updateKey(</div>
<div>1459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>1460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>1461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data) {</div>
<div>1462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return setKey(idx, key, data, false);</div>
<div>1463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1464&emsp;&emsp;</div>
<div>1465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method inserts or updates a key at a given slot. In either case,</div>
<div>1467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the associated embedded data (if any) is inserted or updated as well,</div>
<div>1468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and the key prefix is adjusted, if necessary.</div>
<div>1469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In case of insertion (indicated by a true value for the isInsertion</div>
<div>1471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * param), it is assumed that the idx slot does not store any valid info,</div>
<div>1472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * so any change to the key prefix (if any) is due to the insertion of</div>
<div>1473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * this new new key and not to the removal of the current key at the idx</div>
<div>1474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot.</div>
<div>1475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In case of update, the method does not check if the current key is</div>
<div>1477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * indeed different from the new key; it just updates the key</div>
<div>1478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * unconditionally. If the slot has embedded data, that data will also</div>
<div>1479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be updated (if the data param is not null), or be removed (if the data</div>
<div>1480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * param is null). If the slot does not have embedded data and the data</div>
<div>1481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * param is not null, the given data will be embedded.</div>
<div>1482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note: For BINs, the maintenance of the EMBEDDED_LN_BIT andNO_DATA_LN_BIT</div>
<div>1484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is done by the callers of this method.</div>
<div>1485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data If the data portion of a record must be embedded in this</div>
<div>1487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN, "data" stores the record's data. Null otherwise. See also comment</div>
<div>1488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the keyEntries field. </div>
<div>1489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if a multi-slot change was made and the complete IN memory</div>
<div>1491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * size must be updated.</div>
<div>1492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean setKey(</div>
<div>1494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>1495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>1496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data,</div>
<div>1497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean isInsertion) {</div>
<div>1498&emsp;&emsp;</div>
<div>1499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>1501&emsp;&emsp;</div>
<div>1502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Only compute key prefix if prefixing is enabled and there's an</div>
<div>1504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * existing prefix.</div>
<div>1505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">1506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (databaseImpl.getKeyPrefixing() && keyPrefix != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1507&emsp;&emsp;</div>
<div>1508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int newPrefixLen = Key.getKeyPrefixLength(</div>
<div>1509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                keyPrefix, keyPrefix.length, key);</div>
<div>1510&emsp;&emsp;</div>
<div style="background-color:limegreen;">1511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (newPrefixLen &#60; keyPrefix.length) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1512&emsp;&emsp;</div>
<div>1513&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>1514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * The new key doesn't share the current prefix, so recompute</div>
<div>1515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * the prefix and readjust all the existing suffixes.</div>
<div>1516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div style="background-color:limegreen;">1517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                byte[] newPrefix = (isInsertion ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    Key.createKeyPrefix(keyPrefix, key) :</div>
<div>1519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    computeKeyPrefix(idx));</div>
<div>1520&emsp;&emsp;</div>
<div style="background-color:limegreen;">1521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (newPrefix != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    /* Take the new key into consideration for new prefix. */</div>
<div>1523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    newPrefix = Key.createKeyPrefix(newPrefix, key);</div>
<div>1524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1525&emsp;&emsp;</div>
<div>1526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                recalcSuffixes(newPrefix, key, data, idx);</div>
<div>1527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return true;</div>
<div>1528&emsp;&emsp;</div>
<div>1529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>1530&emsp;&emsp;</div>
<div>1531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                INKeyRep.Type prevRepType = entryKeys.getType();</div>
<div>1532&emsp;&emsp;</div>
<div>1533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] suffix = computeKeySuffix(keyPrefix, key);</div>
<div>1534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryKeys = entryKeys.set(idx, suffix, data, this);</div>
<div>1535&emsp;&emsp;</div>
<div style="background-color:limegreen;">1536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                return prevRepType != entryKeys.getType();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1538&emsp;&emsp;</div>
<div style="background-color:limegreen;">1539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (keyPrefix != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1540&emsp;&emsp;</div>
<div>1541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>1542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Key prefixing has been turned off on this database, but there</div>
<div>1543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * are existing prefixes. Remove prefixes for this IN.</div>
<div>1544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>1545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            recalcSuffixes(null, key, data, idx);</div>
<div>1546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1547&emsp;&emsp;</div>
<div>1548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            INKeyRep.Type oldRepType = entryKeys.getType();</div>
<div>1550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.set(idx, key, data, this);</div>
<div style="background-color:limegreen;">1551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            return oldRepType != entryKeys.getType();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1554&emsp;&emsp;</div>
<div>1555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Given 2 byte arrays, "prefix" and "key", where "prefix" is or stores</div>
<div>1557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a prefix of "key", allocate and return another byte array that stores</div>
<div>1558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the suffix of "key" w.r.t. "prefix".</div>
<div>1559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static byte[] computeKeySuffix(byte[] prefix, byte[] key) {</div>
<div>1561&emsp;&emsp;</div>
<div style="background-color:limegreen;">1562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        int prefixLen = (prefix == null ? 0 : prefix.length);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1563&emsp;&emsp;</div>
<div style="background-color:limegreen;">1564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (prefixLen == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return key;</div>
<div>1566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1567&emsp;&emsp;</div>
<div>1568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int suffixLen = key.length - prefixLen;</div>
<div>1569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] ret = new byte[suffixLen];</div>
<div>1570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.arraycopy(key, prefixLen, ret, 0, suffixLen);</div>
<div>1571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ret;</div>
<div>1572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1573&emsp;&emsp;</div>
<div>1574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Iterate over all keys in this IN and recalculate their suffixes based on</div>
<div>1576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * newPrefix.  If keyVal and idx are supplied, it means that entry[idx] is</div>
<div>1577&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * about to be changed to keyVal so use that instead of</div>
<div>1578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * entryKeys.get(idx) when computing the new suffixes. If idx is &#60; 0,</div>
<div>1579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and keyVal is null, then recalculate suffixes for all entries in this.</div>
<div>1580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1581&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void recalcSuffixes(</div>
<div>1582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] newPrefix,</div>
<div>1583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>1584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data,</div>
<div>1585&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx) {</div>
<div>1586&emsp;&emsp;</div>
<div style="background-color:limegreen;">1587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1588&emsp;&emsp;</div>
<div style="background-color:limegreen;">1589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            byte[] curKey = (i == idx ? key : getKey(i));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1590&emsp;&emsp;</div>
<div>1591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte[] curData = null;</div>
<div>1592&emsp;&emsp;</div>
<div style="background-color:limegreen;">1593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (i == idx) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1594&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                curData = data;</div>
<div style="background-color:limegreen;">1595&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            } else if (haveEmbeddedData(i)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                curData = entryKeys.getData(i);</div>
<div>1597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1598&emsp;&emsp;</div>
<div>1599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte[] suffix = computeKeySuffix(newPrefix, curKey);</div>
<div>1600&emsp;&emsp;</div>
<div>1601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.set(i, suffix, curData, this);</div>
<div>1602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1603&emsp;&emsp;</div>
<div>1604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setKeyPrefix(newPrefix);</div>
<div>1605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1606&emsp;&emsp;</div>
<div>1607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Forces computation of the key prefix, without requiring a split.</div>
<div>1609&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Is public for use by DbCacheSize.</div>
<div>1610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void recalcKeyPrefix() {</div>
<div>1612&emsp;&emsp;</div>
<div>1613&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(!isBINDelta());</div>
<div>1614&emsp;&emsp;</div>
<div>1615&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        recalcSuffixes(computeKeyPrefix(-1), null, null, -1);</div>
<div>1616&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1617&emsp;&emsp;</div>
<div>1618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Computes a key prefix based on all the keys in 'this'.  Return null if</div>
<div>1620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the IN is empty or prefixing is not enabled or there is no common</div>
<div>1621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * prefix for the keys.</div>
<div>1622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private byte[] computeKeyPrefix(int excludeIdx) {</div>
<div>1624&emsp;&emsp;</div>
<div style="background-color:limegreen;">1625&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!databaseImpl.getKeyPrefixing() || nEntries &#60;= 1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return null;</div>
<div>1627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1628&emsp;&emsp;</div>
<div style="background-color:limegreen;">1629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        int firstIdx = (excludeIdx == 0) ? 1 : 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1630&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] curPrefixKey = getKey(firstIdx);</div>
<div>1631&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int prefixLen = curPrefixKey.length;</div>
<div>1632&emsp;&emsp;</div>
<div>1633&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>1634&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Only need to look at first and last entries when keys are ordered</div>
<div>1635&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * byte-by-byte.  But when there is a comparator, keys are not</div>
<div>1636&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * necessarily ordered byte-by-byte.  [#21328]</div>
<div>1637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>1638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean byteOrdered;</div>
<div>1639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (true) {</div>
<div>1640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Disable optimization for now.  Needs testing. */</div>
<div>1641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byteOrdered = false;</div>
<div>1642&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1643&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byteOrdered = (databaseImpl.getKeyComparator() == null);</div>
<div>1644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1645&emsp;&emsp;</div>
<div style="background-color:limegreen;">1646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (byteOrdered) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int lastIdx = nEntries - 1;</div>
<div style="background-color:limegreen;">1648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lastIdx == excludeIdx) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                lastIdx -= 1;</div>
<div>1650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">1651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lastIdx > firstIdx) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] lastKey = getKey(lastIdx);</div>
<div>1653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int newPrefixLen = Key.getKeyPrefixLength(</div>
<div>1654&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    curPrefixKey, prefixLen, lastKey);</div>
<div>1655&emsp;&emsp;</div>
<div style="background-color:limegreen;">1656&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (newPrefixLen &#60; prefixLen) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    curPrefixKey = lastKey;</div>
<div>1658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    prefixLen = newPrefixLen;</div>
<div>1659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1660&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1661&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">1662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = firstIdx + 1; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1663&emsp;&emsp;</div>
<div style="background-color:limegreen;">1664&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (i == excludeIdx) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    continue;</div>
<div>1666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1667&emsp;&emsp;</div>
<div>1668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] curKey = getKey(i);</div>
<div>1669&emsp;&emsp;</div>
<div>1670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int newPrefixLen = Key.getKeyPrefixLength(</div>
<div>1671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    curPrefixKey, prefixLen, curKey);</div>
<div>1672&emsp;&emsp;</div>
<div style="background-color:limegreen;">1673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (newPrefixLen &#60; prefixLen) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>1674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    curPrefixKey = curKey;</div>
<div>1675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    prefixLen = newPrefixLen;</div>
<div>1676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1679&emsp;&emsp;</div>
<div>1680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] ret = new byte[prefixLen];</div>
<div>1681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.arraycopy(curPrefixKey, 0, ret, 0, prefixLen);</div>
<div>1682&emsp;&emsp;</div>
<div>1683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ret;</div>
<div>1684&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1685&emsp;&emsp;</div>
<div>1686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For debugging.</div>
<div>1688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final boolean verifyKeyPrefix() {</div>
<div>1690&emsp;&emsp;</div>
<div>1691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] computedKeyPrefix = computeKeyPrefix(-1);</div>
<div>1692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (keyPrefix == null) {</div>
<div>1693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return computedKeyPrefix == null;</div>
<div>1694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1695&emsp;&emsp;</div>
<div>1696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (computedKeyPrefix == null ||</div>
<div>1697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            computedKeyPrefix.length &#60; keyPrefix.length) {</div>
<div>1698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.out.println("VerifyKeyPrefix failed");</div>
<div>1699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.out.println(dumpString(0, false));</div>
<div>1700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; keyPrefix.length; i++) {</div>
<div>1703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (keyPrefix[i] != computedKeyPrefix[i]) {</div>
<div>1704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                System.out.println("VerifyKeyPrefix failed");</div>
<div>1705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                System.out.println(dumpString(0, false));</div>
<div>1706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return false;</div>
<div>1707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>1710&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1711&emsp;&emsp;</div>
<div>1712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether the given key is greater than or equal to the first key</div>
<div>1714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * in the IN and less than or equal to the last key in the IN.  This method</div>
<div>1715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is used to determine whether a key to be inserted belongs in this IN,</div>
<div>1716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * without doing a tree search.  If false is returned it is still possible</div>
<div>1717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * that the key belongs in this IN, but a tree search must be performed to</div>
<div>1718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * find out.</div>
<div>1719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean isKeyInBounds(byte[] key) {</div>
<div>1721&emsp;&emsp;</div>
<div style="background-color:limegreen;">1722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1723&emsp;&emsp;</div>
<div style="background-color:limegreen;">1724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (nEntries &#60; 2) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1727&emsp;&emsp;</div>
<div>1728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Comparator&#60;byte[]> comparator = getKeyComparator();</div>
<div>1729&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int cmp;</div>
<div>1730&emsp;&emsp;</div>
<div>1731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Compare key given to my first key. */</div>
<div>1732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        cmp = entryKeys.compareKeys(</div>
<div>1733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            key, keyPrefix, 0, haveEmbeddedData(0), comparator);</div>
<div>1734&emsp;&emsp;</div>
<div style="background-color:limegreen;">1735&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cmp &#60; 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1738&emsp;&emsp;</div>
<div>1739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Compare key given to my last key. */</div>
<div>1740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx =  nEntries - 1;</div>
<div>1741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        cmp = entryKeys.compareKeys(</div>
<div>1742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            key, keyPrefix, idx, haveEmbeddedData(idx), comparator);</div>
<div>1743&emsp;&emsp;</div>
<div style="background-color:limegreen;">1744&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return cmp &#60;= 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1746&emsp;&emsp;</div>
<div>1747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return the idx'th LSN for this entry.</div>
<div>1749&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the idx'th LSN for this entry.</div>
<div>1751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long getLsn(int idx) {</div>
<div>1753&emsp;&emsp;</div>
<div style="background-color:limegreen;">1754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryLsnLongArray == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int offset = idx &#60;&#60; 2;</div>
<div>1756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int fileOffset = getFileOffset(offset);</div>
<div style="background-color:limegreen;">1757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (fileOffset == -1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return DbLsn.NULL_LSN;</div>
<div>1759&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>1760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return DbLsn.makeLsn((baseFileNumber +</div>
<div>1761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                      getFileNumberOffset(offset)),</div>
<div>1762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                     fileOffset);</div>
<div>1763&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return entryLsnLongArray[idx];</div>
<div>1766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1768&emsp;&emsp;</div>
<div>1769&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set the LSN of the idx'th slot, mark the slot dirty, and update</div>
<div>1771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * memory consuption. Throw exception if the update is not legitimate.</div>
<div>1772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void setLsn(int idx, long lsn) {</div>
<div>1774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, lsn, true);</div>
<div>1775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1776&emsp;&emsp;</div>
<div>1777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set the LSN of the idx'th slot, mark the slot dirty, and update</div>
<div>1779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * memory consuption. If "check" is true, throw exception if the</div>
<div>1780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * update is not legitimate.</div>
<div>1781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setLsn(int idx, long lsn, boolean check) {</div>
<div>1783&emsp;&emsp;</div>
<div style="background-color:limegreen;">1784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!check || shouldUpdateLsn(getLsn(idx), lsn)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1785&emsp;&emsp;</div>
<div>1786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int oldSize = computeLsnOverhead();</div>
<div>1787&emsp;&emsp;</div>
<div>1788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* setLsnInternal can mutate to an array of longs. */</div>
<div>1789&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLsnInternal(idx, lsn);</div>
<div>1790&emsp;&emsp;</div>
<div>1791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(computeLsnOverhead() - oldSize);</div>
<div>1792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] |= EntryStates.DIRTY_BIT;</div>
<div>1793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>1794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1796&emsp;&emsp;</div>
<div>1797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>1798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Set the LSN of the idx'th slot. If the current storage for LSNs is the</div>
<div>1799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * compact one, mutate it to the the non-compact, if necessary.</div>
<div>1800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void setLsnInternal(int idx, long value) {</div>
<div>1802&emsp;&emsp;</div>
<div>1803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Will implement this in the future. Note, don't adjust if mutating.*/</div>
<div>1804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        //maybeAdjustCapacity(offset);</div>
<div style="background-color:limegreen;">1805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryLsnLongArray != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray[idx] = value;</div>
<div>1807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>1808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1809&emsp;&emsp;</div>
<div>1810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int offset = idx &#60;&#60; 2;</div>
<div>1811&emsp;&emsp;</div>
<div style="background-color:limegreen;">1812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (value == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFileNumberOffset(offset, (byte) 0);</div>
<div>1814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFileOffset(offset, -1);</div>
<div>1815&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>1816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1817&emsp;&emsp;</div>
<div>1818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long thisFileNumber = DbLsn.getFileNumber(value);</div>
<div>1819&emsp;&emsp;</div>
<div style="background-color:limegreen;">1820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (baseFileNumber == -1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* First entry. */</div>
<div>1822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            baseFileNumber = thisFileNumber;</div>
<div>1823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFileNumberOffset(offset, (byte) 0);</div>
<div>1824&emsp;&emsp;</div>
<div>1825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>1826&emsp;&emsp;</div>
<div style="background-color:limegreen;">1827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (thisFileNumber &#60; baseFileNumber) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (!adjustFileNumbers(thisFileNumber)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    mutateToLongArray(idx, value);</div>
<div>1830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return;</div>
<div>1831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                baseFileNumber = thisFileNumber;</div>
<div>1833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1834&emsp;&emsp;</div>
<div>1835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long fileNumberDifference = thisFileNumber - baseFileNumber;</div>
<div style="background-color:limegreen;">1836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (fileNumberDifference > Byte.MAX_VALUE) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                mutateToLongArray(idx, value);</div>
<div>1838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return;</div>
<div>1839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1840&emsp;&emsp;</div>
<div>1841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFileNumberOffset(</div>
<div>1842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                offset, (byte) (thisFileNumber - baseFileNumber));</div>
<div>1843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            //assert getFileNumberOffset(offset) >= 0;</div>
<div>1844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1845&emsp;&emsp;</div>
<div>1846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int fileOffset = (int) DbLsn.getFileOffset(value);</div>
<div style="background-color:limegreen;">1847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (fileOffset > MAX_FILE_OFFSET) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            mutateToLongArray(idx, value);</div>
<div>1849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>1850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1851&emsp;&emsp;</div>
<div>1852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setFileOffset(offset, fileOffset);</div>
<div>1853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        //assert getLsn(offset) == value;</div>
<div>1854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1855&emsp;&emsp;</div>
<div>1856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean adjustFileNumbers(long newBaseFileNumber) {</div>
<div>1857&emsp;&emsp;</div>
<div>1858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldBaseFileNumber = baseFileNumber;</div>
<div>1859&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0;</div>
<div style="background-color:limegreen;">1860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>             i &#60; entryLsnByteArray.length;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             i += BYTES_PER_LSN_ENTRY) {</div>
<div style="background-color:limegreen;">1862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (getFileOffset(i) == -1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>1864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1865&emsp;&emsp;</div>
<div>1866&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long curEntryFileNumber =</div>
<div>1867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                oldBaseFileNumber + getFileNumberOffset(i);</div>
<div>1868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newCurEntryFileNumberOffset =</div>
<div>1869&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (curEntryFileNumber - newBaseFileNumber);</div>
<div>1870&emsp;&emsp;</div>
<div style="background-color:limegreen;">1871&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (newCurEntryFileNumberOffset > Byte.MAX_VALUE) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                long undoOffset = oldBaseFileNumber - newBaseFileNumber;</div>
<div>1873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                for (int j = i - BYTES_PER_LSN_ENTRY;</div>
<div style="background-color:limegreen;">1874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                     j >= 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                     j -= BYTES_PER_LSN_ENTRY) {</div>
<div style="background-color:limegreen;">1876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (getFileOffset(j) == -1) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1877&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        continue;</div>
<div>1878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>1879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    setFileNumberOffset</div>
<div>1880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        (j, (byte) (getFileNumberOffset(j) - undoOffset));</div>
<div>1881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    //assert getFileNumberOffset(j) >= 0;</div>
<div>1882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>1883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return false;</div>
<div>1884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFileNumberOffset(i, (byte) newCurEntryFileNumberOffset);</div>
<div>1886&emsp;&emsp;</div>
<div>1887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            //assert getFileNumberOffset(i) >= 0;</div>
<div>1888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>1890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1891&emsp;&emsp;</div>
<div>1892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setFileNumberOffset(int offset, byte fileNumberOffset) {</div>
<div>1893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray[offset] = fileNumberOffset;</div>
<div>1894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1895&emsp;&emsp;</div>
<div>1896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private byte getFileNumberOffset(int offset) {</div>
<div>1897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryLsnByteArray[offset];</div>
<div>1898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1899&emsp;&emsp;</div>
<div>1900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setFileOffset(int offset, int fileOffset) {</div>
<div>1901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        put3ByteInt(offset + 1, fileOffset);</div>
<div>1902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1903&emsp;&emsp;</div>
<div>1904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int getFileOffset(int offset) {</div>
<div>1905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return get3ByteInt(offset + 1);</div>
<div>1906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1907&emsp;&emsp;</div>
<div>1908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void put3ByteInt(int offset, int value) {</div>
<div>1909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray[offset++] = (byte) value;</div>
<div>1910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray[offset++] = (byte) (value >>> 8);</div>
<div>1911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray[offset]   = (byte) (value >>> 16);</div>
<div>1912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1913&emsp;&emsp;</div>
<div>1914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int get3ByteInt(int offset) {</div>
<div>1915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int ret = (entryLsnByteArray[offset++] & 0xFF);</div>
<div>1916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ret += (entryLsnByteArray[offset++] & 0xFF) &#60;&#60; 8;</div>
<div>1917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ret += (entryLsnByteArray[offset]   & 0xFF) &#60;&#60; 16;</div>
<div style="background-color:limegreen;">1918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ret == THREE_BYTE_NEGATIVE_ONE) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ret = -1;</div>
<div>1920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1921&emsp;&emsp;</div>
<div>1922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ret;</div>
<div>1923&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1924&emsp;&emsp;</div>
<div>1925&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void mutateToLongArray(int idx, long value) {</div>
<div>1926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int nElts = entryLsnByteArray.length >> 2;</div>
<div>1927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long[] newArr = new long[nElts];</div>
<div style="background-color:limegreen;">1928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nElts; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newArr[i] = getLsn(i);</div>
<div>1930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        newArr[idx] = value;</div>
<div>1932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnLongArray = newArr;</div>
<div>1933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray = null;</div>
<div>1934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1935&emsp;&emsp;</div>
<div>1936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>1937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For a deferred write database, ensure that information is not lost when</div>
<div>1938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a new LSN is assigned.  Also ensures that a transient LSN is not</div>
<div>1939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * accidentally assigned to a persistent entry.</div>
<div>1940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Because this method uses strict checking, prepareForSlotReuse must</div>
<div>1942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * sometimes be called when a new logical entry is being placed in a slot,</div>
<div>1943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * e.g., during an IN split or an LN slot reuse.</div>
<div>1944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The following transition is a NOOP and the LSN is not set:</div>
<div>1946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Any LSN to same value.</div>
<div>1947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The following transitions are allowed and cause the LSN to be set:</div>
<div>1948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Null LSN to transient LSN</div>
<div>1949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Null LSN to persistent LSN</div>
<div>1950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Transient LSN to persistent LSN</div>
<div>1951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Persistent LSN to new persistent LSN</div>
<div>1952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The following transitions should not occur and throw an exception:</div>
<div>1953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Transient LSN to null LSN</div>
<div>1954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Transient LSN to new transient LSN</div>
<div>1955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Persistent LSN to null LSN</div>
<div>1956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   Persistent LSN to transient LSN</div>
<div>1957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>1958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The above imply that a transient or null LSN can overwrite only a null</div>
<div>1959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * LSN.</div>
<div>1960&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>1961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private final boolean shouldUpdateLsn(long oldLsn, long newLsn) {</div>
<div>1962&emsp;&emsp;</div>
<div>1963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Save a little computation in packing/updating an unchanged LSN. */</div>
<div style="background-color:limegreen;">1964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oldLsn == newLsn) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>1966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* The rules for a new null LSN can be broken in a read-only env. */</div>
<div style="background-color:limegreen;">1968&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (newLsn == DbLsn.NULL_LSN && getEnv().isReadOnly()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>1970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Enforce LSN update rules.  Assume lsn != oldLsn. */</div>
<div style="background-color:limegreen;">1972&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (databaseImpl.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">1973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (oldLsn != DbLsn.NULL_LSN && DbLsn.isTransientOrNull(newLsn)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw unexpectedState(</div>
<div>1975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    "DeferredWrite LSN update not allowed" +</div>
<div>1976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    " oldLsn = " + DbLsn.getNoFormatString(oldLsn) +</div>
<div>1977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    " newLsn = " + DbLsn.getNoFormatString(newLsn));</div>
<div>1978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">1980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (DbLsn.isTransientOrNull(newLsn)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>1981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw unexpectedState(</div>
<div>1982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    "LSN update not allowed" +</div>
<div>1983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    " oldLsn = " + DbLsn.getNoFormatString(oldLsn) +</div>
<div>1984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    " newLsn = " + DbLsn.getNoFormatString(newLsn));</div>
<div>1985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>1986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>1987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>1988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1989&emsp;&emsp;</div>
<div>1990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit tests. */</div>
<div>1991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final long[] getEntryLsnLongArray() {</div>
<div>1992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryLsnLongArray;</div>
<div>1993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1994&emsp;&emsp;</div>
<div>1995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit tests. */</div>
<div>1996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final byte[] getEntryLsnByteArray() {</div>
<div>1997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryLsnByteArray;</div>
<div>1998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>1999&emsp;&emsp;</div>
<div>2000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* For unit tests. */</div>
<div>2001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void initEntryLsn(int capacity) {</div>
<div>2002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnLongArray = null;</div>
<div>2003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryLsnByteArray = new byte[capacity &#60;&#60; 2];</div>
<div>2004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        baseFileNumber = -1;</div>
<div>2005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2006&emsp;&emsp;</div>
<div>2007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Will implement this in the future. Note, don't adjust if mutating.*/</div>
<div>2008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /***</div>
<div>2009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      private void maybeAdjustCapacity(int offset) {</div>
<div>2010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (entryLsnLongArray == null) {</div>
<div>2011&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int bytesNeeded = offset + BYTES_PER_LSN_ENTRY;</div>
<div>2012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int currentBytes = entryLsnByteArray.length;</div>
<div>2013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (currentBytes &#60; bytesNeeded) {</div>
<div>2014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int newBytes = bytesNeeded +</div>
<div>2015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      (GROWTH_INCREMENT * BYTES_PER_LSN_ENTRY);</div>
<div>2016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      byte[] newArr = new byte[newBytes];</div>
<div>2017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.arraycopy(entryLsnByteArray, 0, newArr, 0,</div>
<div>2018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      currentBytes);</div>
<div>2019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      entryLsnByteArray = newArr;</div>
<div>2020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for (int i = currentBytes;</div>
<div>2021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      i &#60; newBytes;</div>
<div>2022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      i += BYTES_PER_LSN_ENTRY) {</div>
<div>2023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      setFileNumberOffset(i, (byte) 0);</div>
<div>2024&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      setFileOffset(i, -1);</div>
<div>2025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      } else {</div>
<div>2028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int currentEntries = entryLsnLongArray.length;</div>
<div>2029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int idx = offset >> 2;</div>
<div>2030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (currentEntries &#60; idx + 1) {</div>
<div>2031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int newEntries = idx + GROWTH_INCREMENT;</div>
<div>2032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      long[] newArr = new long[newEntries];</div>
<div>2033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      System.arraycopy(entryLsnLongArray, 0, newArr, 0,</div>
<div>2034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      currentEntries);</div>
<div>2035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      entryLsnLongArray = newArr;</div>
<div>2036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for (int i = currentEntries; i &#60; newEntries; i++) {</div>
<div>2037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      entryLsnLongArray[i] = DbLsn.NULL_LSN;</div>
<div>2038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }</div>
<div>2042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     ***/</div>
<div>2043&emsp;&emsp;</div>
<div>2044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The last logged size is not stored for UINs.</div>
<div>2046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isLastLoggedSizeStored(int idx) {</div>
<div>2048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>2049&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2050&emsp;&emsp;</div>
<div>2051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean mayHaveLastLoggedSizeStored() {</div>
<div>2052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>2053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2054&emsp;&emsp;</div>
<div>2055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The last logged size is not stored for UINs.</div>
<div>2057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setLastLoggedSize(int idx, int lastLoggedSize) {</div>
<div>2059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2060&emsp;&emsp;</div>
<div>2061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The last logged size is not stored for UINs.</div>
<div>2063&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void clearLastLoggedSize(int idx) {</div>
<div>2065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2066&emsp;&emsp;</div>
<div>2067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The last logged size is not stored for UINs.</div>
<div>2069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setLastLoggedSizeUnconditional(int idx, int lastLoggedSize) {</div>
<div>2071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2072&emsp;&emsp;</div>
<div>2073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The last logged size is not stored for UINs.</div>
<div>2075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getLastLoggedSize(int idx) {</div>
<div>2077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return 0;</div>
<div>2078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2079&emsp;&emsp;</div>
<div>2080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setOffHeapBINId(int idx,</div>
<div>2081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                int val,</div>
<div>2082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                boolean pri2,</div>
<div>2083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                boolean dirty) {</div>
<div>2084&emsp;&emsp;</div>
<div style="background-color:limegreen;">2085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert getNormalizedLevel() == 2;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert val >= 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2087&emsp;&emsp;</div>
<div>2088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setOffHeapBINPri2(idx, pri2);</div>
<div>2089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setOffHeapBINDirty(idx, dirty);</div>
<div>2090&emsp;&emsp;</div>
<div>2091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long newVal = val + 1;</div>
<div>2092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long oldVal = offHeapBINIds.get(idx);</div>
<div>2093&emsp;&emsp;</div>
<div style="background-color:limegreen;">2094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oldVal == newVal) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>2096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2097&emsp;&emsp;</div>
<div style="background-color:limegreen;">2098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert oldVal == 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2099&emsp;&emsp;</div>
<div>2100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapBINIds = offHeapBINIds.set(idx, newVal, this);</div>
<div>2101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2102&emsp;&emsp;</div>
<div>2103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void clearOffHeapBINId(int idx) {</div>
<div>2104&emsp;&emsp;</div>
<div style="background-color:limegreen;">2105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert getNormalizedLevel() == 2;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2106&emsp;&emsp;</div>
<div>2107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setOffHeapBINPri2(idx, false);</div>
<div>2108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setOffHeapBINDirty(idx, false);</div>
<div>2109&emsp;&emsp;</div>
<div>2110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long oldVal = offHeapBINIds.get(idx);</div>
<div>2111&emsp;&emsp;</div>
<div style="background-color:limegreen;">2112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oldVal == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>2114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2115&emsp;&emsp;</div>
<div>2116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapBINIds = offHeapBINIds.set(idx, 0, this);</div>
<div>2117&emsp;&emsp;</div>
<div style="background-color:limegreen;">2118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getInListResident() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            getNormalizedLevel() == 2 &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            offHeapBINIds.isEmpty()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2121&emsp;&emsp;</div>
<div>2122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEvictor().moveToPri1LRU(this);</div>
<div>2123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2125&emsp;&emsp;</div>
<div>2126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getOffHeapBINId(int idx) {</div>
<div>2127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ((int) offHeapBINIds.get(idx)) - 1;</div>
<div>2128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2129&emsp;&emsp;</div>
<div>2130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean hasOffHeapBINIds() {</div>
<div style="background-color:limegreen;">2131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return !offHeapBINIds.isEmpty();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2133&emsp;&emsp;</div>
<div>2134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getOffHeapBINIdsMemorySize() {</div>
<div>2135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return offHeapBINIds.getMemorySize();</div>
<div>2136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2137&emsp;&emsp;</div>
<div>2138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setOffHeapBINDirty(int idx, boolean val) {</div>
<div style="background-color:limegreen;">2139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (val) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] |= EntryStates.OFFHEAP_DIRTY_BIT;</div>
<div>2141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>2142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] &= EntryStates.CLEAR_OFFHEAP_DIRTY_BIT;</div>
<div>2143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2145&emsp;&emsp;</div>
<div>2146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isOffHeapBINDirty(int idx) {</div>
<div style="background-color:limegreen;">2147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (entryStates[idx] & EntryStates.OFFHEAP_DIRTY_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2149&emsp;&emsp;</div>
<div>2150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void setOffHeapBINPri2(int idx, boolean val) {</div>
<div style="background-color:limegreen;">2151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (val) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] |= EntryStates.OFFHEAP_PRI2_BIT;</div>
<div>2153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>2154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[idx] &= EntryStates.CLEAR_OFFHEAP_PRI2_BIT;</div>
<div>2155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2157&emsp;&emsp;</div>
<div>2158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean isOffHeapBINPri2(int idx) {</div>
<div style="background-color:limegreen;">2159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (entryStates[idx] & EntryStates.OFFHEAP_PRI2_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2161&emsp;&emsp;</div>
<div>2162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final INTargetRep getTargets() {</div>
<div>2163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryTargets;</div>
<div>2164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2165&emsp;&emsp;</div>
<div>2166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the idx'th target. No need to make dirty, that state only applies</div>
<div>2168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to key and LSN.</div>
<div>2169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * &#60;p>WARNING: This method does not update the memory budget.  The caller</div>
<div>2171&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * must update the budget.&#60;/p></div>
<div>2172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void setTarget(int idx, Node target) {</div>
<div>2174&emsp;&emsp;</div>
<div style="background-color:limegreen;">2175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner() :&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            "Not latched for write " + getClass().getName() +</div>
<div>2177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            " id=" + getNodeId();</div>
<div>2178&emsp;&emsp;</div>
<div>2179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Node curChild = entryTargets.get(idx);</div>
<div>2180&emsp;&emsp;</div>
<div>2181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = entryTargets.set(idx, target, this);</div>
<div>2182&emsp;&emsp;</div>
<div style="background-color:limegreen;">2183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (target != null && target.isIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ((IN) target).setParent(this);</div>
<div>2185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2186&emsp;&emsp;</div>
<div style="background-color:limegreen;">2187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isUpperIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (target == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2189&emsp;&emsp;</div>
<div>2190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>2191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * If this UIN has just lost its last cached child, set its</div>
<div>2192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * hasCachedChildren flag to false and put it back to the</div>
<div>2193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * LRU list.</div>
<div>2194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div style="background-color:limegreen;">2195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (curChild != null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    hasCachedChildrenFlag() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    !hasCachedChildren()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2198&emsp;&emsp;</div>
<div>2199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    setHasCachedChildrenFlag(false);</div>
<div>2200&emsp;&emsp;</div>
<div style="background-color:limegreen;">2201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (!isDIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        if (traceLRU) {</div>
<div>2203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            LoggerUtils.envLogMsg(</div>
<div>2204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                traceLevel, getEnv(),</div>
<div>2205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                Thread.currentThread().getId() + "-" +</div>
<div>2206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    Thread.currentThread().getName() +</div>
<div>2207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    "-" + getEnv().getName() +</div>
<div>2208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    " setTarget(): " +</div>
<div>2209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    " Adding UIN " + getNodeId() +</div>
<div>2210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    " to LRU after detaching chld " +</div>
<div>2211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                    ((IN) curChild).getNodeId());</div>
<div>2212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        }</div>
<div>2213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        getEvictor().addBack(this);</div>
<div>2214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div style="background-color:limegreen;">2217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (curChild == null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    !hasCachedChildrenFlag()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2219&emsp;&emsp;</div>
<div>2220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    setHasCachedChildrenFlag(true);</div>
<div>2221&emsp;&emsp;</div>
<div>2222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    if (traceLRU) {</div>
<div>2223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        LoggerUtils.envLogMsg(</div>
<div>2224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            traceLevel, getEnv(),</div>
<div>2225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            Thread.currentThread().getId() + "-" +</div>
<div>2226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                Thread.currentThread().getName() +</div>
<div>2227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                "-" + getEnv().getName() +</div>
<div>2228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                " setTarget(): " +</div>
<div>2229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                " Removing UIN " + getNodeId() +</div>
<div>2230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                " after attaching child " +</div>
<div>2231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                ((IN) target).getNodeId());</div>
<div>2232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getEvictor().remove(this);</div>
<div>2234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2238&emsp;&emsp;</div>
<div>2239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return the idx'th target.</div>
<div>2241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method does not load children from off-heap cache, so it always</div>
<div>2243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * returns null when then child is not in main cache. Note that when</div>
<div>2244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * children are INs (this is not a BIN), when this method returns null it</div>
<div>2245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is does not imply that the child is non-dirty, because dirty BINs are</div>
<div>2246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * stored off-heap. To fetch the current version from off-heap cache in</div>
<div>2247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * that case, call loadIN instead.</div>
<div>2248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final Node getTarget(int idx) {</div>
<div>2250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return entryTargets.get(idx);</div>
<div>2251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2252&emsp;&emsp;</div>
<div>2253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the idx-th child of "this" upper IN, fetching the child from</div>
<div>2255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the log and attaching it to its parent if it is not already attached.</div>
<div>2256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is used during tree searches.</div>
<div>2257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * On entry, the parent must be latched already.</div>
<div>2259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If the child must be fetched from the log, the parent is unlatched.</div>
<div>2261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * After the disk read is done, the parent is relatched. However, due to</div>
<div>2262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * splits, it may not be the correct parent anymore. If so, the method</div>
<div>2263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * will return null, and the caller is expected to restart the tree search.</div>
<div>2264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * On return, the parent will be latched, unless null is returned or an</div>
<div>2266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * exception is thrown.</div>
<div>2267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The "searchKey" param is the key that the caller is looking for. It is</div>
<div>2269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * used by this method in determining if, after a disk read, "this" is</div>
<div>2270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * still the correct parent for the child. "searchKey" may be null if the</div>
<div>2271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * caller is doing a LEFT or RIGHT search.</div>
<div>2272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final IN fetchINWithNoLatch(int idx,</div>
<div>2274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                byte [] searchKey,</div>
<div>2275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                CacheMode cacheMode) {</div>
<div>2276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return fetchINWithNoLatch(idx, searchKey, null, cacheMode);</div>
<div>2277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2278&emsp;&emsp;</div>
<div>2279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This variant of fetchIN() takes a SearchResult as a param, instead of</div>
<div>2281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * an idx (it is used by Tree.getParentINForChildIN()). The ordinal number</div>
<div>2282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * of the child to fetch is specified by result.index. result.index will</div>
<div>2283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be adjusted by this method if, after a disk read, the ordinal number</div>
<div>2284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * of the child changes due to insertions, deletions or splits in the</div>
<div>2285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parent.</div>
<div>2286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final IN fetchINWithNoLatch(SearchResult result,</div>
<div>2288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                byte [] searchKey,</div>
<div>2289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                CacheMode cacheMode) {</div>
<div>2290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return fetchINWithNoLatch(result.index, searchKey, result, cacheMode);</div>
<div>2291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2292&emsp;&emsp;</div>
<div>2293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Provides the implementation of the above two methods.</div>
<div>2295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private IN fetchINWithNoLatch(</div>
<div>2297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>2298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte [] searchKey,</div>
<div>2299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        SearchResult result,</div>
<div>2300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        CacheMode cacheMode) {</div>
<div>2301&emsp;&emsp;</div>
<div style="background-color:limegreen;">2302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isUpperIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isLatchOwner());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2304&emsp;&emsp;</div>
<div>2305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = getEnv();</div>
<div>2306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</div>
<div>2307&emsp;&emsp;</div>
<div>2308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean isMiss = false;</div>
<div>2309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean success = false;</div>
<div>2310&emsp;&emsp;</div>
<div>2311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN child = (IN)entryTargets.get(idx);</div>
<div>2312&emsp;&emsp;</div>
<div style="background-color:limegreen;">2313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2314&emsp;&emsp;</div>
<div>2315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final long lsn = getLsn(idx);</div>
<div>2316&emsp;&emsp;</div>
<div style="background-color:limegreen;">2317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lsn == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw unexpectedState(makeFetchErrorMsg(</div>
<div>2319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    "NULL_LSN in upper IN", lsn, idx));</div>
<div>2320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2321&emsp;&emsp;</div>
<div>2322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * For safety we must get a copy of the BIN off-heap bytes while</div>
<div>2324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * latched, but we can materialize the bytes while unlatched</div>
<div>2325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * (further below) to reduce the work done while latched.</div>
<div>2326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>2327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte[] ohBytes = null;</div>
<div>2328&emsp;&emsp;</div>
<div style="background-color:limegreen;">2329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (getNormalizedLevel() == 2) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ohBytes = ohCache.getBINBytes(this, idx);</div>
<div>2331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2332&emsp;&emsp;</div>
<div>2333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            pin();</div>
<div>2334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>2335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                releaseLatch();</div>
<div>2336&emsp;&emsp;</div>
<div>2337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                TestHookExecute.doHookIfSet(fetchINHook);</div>
<div>2338&emsp;&emsp;</div>
<div style="background-color:limegreen;">2339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (ohBytes != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child = ohCache.materializeBIN(envImpl, ohBytes);</div>
<div>2341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>2342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final WholeEntry wholeEntry = envImpl.getLogManager().</div>
<div>2343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        getLogEntryAllowInvisibleAtRecovery(</div>
<div>2344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            lsn, getLastLoggedSize(idx));</div>
<div>2345&emsp;&emsp;</div>
<div>2346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final LogEntry logEntry = wholeEntry.getEntry();</div>
<div>2347&emsp;&emsp;</div>
<div>2348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child = (IN) logEntry.getResolvedItem(databaseImpl);</div>
<div>2349&emsp;&emsp;</div>
<div>2350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    isMiss = true;</div>
<div>2351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2352&emsp;&emsp;</div>
<div>2353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                latch(CacheMode.UNCHANGED);</div>
<div>2354&emsp;&emsp;</div>
<div>2355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>2356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * The following if statement relies on splits being logged</div>
<div>2357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * immediately, or more precisely, the split node and its</div>
<div>2358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * new sibling being logged immediately, while both siblings</div>
<div>2359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * and their parent are latched exclusively. The reason for</div>
<div>2360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * this is as follows: </div>
<div>2361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * </div>
<div>2362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Let K be the search key. If we are doing a left-deep or</div>
<div>2363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * right-deep search, K is -INF or +INF respectively.</div>
<div>2364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Let P be the parent IN (i.e., "this") and S be the slot at</div>
<div>2366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * the idx position before P was unlatched above. Here, we</div>
<div>2367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * view slots as independent objects, not identified by their</div>
<div>2368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * position in an IN but by some unique (imaginary) and</div>
<div>2369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * immutable id assigned to the slot when it is first inserted</div>
<div>2370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * into an IN. </div>
<div>2371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Before unlatching P, S was the correct slot to follow down</div>
<div>2373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * the tree looking for K. After P is unlatched and then</div>
<div>2374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * relatched, let S' be the slot at the idx position, if P</div>
<div>2375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * still has an idx position. We consider the following 2 cases:</div>
<div>2376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * 1. S' exists and S'.LSN == S.LSN. Then S and S' are the same</div>
<div>2378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (logical) slot (because two different slots can never cover</div>
<div>2379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * overlapping ranges of keys, and as a result, can never point</div>
<div>2380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * to the same LSN). Then, S is still the correct slot to take</div>
<div>2381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * down the tree, unless the range of keys covered by S has</div>
<div>2382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * shrunk while P was unlatched. But the only way for S's key</div>
<div>2383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * range to shrink is for its child IN to split, which could</div>
<div>2384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * not have happened because if it did, the before and after</div>
<div>2385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * LSNs of S would be different, given that splits are logged</div>
<div>2386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * immediately. We conclude that the set of keys covered by</div>
<div>2387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * S after P is relatched is the same or a superset of the keys</div>
<div>2388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * covered by S before P was unlatched, and thus S (at the idx</div>
<div>2389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * position) is still the correct slot to follow.</div>
<div>2390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * 2. There is no idx position in P or S'.LSN != S.LSN. In</div>
<div>2392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * this case we cannot be sure if S' (if it exists) is the</div>
<div>2393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * the correct slot to follow. So, we (re)search for K in P</div>
<div>2394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * to check if P is still the correct parent and find the</div>
<div>2395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * correct slot to follow. If this search lands on the 1st or</div>
<div>2396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * last slot in P, we may return null because using the key</div>
<div>2397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * info contained in P only, we do not know the full range of</div>
<div>2398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * keys covered by those two slots. If null is returned, the</div>
<div>2399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * caller is expected to restart the tree search from the root.</div>
<div>2400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Notice that the if conditions are necessary before calling</div>
<div>2402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * findEntry(). Without them, we could get into an infinite</div>
<div>2403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * loop of search re-tries in the scenario where nothing changes</div>
<div>2404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * in the tree and findEntry always lands on the 1st or last</div>
<div>2405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * slot in P. The conditions guarantee that we may restart the</div>
<div>2406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * tree search only if something changes with S while P is</div>
<div>2407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * unlatched (S moves to a different position or a different</div>
<div>2408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * IN or it points to a different LSN).</div>
<div>2409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * </div>
<div>2410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Notice also that if P does not split while it is unlatched,</div>
<div>2411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * the range of keys covered by P does not change either. This</div>
<div>2412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * implies that the correct slot to follow *must* be inside P,</div>
<div>2413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * and as a result, the 1st and last slots in P can be trusted.</div>
<div>2414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Unfortunately, however, we have no way to detecting reliably</div>
<div>2415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * whether P splits or not.</div>
<div>2416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * </div>
<div>2417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Special care for DBs in DW mode:</div>
<div>2418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * For DBs in DW mode, special care must be taken because</div>
<div>2420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * splits are not immediately logged. So, for DW DBs, to avoid</div>
<div>2421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * a call to findEntry() we require that not only S'.LSN ==</div>
<div>2422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * S.LSN, but also the the child is not cached. These 2</div>
<div>2423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * conditions together guarantee that the child did not split</div>
<div>2424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * while P was unlatched, because if the child did split, it</div>
<div>2425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * was fetched and cached first, so after P is relatched,</div>
<div>2426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * either the child would be still cached, or if it was evicted</div>
<div>2427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * after the split, S.LSN would have changed.</div>
<div>2428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div style="background-color:limegreen;">2429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (idx >= nEntries ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    getLsn(idx) != lsn ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    (databaseImpl.isDeferredWriteMode() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                     entryTargets.get(idx) != null)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2433&emsp;&emsp;</div>
<div style="background-color:limegreen;">2434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (searchKey == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        return null;</div>
<div>2436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2437&emsp;&emsp;</div>
<div>2438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    idx = findEntry(searchKey, false, false);</div>
<div>2439&emsp;&emsp;</div>
<div style="background-color:limegreen;">2440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if ((idx == 0 || idx == nEntries - 1) &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                        !isKeyInBounds(searchKey)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        return null;</div>
<div>2443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2445&emsp;&emsp;</div>
<div style="background-color:limegreen;">2446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (result != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    result.index = idx;</div>
<div>2448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2449&emsp;&emsp;</div>
<div>2450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>2451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * "this" is still the correct parent and "idx" points to the</div>
<div>2452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * correct slot to follow for the search down the tree. But</div>
<div>2453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * what we fetched from the log may be out-of-date by now</div>
<div>2454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (because it was fetched and then updated by other threads)</div>
<div>2455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * or it may not be the correct child anymore ("idx" was</div>
<div>2456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * changed by the findEntry() call above). We check 5 cases:</div>
<div>2457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (a) There is already a cached child at the "idx" position.</div>
<div>2459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * In this case, we return whatever is there because it has to</div>
<div>2460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * be the most recent version of the appropriate child node.</div>
<div>2461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * This is true even when a split or reverse split occurred.</div>
<div>2462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * The check for isKeyInBounds above is critical in that case.</div>
<div>2463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (b) There is no cached child at the "idx" slot, but the slot</div>
<div>2465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * LSN is not the same as the LSN we read from the log. This is</div>
<div>2466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * the case if "idx" was changed by findEntry() or other</div>
<div>2467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * threads fetched the same child as this thread, updated it,</div>
<div>2468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * and then evicted it. The child we fetched is obsolete and</div>
<div>2469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * should not be attached. For simplicity, we just return null</div>
<div>2470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * in this (quite rare) case.</div>
<div>2471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (c) We loaded the BIN from off-heap cache and, similar to</div>
<div>2473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * case (b), another thread has loaded the same child, modified</div>
<div>2474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * it, and then evicted it, placing it off-heap again. It's LSN</div>
<div>2475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * did not change because it wasn't logged. We determine</div>
<div>2476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * whether the off-heap BIN has changed, and if so then</div>
<div>2477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * null is returned. This is also rare.</div>
<div>2478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (d) The child was loaded from disk (not off-heap cache) but</div>
<div>2480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * an off-heap cache entry for this BIN has appeared. Another</div>
<div>2481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * thread loaded the BIN from disk and then it was moved</div>
<div>2482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * off-heap, possibly after it was modified. We should use the</div>
<div>2483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * off-heap version and for simplicity we return null. This is</div>
<div>2484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * also rare.</div>
<div>2485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * (e) Otherwise, we attach the fetched/loaded child to the</div>
<div>2487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * parent.</div>
<div>2488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div style="background-color:limegreen;">2489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (entryTargets.get(idx) != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child = (IN) entryTargets.get(idx);</div>
<div>2491&emsp;&emsp;</div>
<div style="background-color:limegreen;">2492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                } else if (getLsn(idx) != lsn) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return null;</div>
<div>2494&emsp;&emsp;</div>
<div style="background-color:limegreen;">2495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                } else if (ohBytes != null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                           ohCache.haveBINBytesChanged(this, idx, ohBytes)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return null;</div>
<div>2498&emsp;&emsp;</div>
<div style="background-color:limegreen;">2499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                } else if (ohBytes == null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                           getOffHeapBINId(idx) >= 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return null;</div>
<div>2502&emsp;&emsp;</div>
<div>2503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>2504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.latchNoUpdateLRU(databaseImpl);</div>
<div>2505&emsp;&emsp;</div>
<div style="background-color:limegreen;">2506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (ohBytes != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        child.postLoadInit(this, idx);</div>
<div>2508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    } else {</div>
<div>2509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        child.postFetchInit(databaseImpl, lsn);</div>
<div>2510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2511&emsp;&emsp;</div>
<div>2512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    attachNode(idx, child, null);</div>
<div>2513&emsp;&emsp;</div>
<div>2514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.releaseLatch();</div>
<div>2515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2516&emsp;&emsp;</div>
<div>2517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                success = true;</div>
<div>2518&emsp;&emsp;</div>
<div>2519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (FileNotFoundException e) {</div>
<div>2520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new EnvironmentFailureException(</div>
<div>2521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,</div>
<div>2522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg(null, lsn, idx), e);</div>
<div>2523&emsp;&emsp;</div>
<div>2524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (EnvironmentFailureException e) {</div>
<div>2525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                e.addErrorMessage(makeFetchErrorMsg(null, lsn, idx));</div>
<div>2526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw e;</div>
<div>2527&emsp;&emsp;</div>
<div>2528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (RuntimeException e) {</div>
<div>2529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new EnvironmentFailureException(</div>
<div>2530&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl, EnvironmentFailureReason.LOG_INTEGRITY,</div>
<div>2531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg(e.toString(), lsn, idx), e);</div>
<div>2532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } finally {</div>
<div>2533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>2534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Release the parent latch if null is being returned. In this</div>
<div>2535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * case, the parent was unlatched earlier during the disk read,</div>
<div>2536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * and as a result, the caller cannot make any assumptions</div>
<div>2537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * about the state of the parent.</div>
<div>2538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 *</div>
<div>2539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * If we are returning or throwing out of this try block, the</div>
<div>2540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * parent may or may not be latched. So, only release the latch</div>
<div>2541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * if it is currently held.</div>
<div>2542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div>2543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (!success) {</div>
<div style="background-color:limegreen;">2544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (child != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        child.incFetchStats(envImpl, isMiss);</div>
<div>2546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2547&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    releaseLatchIfOwner();</div>
<div>2548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2549&emsp;&emsp;</div>
<div>2550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                unpin();</div>
<div>2551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2553&emsp;&emsp;</div>
<div style="background-color:limegreen;">2554&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2555&emsp;&emsp;</div>
<div>2556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        child.incFetchStats(envImpl, isMiss);</div>
<div>2557&emsp;&emsp;</div>
<div>2558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return child;</div>
<div>2559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2560&emsp;&emsp;</div>
<div>2561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the idx-th child of "this" upper IN, fetching the child from</div>
<div>2563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the log and attaching it to its parent if it is not already attached.</div>
<div>2564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * On entry, the parent must be EX-latched already and it stays EX-latched</div>
<div>2566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the duration of this method and on return (even in case of</div>
<div>2567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * exceptions).</div>
<div>2568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param idx The slot of the child to fetch.</div>
<div>2570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN fetchIN(int idx, CacheMode cacheMode) {</div>
<div>2572&emsp;&emsp;</div>
<div style="background-color:limegreen;">2573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isUpperIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isLatchExclusiveOwner()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw unexpectedState("EX-latch not held before fetch");</div>
<div>2576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2577&emsp;&emsp;</div>
<div>2578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = getEnv();</div>
<div>2579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</div>
<div>2580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean isMiss = false;</div>
<div>2581&emsp;&emsp;</div>
<div>2582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN child = (IN) entryTargets.get(idx);</div>
<div>2583&emsp;&emsp;</div>
<div style="background-color:limegreen;">2584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2585&emsp;&emsp;</div>
<div>2586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final long lsn = getLsn(idx);</div>
<div>2587&emsp;&emsp;</div>
<div style="background-color:limegreen;">2588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lsn == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw unexpectedState(</div>
<div>2590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg("NULL_LSN in upper IN", lsn, idx));</div>
<div>2591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2592&emsp;&emsp;</div>
<div>2593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>2594&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] ohBytes = null;</div>
<div>2595&emsp;&emsp;</div>
<div style="background-color:limegreen;">2596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (getNormalizedLevel() == 2) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    ohBytes = ohCache.getBINBytes(this, idx);</div>
<div style="background-color:limegreen;">2598&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (ohBytes != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        child = ohCache.materializeBIN(envImpl, ohBytes);</div>
<div>2600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2602&emsp;&emsp;</div>
<div style="background-color:limegreen;">2603&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (child == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final WholeEntry wholeEntry = envImpl.getLogManager().</div>
<div>2605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        getLogEntryAllowInvisibleAtRecovery(</div>
<div>2606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            lsn, getLastLoggedSize(idx));</div>
<div>2607&emsp;&emsp;</div>
<div>2608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final LogEntry logEntry = wholeEntry.getEntry();</div>
<div>2609&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child = (IN) logEntry.getResolvedItem(databaseImpl);</div>
<div>2610&emsp;&emsp;</div>
<div>2611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    isMiss = true;</div>
<div>2612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2613&emsp;&emsp;</div>
<div>2614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child.latchNoUpdateLRU(databaseImpl);</div>
<div>2615&emsp;&emsp;</div>
<div style="background-color:limegreen;">2616&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (ohBytes != null) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>2617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.postLoadInit(this, idx);</div>
<div>2618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>2619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.postFetchInit(databaseImpl, lsn);</div>
<div>2620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2621&emsp;&emsp;</div>
<div>2622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                attachNode(idx, child, null);</div>
<div>2623&emsp;&emsp;</div>
<div>2624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child.releaseLatch();</div>
<div>2625&emsp;&emsp;</div>
<div>2626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (FileNotFoundException e) {</div>
<div>2627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new EnvironmentFailureException(</div>
<div>2628&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,</div>
<div>2629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg(null, lsn, idx), e);</div>
<div>2630&emsp;&emsp;</div>
<div>2631&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (EnvironmentFailureException e) {</div>
<div>2632&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                e.addErrorMessage(makeFetchErrorMsg(null, lsn, idx));</div>
<div>2633&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw e;</div>
<div>2634&emsp;&emsp;</div>
<div>2635&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (RuntimeException e) {</div>
<div>2636&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new EnvironmentFailureException(</div>
<div>2637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl, EnvironmentFailureReason.LOG_INTEGRITY,</div>
<div>2638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg(e.toString(), lsn, idx), e);</div>
<div>2639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2641&emsp;&emsp;</div>
<div style="background-color:limegreen;">2642&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2643&emsp;&emsp;</div>
<div>2644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        child.incFetchStats(envImpl, isMiss);</div>
<div>2645&emsp;&emsp;</div>
<div>2646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return child;</div>
<div>2647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2648&emsp;&emsp;</div>
<div>2649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the idx-th child of "this" upper IN, loading the child from</div>
<div>2651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * off-heap and attaching it to its parent if it is not already attached</div>
<div>2652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and is cached off-heap. This method does not fetch from disk, and will</div>
<div>2653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * return null if the child is not in the main or off-heap cache.</div>
<div>2654&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * On entry, the parent must be EX-latched already and it stays EX-latched</div>
<div>2656&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the duration of this method and on return (even in case of</div>
<div>2657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * exceptions).</div>
<div>2658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param idx The slot of the child to fetch.</div>
<div>2660&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2661&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return null if the LN is not in the main or off-heap cache.</div>
<div>2662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2663&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN loadIN(int idx, CacheMode cacheMode) {</div>
<div>2664&emsp;&emsp;</div>
<div style="background-color:limegreen;">2665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isUpperIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isLatchExclusiveOwner()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw unexpectedState("EX-latch not held before load");</div>
<div>2668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2669&emsp;&emsp;</div>
<div>2670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN child = (IN) entryTargets.get(idx);</div>
<div>2671&emsp;&emsp;</div>
<div style="background-color:limegreen;">2672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return child;</div>
<div>2674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2675&emsp;&emsp;</div>
<div style="background-color:limegreen;">2676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getNormalizedLevel() != 2) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return null;</div>
<div>2678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2679&emsp;&emsp;</div>
<div>2680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = getEnv();</div>
<div>2681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</div>
<div>2682&emsp;&emsp;</div>
<div>2683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long lsn = getLsn(idx);</div>
<div>2684&emsp;&emsp;</div>
<div>2685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        try {</div>
<div>2686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final byte[] ohBytes = ohCache.getBINBytes(this, idx);</div>
<div style="background-color:limegreen;">2687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (ohBytes == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>2688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return null;</div>
<div>2689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2690&emsp;&emsp;</div>
<div>2691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            child = ohCache.materializeBIN(envImpl, ohBytes);</div>
<div>2692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            child.latchNoUpdateLRU(databaseImpl);</div>
<div>2693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            child.postLoadInit(this, idx);</div>
<div>2694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            attachNode(idx, child, null);</div>
<div>2695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            child.releaseLatch();</div>
<div>2696&emsp;&emsp;</div>
<div>2697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return child;</div>
<div>2698&emsp;&emsp;</div>
<div>2699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } catch (RuntimeException e) {</div>
<div>2700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw new EnvironmentFailureException(</div>
<div>2701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                envImpl, EnvironmentFailureReason.LOG_INTEGRITY,</div>
<div>2702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                makeFetchErrorMsg(e.toString(), lsn, idx), e);</div>
<div>2703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2705&emsp;&emsp;</div>
<div>2706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the target of the idx'th entry, fetching from disk if necessary.</div>
<div>2708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Null is returned in the following cases:</div>
<div>2710&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 1. if the LSN is null and the KnownDeleted flag is set; or</div>
<div>2712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * 2. if the LSN's file has been cleaned and:</div>
<div>2713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    a. the PendingDeleted or KnownDeleted flag is set, or</div>
<div>2714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    b. the entry is "probably expired".</div>
<div>2715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note that checking for PD/KD before calling this method is not</div>
<div>2717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * sufficient to ensure that null is not returned, because null is also</div>
<div>2718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * returned for expired records.</div>
<div>2719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * When null is returned, the caller must treat the record as deleted.</div>
<div>2721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note that null can only be returned for a slot that could contain an LN,</div>
<div>2723&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * not other node types and not a DupCountLN since DupCountLNs are never</div>
<div>2724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * deleted or expired.</div>
<div>2725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * An exclusive latch must be held on this BIN.</div>
<div>2727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return the LN or null.</div>
<div>2729&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final LN fetchLN(int idx, CacheMode cacheMode) {</div>
<div>2731&emsp;&emsp;</div>
<div>2732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (LN) fetchLN(idx, cacheMode, false);</div>
<div>2733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2734&emsp;&emsp;</div>
<div>2735&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>2736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method may return either an LN or a DIN child of a BIN. It is meant</div>
<div>2737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to be used from DupConvert only.</div>
<div>2738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final Node fetchLNOrDIN(int idx, CacheMode cacheMode) {</div>
<div>2740&emsp;&emsp;</div>
<div>2741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return fetchLN(idx, cacheMode, true);</div>
<div>2742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2743&emsp;&emsp;</div>
<div>2744&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>2745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Underlying implementation of the above fetchLNXXX methods.</div>
<div>2746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private Node fetchLN(int idx, CacheMode cacheMode, boolean dupConvert) {</div>
<div>2748&emsp;&emsp;</div>
<div style="background-color:limegreen;">2749&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2750&emsp;&emsp;</div>
<div style="background-color:limegreen;">2751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isLatchExclusiveOwner()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw unexpectedState("EX-latch not held before fetch");</div>
<div>2753&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2754&emsp;&emsp;</div>
<div style="background-color:limegreen;">2755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isEntryKnownDeleted(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return null;</div>
<div>2757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2758&emsp;&emsp;</div>
<div>2759&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN bin = (BIN) this;</div>
<div>2760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = getEnv();</div>
<div>2761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</div>
<div>2762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean isMiss = false;</div>
<div>2763&emsp;&emsp;</div>
<div>2764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child = entryTargets.get(idx);</div>
<div>2765&emsp;&emsp;</div>
<div>2766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Fetch it from disk. */</div>
<div style="background-color:limegreen;">2767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2768&emsp;&emsp;</div>
<div>2769&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final long lsn = getLsn(idx);</div>
<div>2770&emsp;&emsp;</div>
<div style="background-color:limegreen;">2771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (lsn == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw unexpectedState(makeFetchErrorMsg(</div>
<div>2773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    "NULL_LSN without KnownDeleted", lsn, idx));</div>
<div>2774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2775&emsp;&emsp;</div>
<div>2776&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>2777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Fetch of immediately obsolete LN not allowed. The only exception</div>
<div>2778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * is during conversion of an old-style dups DB.</div>
<div>2779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">2780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isEmbeddedLN(idx) ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                (databaseImpl.isLNImmediatelyObsolete() && !dupConvert)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw unexpectedState("May not fetch immediately obsolete LN");</div>
<div>2783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2784&emsp;&emsp;</div>
<div>2785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>2786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] lnSlotKey = null;</div>
<div>2787&emsp;&emsp;</div>
<div>2788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child = ohCache.loadLN(bin, idx, cacheMode);</div>
<div>2789&emsp;&emsp;</div>
<div style="background-color:limegreen;">2790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (child == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final WholeEntry wholeEntry = envImpl.getLogManager().</div>
<div>2792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        getLogEntryAllowInvisibleAtRecovery(</div>
<div>2793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            lsn, getLastLoggedSize(idx));</div>
<div>2794&emsp;&emsp;</div>
<div>2795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    /* Last logged size is not present before log version 9. */</div>
<div>2796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    setLastLoggedSize(</div>
<div>2797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        idx, wholeEntry.getHeader().getEntrySize());</div>
<div>2798&emsp;&emsp;</div>
<div>2799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    final LogEntry logEntry = wholeEntry.getEntry();</div>
<div>2800&emsp;&emsp;</div>
<div style="background-color:limegreen;">2801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (logEntry instanceof LNLogEntry) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2802&emsp;&emsp;</div>
<div>2803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        final LNLogEntry&#60;?> lnEntry =</div>
<div>2804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            (LNLogEntry&#60;?>) wholeEntry.getEntry();</div>
<div>2805&emsp;&emsp;</div>
<div>2806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        lnEntry.postFetchInit(databaseImpl);</div>
<div>2807&emsp;&emsp;</div>
<div>2808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        lnSlotKey = lnEntry.getKey();</div>
<div>2809&emsp;&emsp;</div>
<div style="background-color:limegreen;">2810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                        if (cacheMode != CacheMode.EVICT_LN &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            cacheMode != CacheMode.EVICT_BIN &&</div>
<div>2812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            cacheMode != CacheMode.UNCHANGED &&</div>
<div>2813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            cacheMode != CacheMode.MAKE_COLD) {</div>
<div>2814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            getEvictor().moveToPri1LRU(this);</div>
<div>2815&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        }</div>
<div>2816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>2817&emsp;&emsp;</div>
<div>2818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child = (Node) logEntry.getResolvedItem(databaseImpl);</div>
<div>2819&emsp;&emsp;</div>
<div>2820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    isMiss = true;</div>
<div>2821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2822&emsp;&emsp;</div>
<div>2823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child.postFetchInit(databaseImpl, lsn);</div>
<div>2824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                attachNode(idx, child, lnSlotKey);</div>
<div>2825&emsp;&emsp;</div>
<div>2826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (FileNotFoundException e) {</div>
<div>2827&emsp;&emsp;</div>
<div style="background-color:limegreen;">2828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (!bin.isDeleted(idx) &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    !bin.isProbablyExpired(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2830&emsp;&emsp;</div>
<div>2831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    throw new EnvironmentFailureException(</div>
<div>2832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,</div>
<div>2833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         makeFetchErrorMsg(null, lsn, idx), e);</div>
<div>2834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>2835&emsp;&emsp;</div>
<div>2836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>2837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Cleaner got to the log file, so just return null. It is safe</div>
<div>2838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * to ignore a deleted file for a KD or PD entry because files</div>
<div>2839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * with active txns will not be cleaned.</div>
<div>2840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div>2841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return null;</div>
<div>2842&emsp;&emsp;</div>
<div>2843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (EnvironmentFailureException e) {</div>
<div>2844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                e.addErrorMessage(makeFetchErrorMsg(null, lsn, idx));</div>
<div>2845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw e;</div>
<div>2846&emsp;&emsp;</div>
<div>2847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (RuntimeException e) {</div>
<div>2848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new EnvironmentFailureException(</div>
<div>2849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl, EnvironmentFailureReason.LOG_INTEGRITY,</div>
<div>2850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg(e.toString(), lsn, idx), e);</div>
<div>2851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2853&emsp;&emsp;</div>
<div style="background-color:limegreen;">2854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child.isLN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2855&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final LN ln = (LN) child;</div>
<div>2856&emsp;&emsp;</div>
<div style="background-color:limegreen;">2857&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (cacheMode != CacheMode.UNCHANGED &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                cacheMode != CacheMode.MAKE_COLD) {</div>
<div>2859&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ln.setFetchedCold(false);</div>
<div>2860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2861&emsp;&emsp;</div>
<div>2862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.freeRedundantLN(bin, idx, ln, cacheMode);</div>
<div>2863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2864&emsp;&emsp;</div>
<div>2865&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        child.incFetchStats(envImpl, isMiss);</div>
<div>2866&emsp;&emsp;</div>
<div>2867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return child;</div>
<div>2868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2869&emsp;&emsp;</div>
<div>2870&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2871&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return the idx'th LN target, enforcing rules defined by the cache modes</div>
<div>2872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the LN. This method should be called instead of getTarget when a</div>
<div>2873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cache mode applies to user operations such as reads and updates.</div>
<div>2874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final LN getLN(int idx, CacheMode cacheMode) {</div>
<div style="background-color:limegreen;">2876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isBIN();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2877&emsp;&emsp;</div>
<div>2878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final LN ln = (LN) entryTargets.get(idx);</div>
<div>2879&emsp;&emsp;</div>
<div style="background-color:limegreen;">2880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ln == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return null;</div>
<div>2882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2883&emsp;&emsp;</div>
<div style="background-color:limegreen;">2884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (cacheMode != CacheMode.UNCHANGED &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cacheMode != CacheMode.MAKE_COLD) {</div>
<div>2886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ln.setFetchedCold(false);</div>
<div>2887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2888&emsp;&emsp;</div>
<div>2889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</div>
<div>2890&emsp;&emsp;</div>
<div style="background-color:limegreen;">2891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (ohCache.isEnabled()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.freeRedundantLN((BIN) this, idx, ln, cacheMode);</div>
<div>2893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2894&emsp;&emsp;</div>
<div>2895&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ln;</div>
<div>2896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2897&emsp;&emsp;</div>
<div>2898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Initialize a node that has been read in from the log.</div>
<div>2900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>2902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void postFetchInit(DatabaseImpl db, long fetchedLsn) {</div>
<div style="background-color:limegreen;">2903&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2904&emsp;&emsp;</div>
<div>2905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        commonInit(db);</div>
<div>2906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedLsn(fetchedLsn);</div>
<div>2907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        convertDupKeys(); // must be after initMemorySize</div>
<div>2908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        addToMainCache();</div>
<div>2909&emsp;&emsp;</div>
<div style="background-color:limegreen;">2910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFetchedCold(true);</div>
<div>2912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2913&emsp;&emsp;</div>
<div>2914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* See Database.mutateDeferredWriteBINDeltas. */</div>
<div style="background-color:limegreen;">2915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (db.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            mutateToFullBIN(false);</div>
<div>2917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2919&emsp;&emsp;</div>
<div>2920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Initialize a BIN loaded from off-heap cache.</div>
<div>2922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>2923&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Does not call setLastLoggedLsn because materialization of the off-heap</div>
<div>2924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN initializes all fields including the last logged/delta LSNs.</div>
<div>2925&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void postLoadInit(IN parent, int idx) {</div>
<div style="background-color:limegreen;">2927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2928&emsp;&emsp;</div>
<div>2929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        commonInit(parent.databaseImpl);</div>
<div>2930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        addToMainCache();</div>
<div>2931&emsp;&emsp;</div>
<div style="background-color:limegreen;">2932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFetchedCold(true);</div>
<div>2934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setFetchedColdOffHeap(true);</div>
<div>2935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2936&emsp;&emsp;</div>
<div>2937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEnv().getOffHeapCache().postBINLoad(parent, idx, (BIN) this);</div>
<div>2938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2939&emsp;&emsp;</div>
<div>2940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Initialize a node read in during recovery.</div>
<div>2942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void postRecoveryInit(DatabaseImpl db, long lastLoggedLsn) {</div>
<div>2944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        commonInit(db);</div>
<div>2945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedLsn(lastLoggedLsn);</div>
<div>2946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2947&emsp;&emsp;</div>
<div>2948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Common actions of postFetchInit, postLoadInit and postRecoveryInit.</div>
<div>2950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void commonInit(DatabaseImpl db) {</div>
<div>2952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDatabase(db);</div>
<div>2953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        initMemorySize(); // compute before adding to IN list</div>
<div>2954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2955&emsp;&emsp;</div>
<div>2956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Add to INList and perform eviction related initialization.</div>
<div>2958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void addToMainCache() {</div>
<div>2960&emsp;&emsp;</div>
<div>2961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        getEnv().getInMemoryINs().add(this);</div>
<div>2962&emsp;&emsp;</div>
<div style="background-color:limegreen;">2963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isDIN() && !isDBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">2964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isUpperIN() && traceLRU) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LoggerUtils.envLogMsg(</div>
<div>2966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    traceLevel, getEnv(),</div>
<div>2967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    Thread.currentThread().getId() + "-" +</div>
<div>2968&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    Thread.currentThread().getName() +</div>
<div>2969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    "-" + getEnv().getName() +</div>
<div>2970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    " postFetchInit(): " +</div>
<div>2971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    " Adding UIN to LRU: " + getNodeId());</div>
<div>2972&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>2973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEvictor().addBack(this);</div>
<div>2974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2975&emsp;&emsp;</div>
<div>2976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Compress full BINs after fetching or loading. */</div>
<div style="background-color:limegreen;">2977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!(this instanceof DBIN || this instanceof DIN)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEnv().lazyCompress(this);</div>
<div>2979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2981&emsp;&emsp;</div>
<div>2982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>2983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Needed only during duplicates conversion, not during normal operation.</div>
<div>2984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The needDupKeyConversion field will only be true when first upgrading</div>
<div>2985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * from JE 4.1.  After the first time an IN is converted, it will be</div>
<div>2986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * written out in a later file format, so the needDupKeyConversion field</div>
<div>2987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * will be false and this method will do nothing.  See</div>
<div>2988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * DupConvert.convertInKeys.</div>
<div>2989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>2990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void convertDupKeys() {</div>
<div>2991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Do not convert more than once. */</div>
<div style="background-color:limegreen;">2992&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!needDupKeyConversion) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>2993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>2994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>2995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        needDupKeyConversion = false;</div>
<div>2996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        DupConvert.convertInKeys(databaseImpl, this);</div>
<div>2997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>2998&emsp;&emsp;</div>
<div>2999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see Node#incFetchStats</div>
<div>3001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>3003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void incFetchStats(EnvironmentImpl envImpl, boolean isMiss) {</div>
<div>3004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Evictor e = envImpl.getEvictor();</div>
<div style="background-color:limegreen;">3005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            e.incBINFetchStats(isMiss, isBINDelta(false/*checLatched*/));</div>
<div>3007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            e.incUINFetchStats(isMiss);</div>
<div>3009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3011&emsp;&emsp;</div>
<div>3012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String makeFetchErrorMsg(</div>
<div>3013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final String msg,</div>
<div>3014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long lsn,</div>
<div>3015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int idx) {</div>
<div>3016&emsp;&emsp;</div>
<div style="background-color:limegreen;">3017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final byte state = idx >= 0 ? entryStates[idx] : 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3018&emsp;&emsp;</div>
<div>3019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long expirationTime;</div>
<div>3020&emsp;&emsp;</div>
<div style="background-color:limegreen;">3021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN() && idx >= 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3022&emsp;&emsp;</div>
<div>3023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final BIN bin = (BIN) this;</div>
<div>3024&emsp;&emsp;</div>
<div>3025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expirationTime = TTL.expirationToSystemTime(</div>
<div>3026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.getExpiration(idx), isExpirationInHours());</div>
<div>3027&emsp;&emsp;</div>
<div>3028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            expirationTime = 0;</div>
<div>3030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3031&emsp;&emsp;</div>
<div>3032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return makeFetchErrorMsg(msg, this, lsn, state, expirationTime);</div>
<div>3033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3034&emsp;&emsp;</div>
<div>3035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param in parent IN.  Is null when root is fetched.</div>
<div>3037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    static String makeFetchErrorMsg(</div>
<div>3039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        String msg,</div>
<div>3040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN in,</div>
<div>3041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long lsn,</div>
<div>3042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte state,</div>
<div>3043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long expirationTime) {</div>
<div>3044&emsp;&emsp;</div>
<div>3045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Bolster the exception with the LSN, which is critical for</div>
<div>3047&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * debugging. Otherwise, the exception propagates upward and loses the</div>
<div>3048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * problem LSN.</div>
<div>3049&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        StringBuilder sb = new StringBuilder();</div>
<div>3051&emsp;&emsp;</div>
<div style="background-color:limegreen;">3052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (in == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("fetchRoot of ");</div>
<div style="background-color:limegreen;">3054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (in.isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("fetchLN of ");</div>
<div>3056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("fetchIN of ");</div>
<div>3058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3059&emsp;&emsp;</div>
<div style="background-color:limegreen;">3060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (lsn == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("null lsn");</div>
<div>3062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3063&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(DbLsn.getNoFormatString(lsn));</div>
<div>3064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3065&emsp;&emsp;</div>
<div style="background-color:limegreen;">3066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (in != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" parent IN=").append(in.getNodeId());</div>
<div>3068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" IN class=").append(in.getClass().getName());</div>
<div>3069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" lastFullLsn=");</div>
<div>3070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(DbLsn.getNoFormatString(in.getLastFullLsn()));</div>
<div>3071&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" lastLoggedLsn=");</div>
<div>3072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(DbLsn.getNoFormatString(in.getLastLoggedLsn()));</div>
<div>3073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" parent.getDirty()=").append(in.getDirty());</div>
<div>3074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3075&emsp;&emsp;</div>
<div>3076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(" state=").append(state);</div>
<div>3077&emsp;&emsp;</div>
<div>3078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(" expires=");</div>
<div>3079&emsp;&emsp;</div>
<div style="background-color:limegreen;">3080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (expirationTime != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TTL.formatExpirationTime(expirationTime));</div>
<div>3082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("never");</div>
<div>3084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3085&emsp;&emsp;</div>
<div style="background-color:limegreen;">3086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (msg != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" ").append(msg);</div>
<div>3088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3089&emsp;&emsp;</div>
<div>3090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return sb.toString();</div>
<div>3091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3092&emsp;&emsp;</div>
<div>3093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int findEntry(</div>
<div>3094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean indicateIfDuplicate,</div>
<div>3096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean exact) {</div>
<div>3097&emsp;&emsp;</div>
<div>3098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return findEntry(key, indicateIfDuplicate, exact, null /*Comparator*/);</div>
<div>3099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3100&emsp;&emsp;</div>
<div>3101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Find the entry in this IN for which key is LTE the key arg.</div>
<div>3103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Currently uses a binary search, but eventually, this may use binary or</div>
<div>3105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * linear search depending on key size, number of entries, etc.</div>
<div>3106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3107&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method guarantees that the key parameter, which is the user's key</div>
<div>3108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parameter in user-initiated search operations, is always the left hand</div>
<div>3109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parameter to the Comparator.compare method.  This allows a comparator</div>
<div>3110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to perform specialized searches, when passed down from upper layers.</div>
<div>3111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This is public so that DbCursorTest can access it.</div>
<div>3113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note that the 0'th entry's key is treated specially in an IN.  It always</div>
<div>3115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * compares lower than any other key.</div>
<div>3116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param key - the key to search for.</div>
<div>3118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param indicateIfDuplicate - true if EXACT_MATCH should</div>
<div>3119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be or'd onto the return value if key is already present in this node.</div>
<div>3120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param exact - true if an exact match must be found.</div>
<div>3121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return offset for the entry that has a key LTE the arg.  0 if key</div>
<div>3122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is less than the 1st entry.  -1 if exact is true and no exact match</div>
<div>3123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is found.  If indicateIfDuplicate is true and an exact match was found</div>
<div>3124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * then EXACT_MATCH is or'd onto the return value.</div>
<div>3125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int findEntry(</div>
<div>3127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean indicateIfDuplicate,</div>
<div>3129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean exact,</div>
<div>3130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Comparator&#60;byte[]> comparator) {</div>
<div>3131&emsp;&emsp;</div>
<div style="background-color:limegreen;">3132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert idKeyIsSlotKey();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3133&emsp;&emsp;</div>
<div>3134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int high = nEntries - 1;</div>
<div>3135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int low = 0;</div>
<div>3136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int middle = 0;</div>
<div>3137&emsp;&emsp;</div>
<div style="background-color:limegreen;">3138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (comparator == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            comparator = databaseImpl.getKeyComparator();</div>
<div>3140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3141&emsp;&emsp;</div>
<div>3142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Special Treatment of 0th Entry</div>
<div>3144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * ------------------------------</div>
<div>3145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * IN's are special in that they have a entry[0] where the key is a</div>
<div>3146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * virtual key in that it always compares lower than any other key.</div>
<div>3147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * BIN's don't treat key[0] specially.  But if the caller asked for an</div>
<div>3148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * exact match or to indicate duplicates, then use the key[0] and</div>
<div>3149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * forget about the special entry zero comparison.</div>
<div>3150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>3151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * We always use inexact searching to get down to the BIN, and then</div>
<div>3152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * call findEntry separately on the BIN if necessary.  So the behavior</div>
<div>3153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * of findEntry is different for BINs and INs, because it's used in</div>
<div>3154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * different ways.</div>
<div>3155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>3156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Consider a tree where the lowest key is "b" and we want to insert</div>
<div>3157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * "a".  If we did the comparison (with exact == false), we wouldn't</div>
<div>3158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * find the correct (i.e.  the left) path down the tree.  So the</div>
<div>3159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * virtual key ensures that "a" gets inserted down the left path.</div>
<div>3160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>3161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * The insertion case is a good specific example.  findBinForInsert</div>
<div>3162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * does inexact searching in the INs only, not the BIN.</div>
<div>3163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>3164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * There's nothing special about the 0th key itself, only the use of</div>
<div>3165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the 0th key in the comparison algorithm.</div>
<div>3166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean entryZeroSpecialCompare =</div>
<div style="background-color:limegreen;">3168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            isUpperIN() && !exact && !indicateIfDuplicate;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3169&emsp;&emsp;</div>
<div style="background-color:limegreen;">3170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert nEntries >= 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3171&emsp;&emsp;</div>
<div style="background-color:limegreen;">3172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        while (low &#60;= high) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3173&emsp;&emsp;</div>
<div>3174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            middle = (high + low) / 2;</div>
<div>3175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int s;</div>
<div>3176&emsp;&emsp;</div>
<div style="background-color:limegreen;">3177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (middle == 0 && entryZeroSpecialCompare) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                s = 1;</div>
<div>3179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>3180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                s = entryKeys.compareKeys(</div>
<div>3181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    key,  keyPrefix, middle,</div>
<div>3182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    haveEmbeddedData(middle), comparator);</div>
<div>3183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3184&emsp;&emsp;</div>
<div style="background-color:limegreen;">3185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (s &#60; 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                high = middle - 1;</div>
<div style="background-color:limegreen;">3187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            } else if (s > 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                low = middle + 1;</div>
<div>3189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>3190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int ret;</div>
<div style="background-color:limegreen;">3191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (indicateIfDuplicate) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    ret = middle | EXACT_MATCH;</div>
<div>3193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>3194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    ret = middle;</div>
<div>3195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>3196&emsp;&emsp;</div>
<div style="background-color:limegreen;">3197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if ((ret >= 0) && exact && isEntryKnownDeleted(ret & 0xffff)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return -1;</div>
<div>3199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>3200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return ret;</div>
<div>3201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>3202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3204&emsp;&emsp;</div>
<div>3205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * No match found.  Either return -1 if caller wanted exact matches</div>
<div>3207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * only, or return entry whose key is &#60; search key.</div>
<div>3208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">3209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (exact) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return -1;</div>
<div>3211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return high;</div>
<div>3213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3215&emsp;&emsp;</div>
<div>3216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Inserts a slot with the given key, lsn and child node into this IN, if</div>
<div>3218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a slot with the same key does not exist already. The state of the new</div>
<div>3219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot is set to DIRTY. Assumes this node is already latched by the</div>
<div>3220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * caller.</div>
<div>3221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if the entry was successfully inserted, false</div>
<div>3223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if it was a duplicate.</div>
<div>3224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @throws EnvironmentFailureException if the node is full</div>
<div>3226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (it should have been split earlier).</div>
<div>3227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean insertEntry(</div>
<div>3229&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child,</div>
<div>3230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long childLsn)</div>
<div>3232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>3233&emsp;&emsp;</div>
<div style="background-color:limegreen;">3234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3235&emsp;&emsp;</div>
<div>3236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int res = insertEntry1(</div>
<div>3237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             child, key, null, childLsn, EntryStates.DIRTY_BIT, false);</div>
<div>3238&emsp;&emsp;</div>
<div style="background-color:limegreen;">3239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (res & INSERT_SUCCESS) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3241&emsp;&emsp;</div>
<div>3242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Inserts a slot with the given key, lsn and child node into this IN, if</div>
<div>3244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a slot with the same key does not exist already. The state of the new</div>
<div>3245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot is set to DIRTY. Assumes this node is already latched by the</div>
<div>3246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * caller.</div>
<div>3247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data If the data portion of a record must be embedded in this</div>
<div>3249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN, "data" stores the record's data. Null otherwise. See also comment</div>
<div>3250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the keyEntries field. </div>
<div>3251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return either (1) the index of location in the IN where the entry was</div>
<div>3253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * inserted |'d with INSERT_SUCCESS, or (2) the index of the duplicate in</div>
<div>3254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the IN if the entry was found to be a duplicate.</div>
<div>3255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @throws EnvironmentFailureException if the node is full (it should have</div>
<div>3257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * been split earlier).</div>
<div>3258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int insertEntry1(</div>
<div>3260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child,</div>
<div>3261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data,</div>
<div>3263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long childLsn,</div>
<div>3264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean blindInsertion) {</div>
<div>3265&emsp;&emsp;</div>
<div>3266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return insertEntry1(</div>
<div>3267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            child, key, data, childLsn, EntryStates.DIRTY_BIT,</div>
<div>3268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            blindInsertion);</div>
<div>3269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3270&emsp;&emsp;</div>
<div>3271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Inserts a slot with the given key, lsn, state, and child node into this</div>
<div>3273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * IN, if a slot with the same key does not exist already. Assumes this</div>
<div>3274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * node is already latched by the caller.</div>
<div>3275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This returns a failure if there's a duplicate match. The caller must do</div>
<div>3277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the processing to check if the entry is actually deleted and can be</div>
<div>3278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * overwritten. This is foisted upon the caller rather than handled in this</div>
<div>3279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * object because there may be some latch releasing/retaking in order to</div>
<div>3280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * check a child LN.</div>
<div>3281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data If the data portion of a record must be embedded in this</div>
<div>3283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN, "data" stores the record's data. Null otherwise. See also comment</div>
<div>3284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for the keyEntries field. </div>
<div>3285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return either (1) the index of location in the IN where the entry was</div>
<div>3287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * inserted |'d with INSERT_SUCCESS, or (2) the index of the duplicate in</div>
<div>3288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the IN if the entry was found to be a duplicate.</div>
<div>3289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @throws EnvironmentFailureException if the node is full (it should have</div>
<div>3291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * been split earlier).</div>
<div>3292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int insertEntry1(</div>
<div>3294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child,</div>
<div>3295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data,</div>
<div>3297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long childLsn,</div>
<div>3298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte state,</div>
<div>3299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean blindInsertion) {</div>
<div>3300&emsp;&emsp;</div>
<div>3301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Search without requiring an exact match, but do let us know the</div>
<div>3303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * index of the match if there is one.</div>
<div>3304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int index = findEntry(key, true, false);</div>
<div>3306&emsp;&emsp;</div>
<div style="background-color:limegreen;">3307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (index >= 0 && (index & EXACT_MATCH) != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3308&emsp;&emsp;</div>
<div>3309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>3310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * There is an exact match.  Don't insert; let the caller decide</div>
<div>3311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * what to do with this duplicate.</div>
<div>3312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>3313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return index & ~IN.EXACT_MATCH;</div>
<div>3314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3315&emsp;&emsp;</div>
<div>3316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * There was no key match, but if this is a bin delta, there may be an</div>
<div>3318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * exact match in the full bin. Mutate to full bin and search again.</div>
<div>3319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * However, if we know for sure that the key does not exist in the full</div>
<div>3320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * BIN, then don't mutate, unless there is no space in the delta to do</div>
<div>3321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * the insertion.</div>
<div>3322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">3323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3324&emsp;&emsp;</div>
<div>3325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            BIN bin = (BIN)this;</div>
<div>3326&emsp;&emsp;</div>
<div style="background-color:limegreen;">3327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            boolean doBlindInsertion = (nEntries &#60; getMaxEntries());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3328&emsp;&emsp;</div>
<div style="background-color:limegreen;">3329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (doBlindInsertion &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                !blindInsertion &&</div>
<div style="background-color:limegreen;">3331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                bin.mayHaveKeyInFullBin(key)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3332&emsp;&emsp;</div>
<div>3333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                doBlindInsertion = false;</div>
<div>3334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3335&emsp;&emsp;</div>
<div style="background-color:limegreen;">3336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!doBlindInsertion) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3337&emsp;&emsp;</div>
<div>3338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                mutateToFullBIN(true /*leaveFreeSlot*/);</div>
<div>3339&emsp;&emsp;</div>
<div>3340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                index = findEntry(key, true, false);</div>
<div>3341&emsp;&emsp;</div>
<div style="background-color:limegreen;">3342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (index >= 0 && (index & EXACT_MATCH) != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return index & ~IN.EXACT_MATCH;</div>
<div>3344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>3345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>3346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getEvictor().incBinDeltaBlindOps();</div>
<div>3347&emsp;&emsp;</div>
<div>3348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (traceDeltas) {</div>
<div>3349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    LoggerUtils.envLogMsg(</div>
<div>3350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        traceLevel, getEnv(),</div>
<div>3351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        Thread.currentThread().getId() + "-" +</div>
<div>3352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        Thread.currentThread().getName() +</div>
<div>3353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        "-" + getEnv().getName() +</div>
<div>3354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        (blindInsertion ?</div>
<div>3355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         " Blind insertion in BIN-delta " :</div>
<div>3356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         " Blind put in BIN-delta ") +</div>
<div>3357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        getNodeId() + " nEntries = " +</div>
<div>3358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        nEntries + " max entries = " +</div>
<div>3359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        getMaxEntries() +</div>
<div>3360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        " full BIN entries = " +</div>
<div>3361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        bin.getFullBinNEntries() +</div>
<div>3362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        " full BIN max entries = " +</div>
<div>3363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        bin.getFullBinMaxEntries());</div>
<div>3364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>3365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3367&emsp;&emsp;</div>
<div style="background-color:limegreen;">3368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (nEntries >= getMaxEntries()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw unexpectedState(</div>
<div>3370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getEnv(),</div>
<div>3371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "Node " + getNodeId() +</div>
<div>3372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " should have been split before calling insertEntry" +</div>
<div>3373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " is BIN-delta: " + isBINDelta() +</div>
<div>3374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " num entries: " + nEntries +</div>
<div>3375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " max entries: " + getMaxEntries());</div>
<div>3376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3377&emsp;&emsp;</div>
<div>3378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* There was no key match, so insert to the right of this entry. */</div>
<div>3379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        index++;</div>
<div>3380&emsp;&emsp;</div>
<div>3381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* We found a spot for insert, shift entries as needed. */</div>
<div style="background-color:limegreen;">3382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (index &#60; nEntries) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int oldSize = computeLsnOverhead();</div>
<div>3384&emsp;&emsp;</div>
<div>3385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Adding elements to the LSN array can change the space used. */</div>
<div>3386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            shiftEntriesRight(index);</div>
<div>3387&emsp;&emsp;</div>
<div>3388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(computeLsnOverhead() - oldSize);</div>
<div>3389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            nEntries++;</div>
<div>3391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3392&emsp;&emsp;</div>
<div style="background-color:limegreen;">3393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ((BIN)this).incFullBinNEntries();</div>
<div>3395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3396&emsp;&emsp;</div>
<div>3397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int oldSize = computeLsnOverhead();</div>
<div>3398&emsp;&emsp;</div>
<div style="background-color:limegreen;">3399&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (data == null || databaseImpl.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setTarget(index, child);</div>
<div>3401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3402&emsp;&emsp;</div>
<div>3403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsnInternal(index, childLsn);</div>
<div>3404&emsp;&emsp;</div>
<div>3405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = insertKey(index, key, data);</div>
<div>3406&emsp;&emsp;</div>
<div>3407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Do this after calling insert key to overwrite whatever state changes</div>
<div>3409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * were done by the insertEntry() call.</div>
<div>3410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[index] = state;</div>
<div>3412&emsp;&emsp;</div>
<div style="background-color:limegreen;">3413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (data != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setEmbeddedLN(index);</div>
<div style="background-color:limegreen;">3415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (data.length == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setNoDataLN(index);</div>
<div>3417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3419&emsp;&emsp;</div>
<div>3420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        adjustCursorsForInsert(index);</div>
<div>3421&emsp;&emsp;</div>
<div>3422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(oldSize,</div>
<div>3423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         getEntryInMemorySize(index) +</div>
<div>3424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         computeLsnOverhead());</div>
<div>3425&emsp;&emsp;</div>
<div style="background-color:limegreen;">3426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (multiSlotChange) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>3428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3429&emsp;&emsp;</div>
<div>3430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3431&emsp;&emsp;</div>
<div style="background-color:limegreen;">3432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3433&emsp;&emsp;</div>
<div>3434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return (index | INSERT_SUCCESS);</div>
<div>3435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3436&emsp;&emsp;</div>
<div>3437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Removes the slot at index from this IN.  Assumes this node is already</div>
<div>3439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * latched by the caller.</div>
<div>3440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param index The index of the entry to delete from the IN.</div>
<div>3442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void deleteEntry(int index) {</div>
<div>3444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        deleteEntry(index, true /*makeDirty*/, true /*validate*/);</div>
<div>3445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3446&emsp;&emsp;</div>
<div>3447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Variant that allows specifying whether the IN is dirtied and whether</div>
<div>3449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * validation takes place. 'validate' should be false only in tests.</div>
<div>3450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * See BIN.compress and INCompressor for a discussion about why slots can</div>
<div>3452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be deleted without dirtying the BIN, and why the next delta is</div>
<div>3453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * prohibited when the slot is dirty.</div>
<div>3454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void deleteEntry(int index, boolean makeDirty, boolean validate) {</div>
<div>3456&emsp;&emsp;</div>
<div style="background-color:limegreen;">3457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !isBINDelta();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">3458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert index >= 0 && index &#60; nEntries;&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">3459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !validate || validateSubtreeBeforeDelete(index);&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3460&emsp;&emsp;</div>
<div style="background-color:limegreen;">3461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (makeDirty) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>3463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3464&emsp;&emsp;</div>
<div style="background-color:limegreen;">3465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isDirty(index)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setProhibitNextDelta(true);</div>
<div>3467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3468&emsp;&emsp;</div>
<div>3469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child = getTarget(index);</div>
<div>3470&emsp;&emsp;</div>
<div>3471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = getEnv().getOffHeapCache();</div>
<div>3472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int level = getNormalizedLevel();</div>
<div style="background-color:limegreen;">3473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (level == 1) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.freeLN((BIN) this, index);</div>
<div style="background-color:limegreen;">3475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (level == 2) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.freeBIN((BIN) child, this, index);</div>
<div>3477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3478&emsp;&emsp;</div>
<div style="background-color:limegreen;">3479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child != null && child.isIN()) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            IN childIN = (IN)child;</div>
<div>3481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEnv().getInMemoryINs().remove(childIN);</div>
<div>3482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3483&emsp;&emsp;</div>
<div>3484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(getEntryInMemorySize(index), 0);</div>
<div>3485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int oldLSNArraySize = computeLsnOverhead();</div>
<div>3486&emsp;&emsp;</div>
<div>3487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Do the actual deletion. Note: setTarget() must be called before</div>
<div>3489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * copyEntries() so that the hasCachedChildrenFlag will be properly</div>
<div>3490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * maintained.</div>
<div>3491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(index, null);</div>
<div>3493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        copyEntries(index + 1, index, nEntries - index - 1);</div>
<div>3494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nEntries--;</div>
<div>3495&emsp;&emsp;</div>
<div>3496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* cleanup what used to be the last entry */</div>
<div>3497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        clearEntry(nEntries);</div>
<div>3498&emsp;&emsp;</div>
<div>3499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* setLsnInternal can mutate to an array of longs. */</div>
<div>3500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(oldLSNArraySize, computeLsnOverhead());</div>
<div>3501&emsp;&emsp;</div>
<div style="background-color:limegreen;">3502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN() || hasCachedChildrenFlag() == hasCachedChildren());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3503&emsp;&emsp;</div>
<div>3504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Note that we don't have to adjust cursors for delete, since</div>
<div>3506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * there should be nothing pointing at this record.</div>
<div>3507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        traceDelete(Level.FINEST, index);</div>
<div>3509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3510&emsp;&emsp;</div>
<div>3511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * WARNING: clearEntry() calls entryTargets.set() directly, instead of</div>
<div>3513&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * setTarget(). As a result, the hasCachedChildren flag of the IN is not</div>
<div>3514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * updated here. The caller is responsible for updating this flag, if</div>
<div>3515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * needed.</div>
<div>3516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void clearEntry(int idx) {</div>
<div>3518&emsp;&emsp;</div>
<div>3519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = entryTargets.set(idx, null, this);</div>
<div>3520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = entryKeys.set(idx, null, this);</div>
<div>3521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapBINIds = offHeapBINIds.set(idx, 0, this);</div>
<div>3522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsnInternal(idx, DbLsn.NULL_LSN);</div>
<div>3523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] = 0;</div>
<div>3524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3525&emsp;&emsp;</div>
<div>3526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is called after the idx'th child of this node gets logged,</div>
<div>3528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and changes position as a result. </div>
<div>3529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3530&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newLSN The new on-disk position of the child.</div>
<div>3531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newVLSN The VLSN of the logrec at the new position.</div>
<div>3533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For LN children only.</div>
<div>3534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSize The size of the logrec at the new position.</div>
<div>3536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For LN children only.</div>
<div>3537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void updateEntry(</div>
<div>3539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newLSN,</div>
<div>3541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newVLSN,</div>
<div>3542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSize) {</div>
<div>3543&emsp;&emsp;</div>
<div>3544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, newLSN);</div>
<div>3545&emsp;&emsp;</div>
<div style="background-color:limegreen;">3546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">3547&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ((BIN)this).setCachedVLSN(idx, newVLSN);</div>
<div>3549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>3550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setLastLoggedSize(idx, newSize);</div>
<div>3551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3553&emsp;&emsp;</div>
<div>3554&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3556&emsp;&emsp;</div>
<div>3557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is called only from BIN.applyDelta(). It applies the info</div>
<div>3559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * extracted from a delta slot to the corresponding slot in the full BIN.</div>
<div>3560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Unlike other update methods, the LSN may be NULL_LSN if the KD flag is</div>
<div>3562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * set. This allows applying a BIN-delta with a NULL_LSN and KD, for an</div>
<div>3563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * invisible log entry for example.</div>
<div>3564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * No need to do memory counting in this method because the BIN is not</div>
<div>3566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * yet attached to the tree.</div>
<div>3567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void applyDeltaSlot(</div>
<div>3569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node node,</div>
<div>3571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long lsn,</div>
<div>3572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int lastLoggedSize,</div>
<div>3573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte state,</div>
<div>3574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data) {</div>
<div>3576&emsp;&emsp;</div>
<div style="background-color:limegreen;">3577&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">3578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">3579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(lsn != DbLsn.NULL_LSN ||&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               (state & EntryStates.KNOWN_DELETED_BIT) != 0);</div>
<div style="background-color:limegreen;">3581&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(node == null || data == null);&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">3582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!getInListResident());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3583&emsp;&emsp;</div>
<div>3584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ((BIN) this).freeOffHeapLN(idx);</div>
<div>3585&emsp;&emsp;</div>
<div>3586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, lsn, false/*check*/);</div>
<div>3587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedSize(idx, lastLoggedSize);</div>
<div>3588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(idx, node);</div>
<div>3589&emsp;&emsp;</div>
<div>3590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateLNSlotKey(idx, key, data);</div>
<div>3591&emsp;&emsp;</div>
<div style="background-color:limegreen;">3592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isEmbeddedLN(idx) == isEmbeddedLN(state));&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">3593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isNoDataLN(idx) == isNoDataLN(state));&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3594&emsp;&emsp;</div>
<div>3595&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] = state;</div>
<div>3596&emsp;&emsp;</div>
<div>3597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3598&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3599&emsp;&emsp;</div>
<div>3600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Update the idx slot of this BIN to reflect a record insertion in an</div>
<div>3602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * existing KD slot. It is called from CursorImpl.insertRecordInternal(),</div>
<div>3603&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * after logging the insertion op.</div>
<div>3604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newLN The LN associated with the new record.</div>
<div>3606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newLSN The LSN of the insertion logrec.</div>
<div>3608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3609&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSize The size of the insertion logrec.</div>
<div>3610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newKey The value for the record's key. It is equal to the current</div>
<div>3612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * key value in the slot, but may not be identical to that value if a</div>
<div>3613&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * custom comparator is used.</div>
<div>3614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3615&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newData If the record's data must be embedded in this BIN, "data"</div>
<div>3616&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * stores the record's data. Null otherwise. See also comment for the</div>
<div>3617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * keyEntries field.</div>
<div>3618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void insertRecord(</div>
<div>3620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LN newLN,</div>
<div>3622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newLSN,</div>
<div>3623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSize,</div>
<div>3624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] newKey,</div>
<div>3625&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] newData,</div>
<div>3626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int expiration,</div>
<div>3627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean expirationInHours) {</div>
<div>3628&emsp;&emsp;</div>
<div style="background-color:limegreen;">3629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3630&emsp;&emsp;</div>
<div>3631&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN bin = (BIN) this;</div>
<div>3632&emsp;&emsp;</div>
<div>3633&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</div>
<div>3634&emsp;&emsp;</div>
<div>3635&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>3636&emsp;&emsp;</div>
<div>3637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, newLSN);</div>
<div>3638&emsp;&emsp;</div>
<div>3639&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = updateLNSlotKey(idx, newKey, newData);</div>
<div>3640&emsp;&emsp;</div>
<div style="background-color:limegreen;">3641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3642&emsp;&emsp;</div>
<div>3643&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            clearLastLoggedSize(idx);</div>
<div>3644&emsp;&emsp;</div>
<div>3645&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.setCachedVLSN(idx, newLN.getVLSNSequence());</div>
<div>3646&emsp;&emsp;</div>
<div style="background-color:limegreen;">3647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (databaseImpl.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setTarget(idx, newLN);</div>
<div>3649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3651&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setTarget(idx, newLN);</div>
<div>3652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastLoggedSize(idx, newSize);</div>
<div>3653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3654&emsp;&emsp;</div>
<div>3655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.setExpiration(idx, expiration, expirationInHours);</div>
<div>3656&emsp;&emsp;</div>
<div style="background-color:limegreen;">3657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (multiSlotChange) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>3659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3660&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</div>
<div>3661&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>3662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3663&emsp;&emsp;</div>
<div>3664&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        clearKnownDeleted(idx);</div>
<div>3665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        clearPendingDeleted(idx);</div>
<div>3666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3667&emsp;&emsp;</div>
<div style="background-color:limegreen;">3668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3669&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3670&emsp;&emsp;</div>
<div>3671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Update the idx slot of this BIN to reflect an update of the associated</div>
<div>3673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * record. It is called from CursorImpl.updateRecordInternal(), after</div>
<div>3674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * logging the update op.</div>
<div>3675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param oldMemSize If the child LN was cached before the update op, it has</div>
<div>3677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * already been updated in-place by the caller. In this case, oldMemSize</div>
<div>3678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * stores the size of the child LN before the update, and it is used to do</div>
<div>3679&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * memory counting. Otherwise oldMemSize is 0 and the newly created LN has</div>
<div>3680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * not been attached to the tree; it will be attached later by the caller,</div>
<div>3681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if needed.</div>
<div>3682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newLSN The LSN of the update logrec.</div>
<div>3684&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newVLSN The VLSN of the update logrec.</div>
<div>3686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSize The on-disk size of the update logrec.</div>
<div>3688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newKey The new value for the record's key. It is equal to the</div>
<div>3690&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * current value, but may not be identical to the current value if a</div>
<div>3691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * custom comparator is used. It may be null, if the caller knows for</div>
<div>3692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * sure that the key does not change.</div>
<div>3693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newData If the record's data must be embedded in this BIN, "data"</div>
<div>3695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * stores the record's data. Null otherwise. See also comment for the</div>
<div>3696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * keyEntries field.</div>
<div>3697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void updateRecord(</div>
<div>3699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldMemSize,</div>
<div>3701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newLSN,</div>
<div>3702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newVLSN,</div>
<div>3703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSize,</div>
<div>3704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] newKey,</div>
<div>3705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] newData,</div>
<div>3706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int expiration,</div>
<div>3707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean expirationInHours) {</div>
<div>3708&emsp;&emsp;</div>
<div style="background-color:limegreen;">3709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>3710&emsp;&emsp;</div>
<div>3711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN bin = (BIN) this;</div>
<div>3712&emsp;&emsp;</div>
<div>3713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</div>
<div>3714&emsp;&emsp;</div>
<div>3715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>3716&emsp;&emsp;</div>
<div>3717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, newLSN);</div>
<div>3718&emsp;&emsp;</div>
<div>3719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = updateLNSlotKey(idx, newKey, newData);</div>
<div>3720&emsp;&emsp;</div>
<div style="background-color:limegreen;">3721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            clearLastLoggedSize(idx);</div>
<div>3723&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ((BIN)this).setCachedVLSN(idx, newVLSN);</div>
<div>3724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastLoggedSize(idx, newSize);</div>
<div>3726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3727&emsp;&emsp;</div>
<div>3728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.setExpiration(idx, expiration, expirationInHours);</div>
<div>3729&emsp;&emsp;</div>
<div style="background-color:limegreen;">3730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (multiSlotChange) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>3732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Update mem size for key change. */</div>
<div>3734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</div>
<div>3735&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>3736&emsp;&emsp;</div>
<div>3737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Update mem size for node change. */</div>
<div>3738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Node newLN = entryTargets.get(idx);</div>
<div style="background-color:limegreen;">3739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            long newMemSize =&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>3740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (newLN != null ? newLN.getMemorySizeIncludedByParent() : 0);</div>
<div>3741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldMemSize, newMemSize);</div>
<div>3742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3743&emsp;&emsp;</div>
<div>3744&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3746&emsp;&emsp;</div>
<div>3747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Update the idx slot slot of this BIN to reflect a deletion of the </div>
<div>3749&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * associated record. It is called from CursorImpl.deleteCurrentRecord(),</div>
<div>3750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * after logging the deletion op.</div>
<div>3751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param oldMemSize If the child LN was cached before the deletion, it</div>
<div>3753&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * has already been updated in-place by the caller (the ln contents have</div>
<div>3754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * been deleted). In this case, oldMemSize stores the in-memory size of</div>
<div>3755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the child LN before the update, and it is used to do memory counting.</div>
<div>3756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Otherwise oldMemSize is 0 and the newly created LN has not been attached</div>
<div>3757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to the tree; it will be attached later by the caller, if needed.</div>
<div>3758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3759&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newLSN The LSN of the deletion logrec.</div>
<div>3760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newVLSN The VLSN of the deletion logrec.</div>
<div>3762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3763&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param newSize The on-disk size of the deletion logrec.</div>
<div>3764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void deleteRecord(</div>
<div>3766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldMemSize,</div>
<div>3768&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newLSN,</div>
<div>3769&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newVLSN,</div>
<div>3770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSize) {</div>
<div>3771&emsp;&emsp;</div>
<div style="background-color:limegreen;">3772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3773&emsp;&emsp;</div>
<div>3774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN bin = (BIN) this;</div>
<div>3775&emsp;&emsp;</div>
<div>3776&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</div>
<div>3777&emsp;&emsp;</div>
<div>3778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, newLSN);</div>
<div>3779&emsp;&emsp;</div>
<div style="background-color:limegreen;">3780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            clearLastLoggedSize(idx);</div>
<div>3782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.setCachedVLSN(idx, newVLSN);</div>
<div>3783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastLoggedSize(idx, newSize);</div>
<div>3785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3786&emsp;&emsp;</div>
<div style="background-color:limegreen;">3787&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryTargets.get(idx) != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Update mem size for node change. */</div>
<div style="background-color:limegreen;">3789&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(oldMemSize != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Node newLN = entryTargets.get(idx);</div>
<div>3791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newMemSize = newLN.getMemorySizeIncludedByParent();</div>
<div>3792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldMemSize, newMemSize);</div>
<div>3793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">3794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(oldMemSize == 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3796&emsp;&emsp;</div>
<div>3797&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setPendingDeleted(idx);</div>
<div>3798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3800&emsp;&emsp;</div>
<div>3801&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is used by the RecoveryManager to change the current version</div>
<div>3803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * of a record, either to a later version (in case of redo), or to an </div>
<div>3804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * earlier version (in case of undo). The current version may or may not be</div>
<div>3805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cached as a child LN of this BIN (it may be only in case of txn abort</div>
<div>3806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * during normal processing). If it is, it is evicted. The new version is</div>
<div>3807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * not attached to the in-memory tree, to save memory during crash</div>
<div>3808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * recovery.</div>
<div>3809&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param idx The BIN slot for the record.</div>
<div>3811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param lsn The LSN of the new record version. It may be null in case of</div>
<div>3813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * undo, if the logrec that is being undone is an insertion and the record</div>
<div>3814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * did not exist at all in the DB before that insertion.</div>
<div>3815&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param knownDeleted True if the new version is a committed deletion.</div>
<div>3817&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param pendingDeleted True if the new version is a deletion, which </div>
<div>3819&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * may or may not be committed.</div>
<div>3820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param key The key of the new version. It is null only if we are undoing</div>
<div>3822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and the revert-to version was not embedded (in this case the key of the</div>
<div>3823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * revert-to version is not stored in the logrec). If it is null and the</div>
<div>3824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * DB allows key updates, the new record version is fetched from disk to</div>
<div>3825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * retrieve its key, so that the key values stored in the BIN slots are</div>
<div>3826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * always transactionally correct.</div>
<div>3827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param data The data of the new version. It is non-null if and only if</div>
<div>3829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the new version must be embedded in the BIN.</div>
<div>3830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param vlsn The VLSN of the new version.</div>
<div>3832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param logrecSize The on-disk size of the logrec corresponding to the</div>
<div>3834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * new version. It may be 0 (i.e. unknown) in case of undo. </div>
<div>3835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void recoverRecord(</div>
<div>3837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long lsn,</div>
<div>3839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean knownDeleted,</div>
<div>3840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean pendingDeleted,</div>
<div>3841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>3842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] data,</div>
<div>3843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long vlsn,</div>
<div>3844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int logrecSize,</div>
<div>3845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int expiration,</div>
<div>3846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean expirationInHours) {</div>
<div>3847&emsp;&emsp;</div>
<div style="background-color:limegreen;">3848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3849&emsp;&emsp;</div>
<div>3850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        BIN bin = (BIN) this;</div>
<div>3851&emsp;&emsp;</div>
<div>3852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</div>
<div>3853&emsp;&emsp;</div>
<div style="background-color:limegreen;">3854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (lsn == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3855&emsp;&emsp;</div>
<div>3856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>3857&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * A NULL lsn means that we are undoing an insertion that was done</div>
<div>3858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * without slot reuse. To undo such an insertion we evict the </div>
<div>3859&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * current version (it may cached only in case of normal txn abort)</div>
<div>3860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * and set the KD flag in the slot. We also set the LSN to null to</div>
<div>3861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * ensure that the slot does not point to a logrec that does not</div>
<div>3862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * reflect the slot's current state. The slot can then be put on</div>
<div>3863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * the compressor for complete removal.</div>
<div>3864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>3865&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setKnownDeletedAndEvictLN(idx);</div>
<div>3866&emsp;&emsp;</div>
<div>3867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLsnInternal(idx, DbLsn.NULL_LSN);</div>
<div>3868&emsp;&emsp;</div>
<div>3869&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.queueSlotDeletion(idx);</div>
<div>3870&emsp;&emsp;</div>
<div>3871&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>3872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3873&emsp;&emsp;</div>
<div style="background-color:limegreen;">3874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (key == null &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">3875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            databaseImpl.allowsKeyUpdates() &&&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            !knownDeleted) {</div>
<div>3877&emsp;&emsp;</div>
<div>3878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>3879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                WholeEntry wholeEntry = getEnv().getLogManager().</div>
<div>3880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getLogEntryAllowInvisibleAtRecovery(</div>
<div>3881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        lsn, getLastLoggedSize(idx));</div>
<div>3882&emsp;&emsp;</div>
<div>3883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LNLogEntry&#60;?> logrec = (LNLogEntry&#60;?>) wholeEntry.getEntry();</div>
<div>3884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logrec.postFetchInit(getDatabase());</div>
<div>3885&emsp;&emsp;</div>
<div>3886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                key = logrec.getKey();</div>
<div>3887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logrecSize = wholeEntry.getHeader().getEntrySize();</div>
<div>3888&emsp;&emsp;</div>
<div>3889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } catch (FileNotFoundException e) {</div>
<div>3890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw new EnvironmentFailureException(</div>
<div>3891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getEnv(), EnvironmentFailureReason.LOG_FILE_NOT_FOUND,</div>
<div>3892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    makeFetchErrorMsg(null, lsn, idx), e);</div>
<div>3893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3895&emsp;&emsp;</div>
<div>3896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>3897&emsp;&emsp;</div>
<div>3898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, lsn);</div>
<div>3899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(idx, null);</div>
<div>3900&emsp;&emsp;</div>
<div>3901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = updateLNSlotKey(idx, key, data);</div>
<div>3902&emsp;&emsp;</div>
<div style="background-color:limegreen;">3903&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isEmbeddedLN(idx)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            clearLastLoggedSize(idx);</div>
<div>3905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.setCachedVLSN(idx, vlsn);</div>
<div>3906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastLoggedSize(idx, logrecSize);</div>
<div>3908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3909&emsp;&emsp;</div>
<div style="background-color:limegreen;">3910&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (knownDeleted) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">3911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(!pendingDeleted);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setKnownDeleted(idx);</div>
<div>3913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.queueSlotDeletion(idx);</div>
<div>3914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            clearKnownDeleted(idx);</div>
<div style="background-color:limegreen;">3916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (pendingDeleted) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setPendingDeleted(idx);</div>
<div>3918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.queueSlotDeletion(idx);</div>
<div>3919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>3920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                clearPendingDeleted(idx);</div>
<div>3921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>3922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3923&emsp;&emsp;</div>
<div>3924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        bin.setExpiration(idx, expiration, expirationInHours);</div>
<div>3925&emsp;&emsp;</div>
<div style="background-color:limegreen;">3926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (multiSlotChange) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>3928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>3929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</div>
<div>3930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>3931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>3932&emsp;&emsp;</div>
<div>3933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3935&emsp;&emsp;</div>
<div>3936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Update the cached-child and LSN properties of the idx-th slot. This</div>
<div>3938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * method is used by the RecoveryManager.recoverChildIN() to change the</div>
<div>3939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * version of a child IN, a later version The child IN may or may not be</div>
<div>3940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * already attached to the tree.</div>
<div>3941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void recoverIN(</div>
<div>3943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>3944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node node,</div>
<div>3945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long lsn,</div>
<div>3946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int lastLoggedSize) {</div>
<div>3947&emsp;&emsp;</div>
<div>3948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>3949&emsp;&emsp;</div>
<div>3950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>3951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * If we are about to detach a cached child IN, make sure that it is</div>
<div>3952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * not in the INList. This is correct, because this method is called</div>
<div>3953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * during the recovery phase where the INList is disabled,</div>
<div>3954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>3955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child = getTarget(idx);</div>
<div>3956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(child == null ||</div>
<div>3957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               !((IN)child).getInListResident() ||</div>
<div>3958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               child == node/* this is needed by a unit test*/);</div>
<div>3959&emsp;&emsp;</div>
<div>3960&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, lsn);</div>
<div>3961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLastLoggedSize(idx, lastLoggedSize);</div>
<div>3962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(idx, node);</div>
<div>3963&emsp;&emsp;</div>
<div>3964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newSlotSize = getEntryInMemorySize(idx);</div>
<div>3965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>3966&emsp;&emsp;</div>
<div>3967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>3968&emsp;&emsp;</div>
<div>3969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</div>
<div>3970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>3971&emsp;&emsp;</div>
<div>3972&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>3973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Attach the given node as the idx-th child of "this" node. If the child</div>
<div>3974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * node is an LN, update the key of the parent slot to the given key value,</div>
<div>3975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if that value is non-null and an update is indeed necessary.</div>
<div>3976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is called after the child node has been either (a) fetched</div>
<div>3978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * in from disk and is not dirty, or (b) is a newly created instance that</div>
<div>3979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * will be written out later by something like a checkpoint. In either</div>
<div>3980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * case, the slot LSN does not need to be updated.</div>
<div>3981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>3982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note: does not dirty the node unless the LN slot key is changed.</div>
<div>3983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>3984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void attachNode(int idx, Node node, byte[] newKey) {</div>
<div>3985&emsp;&emsp;</div>
<div style="background-color:limegreen;">3986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !(node instanceof IN) || ((IN) node).isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3987&emsp;&emsp;</div>
<div>3988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>3989&emsp;&emsp;</div>
<div>3990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Make sure we are not using this method to detach a cached child */</div>
<div style="background-color:limegreen;">3991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(getTarget(idx) == null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3992&emsp;&emsp;</div>
<div>3993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(idx, node);</div>
<div>3994&emsp;&emsp;</div>
<div>3995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = false;</div>
<div>3996&emsp;&emsp;</div>
<div style="background-color:limegreen;">3997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN() && newKey != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">3998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(!haveEmbeddedData(idx));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>3999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            multiSlotChange = updateLNSlotKey(idx, newKey, null);</div>
<div>4000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4001&emsp;&emsp;</div>
<div style="background-color:limegreen;">4002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (multiSlotChange) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>4004&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</div>
<div>4006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>4007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4008&emsp;&emsp;</div>
<div style="background-color:limegreen;">4009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4011&emsp;&emsp;</div>
<div>4012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Detach from the tree the child node at the idx-th slot.</div>
<div>4014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * The most common caller of this method is the evictor. If the child</div>
<div>4016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * being evicted was dirty, it has just been logged and the lsn of the</div>
<div>4017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot must be updated.</div>
<div>4018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void detachNode(int idx, boolean updateLsn, long newLsn) {</div>
<div>4020&emsp;&emsp;</div>
<div>4021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>4022&emsp;&emsp;</div>
<div>4023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Node child = getTarget(idx);</div>
<div>4024&emsp;&emsp;</div>
<div style="background-color:limegreen;">4025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (updateLsn) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLsn(idx, newLsn);</div>
<div>4027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>4028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(idx, null);</div>
<div>4030&emsp;&emsp;</div>
<div>4031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long newSlotSize = getEntryInMemorySize(idx);</div>
<div>4032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>4033&emsp;&emsp;</div>
<div style="background-color:limegreen;">4034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (child != null && child.isIN()) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>4035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEnv().getInMemoryINs().remove((IN) child);</div>
<div>4036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4037&emsp;&emsp;</div>
<div style="background-color:limegreen;">4038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>4039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4040&emsp;&emsp;</div>
<div>4041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This method is used in DupConvert, where it is called to convert the</div>
<div>4043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * keys of an upper IN that has just been fetched from the log and is not</div>
<div>4044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * attached to in-memory tree yet.</div>
<div>4045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void convertKey(int idx, byte[] newKey) {</div>
<div>4047&emsp;&emsp;</div>
<div>4048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</div>
<div>4049&emsp;&emsp;</div>
<div>4050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = updateKey(idx, newKey, null);</div>
<div>4051&emsp;&emsp;</div>
<div style="background-color:limegreen;">4052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (multiSlotChange) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>4054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</div>
<div>4056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</div>
<div>4057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4058&emsp;&emsp;</div>
<div>4059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>4060&emsp;&emsp;</div>
<div style="background-color:limegreen;">4061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4063&emsp;&emsp;</div>
<div>4064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void copyEntries(final int from, final int to, final int n) {</div>
<div>4065&emsp;&emsp;</div>
<div>4066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = entryTargets.copy(from, to, n, this);</div>
<div>4067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = entryKeys.copy(from, to, n, this);</div>
<div>4068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapBINIds = offHeapBINIds.copy(from, to, n, this);</div>
<div>4069&emsp;&emsp;</div>
<div>4070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.arraycopy(entryStates, from, entryStates, to, n);</div>
<div>4071&emsp;&emsp;</div>
<div style="background-color:limegreen;">4072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryLsnLongArray == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int fromOff = from &#60;&#60; 2;</div>
<div>4074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int toOff = to &#60;&#60; 2;</div>
<div>4075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int nBytes = n &#60;&#60; 2;</div>
<div>4076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.arraycopy(entryLsnByteArray, fromOff,</div>
<div>4077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnByteArray, toOff, nBytes);</div>
<div>4078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4079&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.arraycopy(entryLsnLongArray, from,</div>
<div>4080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryLsnLongArray, to,</div>
<div>4081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                n);</div>
<div>4082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4084&emsp;&emsp;</div>
<div>4085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Return true if this node needs splitting.  For the moment, needing to be</div>
<div>4087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * split is defined by there being no free entries available.</div>
<div>4088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean needsSplitting() {</div>
<div>4090&emsp;&emsp;</div>
<div style="background-color:limegreen;">4091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBINDelta()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            BIN bin = (BIN)this;</div>
<div>4093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int fullBinNEntries = bin.getFullBinNEntries();</div>
<div>4094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int fullBinMaxEntries = bin.getFullBinMaxEntries();</div>
<div>4095&emsp;&emsp;</div>
<div style="background-color:limegreen;">4096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (fullBinNEntries &#60; 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4097&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* fullBinNEntries is unknown in logVersions &#60; 10 */</div>
<div>4098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                mutateToFullBIN(false /*leaveFreeSlot*/);</div>
<div>4099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div style="background-color:limegreen;">4100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                assert(fullBinNEntries > 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">4101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                return ((fullBinMaxEntries - fullBinNEntries) &#60; 1);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4104&emsp;&emsp;</div>
<div style="background-color:limegreen;">4105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return ((getMaxEntries() - nEntries) &#60; 1);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4107&emsp;&emsp;</div>
<div>4108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Split this into two nodes.  Parent IN is passed in parent and should be</div>
<div>4110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * latched by the caller.</div>
<div>4111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * childIndex is the index in parent of where "this" can be found.</div>
<div>4113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final IN split(</div>
<div>4115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN parent,</div>
<div>4116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int childIndex,</div>
<div>4117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN grandParent,</div>
<div>4118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int maxEntries) {</div>
<div>4119&emsp;&emsp;</div>
<div>4120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return splitInternal(parent, childIndex, grandParent, maxEntries, -1);</div>
<div>4121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4122&emsp;&emsp;</div>
<div>4123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called when we know we are about to split on behalf of a key that is the</div>
<div>4125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * minimum (leftSide) or maximum (!leftSide) of this node.  This is</div>
<div>4126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * achieved by just forcing the split to occur either one element in from</div>
<div>4127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the left or the right (i.e. splitIndex is 1 or nEntries - 1).</div>
<div>4128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    IN splitSpecial(</div>
<div>4130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN parent,</div>
<div>4131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int parentIndex,</div>
<div>4132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN grandParent,</div>
<div>4133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int maxEntriesPerNode,</div>
<div>4134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key,</div>
<div>4135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean leftSide) {</div>
<div>4136&emsp;&emsp;</div>
<div>4137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int index = findEntry(key, false, false);</div>
<div>4138&emsp;&emsp;</div>
<div style="background-color:limegreen;">4139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (leftSide && index == 0) {&nbsp;&#8594; [ALLOWCREATE] & [ALLOWCREATE, READONLY]</b></div>
<div>4140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return splitInternal(</div>
<div>4141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode, 1);</div>
<div>4142&emsp;&emsp;</div>
<div style="background-color:limegreen;">4143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (!leftSide && index == (nEntries - 1)) {&nbsp;&#8594; [ALLOWCREATE] & [ALLOWCREATE, READONLY]</b></div>
<div>4144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return splitInternal(</div>
<div>4145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode,</div>
<div>4146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                nEntries - 1);</div>
<div>4147&emsp;&emsp;</div>
<div>4148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return split(</div>
<div>4150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode);</div>
<div>4151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4153&emsp;&emsp;</div>
<div>4154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final IN splitInternal(</div>
<div>4155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final IN parent,</div>
<div>4156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int childIndex,</div>
<div>4157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final IN grandParent,</div>
<div>4158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int maxEntries,</div>
<div>4159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int splitIndex)</div>
<div>4160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>4161&emsp;&emsp;</div>
<div style="background-color:limegreen;">4162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4163&emsp;&emsp;</div>
<div>4164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>4165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Find the index of the existing identifierKey so we know which IN</div>
<div>4166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * (new or old) to put it in.</div>
<div>4167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">4168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (identifierKey == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            throw unexpectedState();</div>
<div>4170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4171&emsp;&emsp;</div>
<div>4172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int idKeyIndex = findEntry(identifierKey, false, false);</div>
<div>4173&emsp;&emsp;</div>
<div style="background-color:limegreen;">4174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (splitIndex &#60; 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            splitIndex = nEntries / 2;</div>
<div>4176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4177&emsp;&emsp;</div>
<div>4178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Range of entries to copy to new sibling. */</div>
<div>4179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int low, high;</div>
<div>4180&emsp;&emsp;</div>
<div style="background-color:limegreen;">4181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (idKeyIndex &#60; splitIndex) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4182&emsp;&emsp;</div>
<div>4183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Current node (this) keeps left half entries.  Right half entries</div>
<div>4185&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * will go in the new node.</div>
<div>4186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            low = splitIndex;</div>
<div>4188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            high = nEntries;</div>
<div>4189&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4190&emsp;&emsp;</div>
<div>4191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Current node (this) keeps right half entries.  Left half entries</div>
<div>4193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * will go in the new node.</div>
<div>4194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            low = 0;</div>
<div>4196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            high = splitIndex;</div>
<div>4197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4198&emsp;&emsp;</div>
<div>4199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] newIdKey = getKey(low);</div>
<div>4200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long parentLsn;</div>
<div>4201&emsp;&emsp;</div>
<div>4202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>4203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Ensure that max entries is large enough to hold the slots being</div>
<div>4204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * moved to the new sibling, with one spare slot for insertions. This</div>
<div>4205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * is important when the maxEntries param is less than nEntries in this</div>
<div>4206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * node, which can occur when the user reduces the fanout or when this</div>
<div>4207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * node has temporarily grown beyond its original fanout.</div>
<div>4208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>4209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final IN newSibling = createNewInstance(</div>
<div>4210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newIdKey,</div>
<div>4211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Math.max(maxEntries, high - low + 1),</div>
<div>4212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            level);</div>
<div>4213&emsp;&emsp;</div>
<div>4214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        newSibling.latch(CacheMode.UNCHANGED);</div>
<div>4215&emsp;&emsp;</div>
<div>4216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        try {</div>
<div>4217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean addedNewSiblingToCompressorQueue = false;</div>
<div>4218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final int newSiblingNEntries = (high - low);</div>
<div>4219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final boolean haveCachedChildren = hasCachedChildrenFlag();</div>
<div>4220&emsp;&emsp;</div>
<div style="background-color:limegreen;">4221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(isBIN() || haveCachedChildren == hasCachedChildren());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4222&emsp;&emsp;</div>
<div style="background-color:limegreen;">4223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            final BIN bin = isBIN() ? (BIN) this : null;&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4224&emsp;&emsp;</div>
<div>4225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /**</div>
<div>4226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Distribute entries among the split node and the new sibling.</div>
<div>4227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">4228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            for (int i = low; i &#60; high; i++) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4229&emsp;&emsp;</div>
<div style="background-color:limegreen;">4230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (!addedNewSiblingToCompressorQueue &&&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>4231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    bin != null &&</div>
<div style="background-color:limegreen;">4232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    bin.isDefunct(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4233&emsp;&emsp;</div>
<div>4234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    addedNewSiblingToCompressorQueue = true;</div>
<div>4235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getEnv().addToCompressorQueue((BIN) newSibling);</div>
<div>4236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>4237&emsp;&emsp;</div>
<div>4238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                newSibling.appendEntryFromOtherNode(this, i);</div>
<div>4239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                clearEntry(i);</div>
<div>4240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4241&emsp;&emsp;</div>
<div style="background-color:limegreen;">4242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (low == 0) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                shiftEntriesLeft(newSiblingNEntries);</div>
<div>4244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4245&emsp;&emsp;</div>
<div>4246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            nEntries -= newSiblingNEntries;</div>
<div>4247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setDirty(true);</div>
<div>4248&emsp;&emsp;</div>
<div style="background-color:limegreen;">4249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isUpperIN() && haveCachedChildren) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>4250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setHasCachedChildrenFlag(hasCachedChildren());</div>
<div>4251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4252&emsp;&emsp;</div>
<div style="background-color:limegreen;">4253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(isBIN() ||&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">4254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                   hasCachedChildrenFlag() == hasCachedChildren());&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">4255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert(isBIN() ||&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>4256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   newSibling.hasCachedChildrenFlag() ==</div>
<div style="background-color:limegreen;">4257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                   newSibling.hasCachedChildren());&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4258&emsp;&emsp;</div>
<div>4259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            adjustCursors(newSibling, low, high);</div>
<div>4260&emsp;&emsp;</div>
<div>4261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * If this node has no key prefix, calculate it now that it has</div>
<div>4263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * been split.  This must be done before logging, to ensure the</div>
<div>4264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * prefix information is made persistent [#20799].</div>
<div>4265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte[] newKeyPrefix = computeKeyPrefix(-1);</div>
<div>4267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            recalcSuffixes(newKeyPrefix, null, null, -1);</div>
<div>4268&emsp;&emsp;</div>
<div>4269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Apply compaction after prefixing [#20799]. */</div>
<div>4270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.compact(this);</div>
<div>4271&emsp;&emsp;</div>
<div>4272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Only recalc if there are multiple entries in newSibling. */</div>
<div style="background-color:limegreen;">4273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (newSibling.getNEntries() > 1) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>4274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] newSiblingPrefix = newSibling.computeKeyPrefix(-1);</div>
<div>4275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                newSibling.recalcSuffixes(newSiblingPrefix, null, null, -1);</div>
<div>4276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* initMemorySize calls entryKeys.compact. */</div>
<div>4277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                newSibling.initMemorySize();</div>
<div>4278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4279&emsp;&emsp;</div>
<div style="background-color:limegreen;">4280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert idKeyIsSlotKey();&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>4281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            assert newSibling.idKeyIsSlotKey();</div>
<div>4282&emsp;&emsp;</div>
<div>4283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Update size. newSibling and parent are correct, but this IN has</div>
<div>4285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * had its entries shifted and is not correct.</div>
<div>4286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>4287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Also, inMemorySize does not reflect changes that may have</div>
<div>4288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * resulted from key prefixing related changes, it needs to be</div>
<div>4289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * brought up to date, so update it appropriately for this and the</div>
<div>4290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * above reason.</div>
<div>4291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            EnvironmentImpl env = getEnv();</div>
<div>4293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            INList inMemoryINs = env.getInMemoryINs();</div>
<div>4294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long oldMemorySize = inMemorySize;</div>
<div>4295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSize = computeMemorySize();</div>
<div>4296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldMemorySize, newSize);</div>
<div>4297&emsp;&emsp;</div>
<div>4298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Parent refers to child through an element of the entries array.</div>
<div>4300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Depending on which half of the BIN we copied keys from, we</div>
<div>4301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * either have to adjust one pointer and add a new one, or we have</div>
<div>4302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * to just add a new pointer to the new sibling.</div>
<div>4303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>4304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * We must use the provisional logging for two reasons:</div>
<div>4305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>4306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   1) All three log entries must be read atomically. The parent</div>
<div>4307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   must get logged last, as all referred-to children must precede</div>
<div>4308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   it. Provisional entries guarantee that all three are processed</div>
<div>4309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   as a unit. Recovery skips provisional entries, so the changed</div>
<div>4310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   children are only used if the parent makes it out to the log.</div>
<div>4311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>4312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   2) We log all they way to the root to avoid the "great aunt"</div>
<div>4313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   problem (see LevelRecorder), and provisional logging is</div>
<div>4314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   necessary during a checkpoint for levels less than</div>
<div>4315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *   maxFlushLevel.</div>
<div>4316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             *</div>
<div>4317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * We prohibit compression during logging because there should be</div>
<div>4318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * at least one entry in each IN. Note the use of getKey(0) below.</div>
<div>4319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSiblingLsn =</div>
<div>4321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                newSibling.optionalLogProvisionalNoCompress(parent);</div>
<div>4322&emsp;&emsp;</div>
<div>4323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long myNewLsn = optionalLogProvisionalNoCompress(parent);</div>
<div>4324&emsp;&emsp;</div>
<div>4325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            assert nEntries > 0;</div>
<div>4326&emsp;&emsp;</div>
<div>4327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * When we update the parent entry, we make sure that we don't</div>
<div>4329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * replace the parent's key that points at 'this' with a key that</div>
<div>4330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * is > than the existing one.  Replacing the parent's key with</div>
<div>4331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * something > would effectively render a piece of the subtree</div>
<div>4332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * inaccessible.  So only replace the parent key with something</div>
<div>4333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * &#60;= the existing one.  See tree/SplitTest.java for more details</div>
<div>4334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * on the scenario.</div>
<div>4335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (low == 0) {</div>
<div>4337&emsp;&emsp;</div>
<div>4338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>4339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Change the original entry to point to the new child and add</div>
<div>4340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * an entry to point to the newly logged version of this</div>
<div>4341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * existing child.</div>
<div>4342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div>4343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent.prepareForSlotReuse(childIndex);</div>
<div>4344&emsp;&emsp;</div>
<div>4345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent.updateSplitSlot(</div>
<div>4346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    childIndex, newSibling, newSiblingLsn, newIdKey);</div>
<div>4347&emsp;&emsp;</div>
<div>4348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                boolean inserted = parent.insertEntry(</div>
<div>4349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    this, getKey(0), myNewLsn);</div>
<div>4350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                assert inserted;</div>
<div>4351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>4352&emsp;&emsp;</div>
<div>4353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>4354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Update the existing child's LSN to reflect the newly logged</div>
<div>4355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * version and insert new child into parent.</div>
<div>4356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div>4357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parent.updateSplitSlot(childIndex, this, myNewLsn, getKey(0));</div>
<div>4358&emsp;&emsp;</div>
<div>4359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                boolean inserted = parent.insertEntry(</div>
<div>4360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    newSibling, newIdKey, newSiblingLsn);</div>
<div>4361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                assert inserted;</div>
<div>4362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4363&emsp;&emsp;</div>
<div>4364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            inMemoryINs.add(newSibling);</div>
<div>4365&emsp;&emsp;</div>
<div>4366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /**</div>
<div>4367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Log the parent. Note that the root slot or grandparent slot is</div>
<div>4368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * not updated with the parent's LSN here; this is done by</div>
<div>4369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Tree.forceSplit.</div>
<div>4370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (parent.isRoot()) {</div>
<div>4372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parentLsn = parent.optionalLog();</div>
<div>4373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>4374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                parentLsn = parent.optionalLogProvisional(grandParent);</div>
<div>4375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4376&emsp;&emsp;</div>
<div>4377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Coordinate the split with an in-progress checkpoint. */</div>
<div>4378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            env.getCheckpointer().coordinateSplitWithCheckpoint(newSibling);</div>
<div>4379&emsp;&emsp;</div>
<div>4380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Check whether either the old or the new sibling must be added</div>
<div>4382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * to the LRU (priority-1 LRUSet).</div>
<div>4383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            assert(!isDIN() && !isDBIN());</div>
<div>4385&emsp;&emsp;</div>
<div>4386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if(isBIN() || !newSibling.hasCachedChildrenFlag()) {</div>
<div>4387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (isUpperIN() && traceLRU) {</div>
<div>4388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    LoggerUtils.envLogMsg(</div>
<div>4389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        traceLevel, getEnv(),</div>
<div>4390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        "split-newSibling " +</div>
<div>4391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            Thread.currentThread().getId() + "-" +</div>
<div>4392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            Thread.currentThread().getName() +</div>
<div>4393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            "-" + getEnv().getName() +</div>
<div>4394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            " Adding UIN to LRU: " +</div>
<div>4395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            newSibling.getNodeId());</div>
<div>4396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>4397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getEvictor().addBack(newSibling);</div>
<div>4398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4399&emsp;&emsp;</div>
<div>4400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (isUpperIN() &&</div>
<div>4401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                haveCachedChildren &&</div>
<div>4402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                !hasCachedChildrenFlag()) {</div>
<div>4403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (traceLRU) {</div>
<div>4404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    LoggerUtils.envLogMsg(</div>
<div>4405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        traceLevel, getEnv(),</div>
<div>4406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        "split-oldSibling " +</div>
<div>4407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        Thread.currentThread().getId() + "-" +</div>
<div>4408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        Thread.currentThread().getName() +</div>
<div>4409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        "-" + getEnv().getName() +</div>
<div>4410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        " Adding UIN to LRU: " + getNodeId());</div>
<div>4411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>4412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getEvictor().addBack(this);</div>
<div>4413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4414&emsp;&emsp;</div>
<div>4415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Debug log this information. */</div>
<div>4416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            traceSplit(Level.FINE, parent,</div>
<div>4417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                       newSibling, parentLsn, myNewLsn,</div>
<div>4418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                       newSiblingLsn, splitIndex, idKeyIndex, childIndex);</div>
<div>4419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } finally {</div>
<div>4420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            newSibling.releaseLatch();</div>
<div>4421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4422&emsp;&emsp;</div>
<div>4423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return newSibling;</div>
<div>4424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4425&emsp;&emsp;</div>
<div>4426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used for moving entries between BINs during splits.</div>
<div>4428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void appendEntryFromOtherNode(IN from, int fromIdx) {</div>
<div>4430&emsp;&emsp;</div>
<div style="background-color:limegreen;">4431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>4432&emsp;&emsp;</div>
<div>4433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Node target = from.entryTargets.get(fromIdx);</div>
<div>4434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int ohBinId = from.getOffHeapBINId(fromIdx);</div>
<div>4435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean ohBinPri2 = from.isOffHeapBINPri2(fromIdx);</div>
<div>4436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean ohBinDirty = from.isOffHeapBINDirty(fromIdx);</div>
<div>4437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long lsn = from.getLsn(fromIdx);</div>
<div>4438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte state = from.entryStates[fromIdx];</div>
<div>4439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final byte[] key = from.getKey(fromIdx);</div>
<div style="background-color:limegreen;">4440&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final byte[] data = (from.haveEmbeddedData(fromIdx) ?&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                             from.getData(fromIdx) : null);</div>
<div>4442&emsp;&emsp;</div>
<div>4443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSize = computeLsnOverhead();</div>
<div>4444&emsp;&emsp;</div>
<div>4445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ++nEntries;</div>
<div>4446&emsp;&emsp;</div>
<div>4447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx = nEntries - 1;</div>
<div>4448&emsp;&emsp;</div>
<div>4449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>4450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * When calling setTarget for an IN child we must latch it, because</div>
<div>4451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * setTarget sets the parent.</div>
<div>4452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>4453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (target != null && target.isIN()) {</div>
<div>4454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final IN in = (IN) target;</div>
<div>4455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            in.latchNoUpdateLRU(databaseImpl);</div>
<div>4456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setTarget(idx, target);</div>
<div>4457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            in.releaseLatch();</div>
<div>4458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setTarget(idx, target);</div>
<div>4460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4461&emsp;&emsp;</div>
<div>4462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean multiSlotChange = insertKey(idx, key, data);</div>
<div>4463&emsp;&emsp;</div>
<div>4464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* setLsnInternal can mutate to an array of longs. */</div>
<div>4465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsnInternal(idx, lsn);</div>
<div>4466&emsp;&emsp;</div>
<div>4467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates[idx] = state;</div>
<div>4468&emsp;&emsp;</div>
<div>4469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (ohBinId >= 0) {</div>
<div>4470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setOffHeapBINId(idx, ohBinId, ohBinPri2, ohBinDirty);</div>
<div>4471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getOffHeapCache().setOwner(ohBinId, this);</div>
<div>4472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4473&emsp;&emsp;</div>
<div>4474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (multiSlotChange) {</div>
<div>4475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>4476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSize = getEntryInMemorySize(idx) + computeLsnOverhead();</div>
<div>4478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSize, newSize);</div>
<div>4479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4480&emsp;&emsp;</div>
<div>4481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>4482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4483&emsp;&emsp;</div>
<div>4484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Update a slot that is being split. The slot to be updated here is the</div>
<div>4486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * one that existed before the split.</div>
<div>4487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param child The new child to be placed under the slot. May be the</div>
<div>4489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * newly created sibling or the pre-existing sibling.</div>
<div>4490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param lsn The new lsn of the child (the child was logged just before</div>
<div>4491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * calling this method, so its slot lsn must be updated)</div>
<div>4492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param key The new key for the slot. We should not actually update the</div>
<div>4493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * slot key, because its value is the lower bound of the key range covered</div>
<div>4494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * by the slot, and this lower bound does not change as a result of the</div>
<div>4495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * split (the new slot created as a result of the split is placed to the</div>
<div>4496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * right of the pre-existing slot). There is however one exception: the</div>
<div>4497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * key can be updated if "idx" is the 0-slot. The 0-slot key is not a true</div>
<div>4498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * lower bound; the actual lower bound for the 0-slot is the key in the</div>
<div>4499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parent slot for this IN. So, in this case, if the given key is less</div>
<div>4500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * than the current one, it is better to update the key in order to better</div>
<div>4501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * approximate the real lower bound (and thus make the isKeyInBounds()</div>
<div>4502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * method more effective).</div>
<div>4503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void updateSplitSlot(</div>
<div>4505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int idx,</div>
<div>4506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN child,</div>
<div>4507&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long lsn,</div>
<div>4508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte[] key) {</div>
<div>4509&emsp;&emsp;</div>
<div>4510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(isUpperIN());</div>
<div>4511&emsp;&emsp;</div>
<div>4512&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long oldSize = getEntryInMemorySize(idx);</div>
<div>4513&emsp;&emsp;</div>
<div>4514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setLsn(idx, lsn);</div>
<div>4515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setTarget(idx, child);</div>
<div>4516&emsp;&emsp;</div>
<div>4517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (idx == 0) {</div>
<div>4518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int s = entryKeys.compareKeys(</div>
<div>4519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                key, keyPrefix, idx, haveEmbeddedData(idx),</div>
<div>4520&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                getKeyComparator());</div>
<div>4521&emsp;&emsp;</div>
<div>4522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean multiSlotChange = false;</div>
<div>4523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (s &#60; 0) {</div>
<div>4524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                multiSlotChange = updateKey(idx, key, null/*data*/);</div>
<div>4525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4526&emsp;&emsp;</div>
<div>4527&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (multiSlotChange) {</div>
<div>4528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>4529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>4530&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                long newSize = getEntryInMemorySize(idx);</div>
<div>4531&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                updateMemorySize(oldSize, newSize);</div>
<div>4532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long newSize = getEntryInMemorySize(idx);</div>
<div>4535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(oldSize, newSize);</div>
<div>4536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4537&emsp;&emsp;</div>
<div>4538&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>4539&emsp;&emsp;</div>
<div>4540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(hasCachedChildren() == hasCachedChildrenFlag());</div>
<div>4541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4542&emsp;&emsp;</div>
<div>4543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Shift entries to the right by one position, starting with (and</div>
<div>4545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * including) the entry at index. Increment nEntries by 1. Called</div>
<div>4546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * in insertEntry1()</div>
<div>4547&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param index - The position to start shifting from.</div>
<div>4549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void shiftEntriesRight(int index) {</div>
<div>4551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        copyEntries(index, index + 1, nEntries - index);</div>
<div>4552&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        clearEntry(index);</div>
<div>4553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nEntries++;</div>
<div>4554&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>4555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4556&emsp;&emsp;</div>
<div>4557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Shift entries starting at the byHowMuch'th element to the left, thus</div>
<div>4559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * removing the first byHowMuch'th elements of the entries array.  This</div>
<div>4560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * always starts at the 0th entry. Caller is responsible for decrementing</div>
<div>4561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * nEntries.</div>
<div>4562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @param byHowMuch - The number of entries to remove from the left side</div>
<div>4564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * of the entries array.</div>
<div>4565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void shiftEntriesLeft(int byHowMuch) {</div>
<div>4567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        copyEntries(byHowMuch, 0, nEntries - byHowMuch);</div>
<div style="background-color:limegreen;">4568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = nEntries - byHowMuch; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>4569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            clearEntry(i);</div>
<div>4570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        setDirty(true);</div>
<div>4572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4573&emsp;&emsp;</div>
<div>4574&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void adjustCursors(</div>
<div>4575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN newSibling,</div>
<div>4576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSiblingLow,</div>
<div>4577&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int newSiblingHigh) {</div>
<div>4578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Cursors never refer to IN's. */</div>
<div>4579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4580&emsp;&emsp;</div>
<div>4581&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void adjustCursorsForInsert(int insertIndex) {</div>
<div>4582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Cursors never refer to IN's. */</div>
<div>4583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4584&emsp;&emsp;</div>
<div>4585&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called prior to changing a slot to contain a different logical node.</div>
<div>4587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Necessary to support assertions for transient LSNs in shouldUpdateLsn.</div>
<div>4589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Examples: LN slot reuse, and splits where a new node is placed in an</div>
<div>4590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * existing slot.</div>
<div>4591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Also needed to free the off-heap BIN associated with the old node.</div>
<div>4593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4594&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * TODO: This method is no longer used for LN slot reuse, and freeing of</div>
<div>4595&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the off-heap BIN could be done by the only caller, splitInternal, and</div>
<div>4596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * then this method could be removed.</div>
<div>4597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4598&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void prepareForSlotReuse(int idx) {</div>
<div>4599&emsp;&emsp;</div>
<div>4600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (databaseImpl.isDeferredWriteMode()) {</div>
<div>4601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLsn(idx, DbLsn.NULL_LSN, false/*check*/);</div>
<div>4602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4603&emsp;&emsp;</div>
<div>4604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</div>
<div>4605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (ohCache.isEnabled() && getNormalizedLevel() == 2) {</div>
<div>4606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ohCache.freeBIN((BIN) getTarget(idx), this, idx);</div>
<div>4607&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4609&emsp;&emsp;</div>
<div>4610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the current memory consumption of this node</div>
<div>4612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4613&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getInMemorySize() {</div>
<div>4614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return inMemorySize;</div>
<div>4615&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4616&emsp;&emsp;</div>
<div>4617&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Compute the current memory consumption of this node, after putting</div>
<div>4619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * its keys in their compact representation, if possible.</div>
<div>4620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void initMemorySize() {</div>
<div>4622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = entryKeys.compact(this);</div>
<div>4623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        inMemorySize = computeMemorySize();</div>
<div>4624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4625&emsp;&emsp;</div>
<div>4626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Count up the memory usage attributable to this node alone. LNs children</div>
<div>4628&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * are counted by their BIN parents, but INs are not counted by their</div>
<div>4629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * parents because they are resident on the IN list.  The identifierKey is</div>
<div>4630&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * "intentionally" not kept track of in the memory budget.</div>
<div>4631&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4632&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long computeMemorySize() {</div>
<div>4633&emsp;&emsp;</div>
<div>4634&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long calcMemorySize = getFixedMemoryOverhead();</div>
<div>4635&emsp;&emsp;</div>
<div>4636&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        calcMemorySize += MemoryBudget.byteArraySize(entryStates.length);</div>
<div>4637&emsp;&emsp;</div>
<div>4638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        calcMemorySize += computeLsnOverhead();</div>
<div>4639&emsp;&emsp;</div>
<div style="background-color:limegreen;">4640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            calcMemorySize += getEntryInMemorySize(i);</div>
<div>4642&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4643&emsp;&emsp;</div>
<div style="background-color:limegreen;">4644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (keyPrefix != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4645&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            calcMemorySize += MemoryBudget.byteArraySize(keyPrefix.length);</div>
<div>4646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4647&emsp;&emsp;</div>
<div style="background-color:limegreen;">4648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (provisionalObsolete != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            calcMemorySize += provisionalObsolete.getMemorySize();</div>
<div>4650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4651&emsp;&emsp;</div>
<div>4652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        calcMemorySize += entryTargets.calculateMemorySize();</div>
<div>4653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        calcMemorySize += entryKeys.calculateMemorySize();</div>
<div>4654&emsp;&emsp;</div>
<div style="background-color:limegreen;">4655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (offHeapBINIds != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4656&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            calcMemorySize += offHeapBINIds.getMemorySize();</div>
<div>4657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4658&emsp;&emsp;</div>
<div>4659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return calcMemorySize;</div>
<div>4660&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4661&emsp;&emsp;</div>
<div>4662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4663&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overridden by subclasses.</div>
<div>4664&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected long getFixedMemoryOverhead() {</div>
<div>4666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return MemoryBudget.IN_FIXED_OVERHEAD;</div>
<div>4667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4668&emsp;&emsp;</div>
<div>4669&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Compute the memory consumption for storing this node's LSNs</div>
<div>4671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int computeLsnOverhead() {</div>
<div style="background-color:limegreen;">4673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (entryLsnLongArray == null) ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            MemoryBudget.byteArraySize(entryLsnByteArray.length) :</div>
<div>4675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            MemoryBudget.ARRAY_OVERHEAD +</div>
<div>4676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (entryLsnLongArray.length *</div>
<div>4677&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 MemoryBudget.PRIMITIVE_LONG_ARRAY_ITEM_OVERHEAD);</div>
<div>4678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4679&emsp;&emsp;</div>
<div>4680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private long getEntryInMemorySize(int idx) {</div>
<div>4681&emsp;&emsp;</div>
<div>4682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>4683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Do not count state size here, since it is counted as overhead</div>
<div>4684&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * during initialization.</div>
<div>4685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>4686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long ret = 0;</div>
<div>4687&emsp;&emsp;</div>
<div>4688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>4689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Don't count the key size if the representation has already</div>
<div>4690&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * accounted for it.</div>
<div>4691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">4692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!entryKeys.accountsForKeyByteMemUsage()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4693&emsp;&emsp;</div>
<div>4694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Materialize the key object only if needed, thus avoiding the</div>
<div>4696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * object allocation cost when possible.</div>
<div>4697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>4698&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            final byte[] key = entryKeys.get(idx);</div>
<div style="background-color:limegreen;">4699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (key != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ret += MemoryBudget.byteArraySize(key.length);</div>
<div>4701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4703&emsp;&emsp;</div>
<div>4704&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Node target = entryTargets.get(idx);</div>
<div style="background-color:limegreen;">4705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (target != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ret += target.getMemorySizeIncludedByParent();</div>
<div>4707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ret;</div>
<div>4709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4710&emsp;&emsp;</div>
<div>4711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Compacts the representation of the IN, if possible.</div>
<div>4713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called by the evictor to reduce memory usage. Should not be called too</div>
<div>4715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * often (e.g., every CRUD operation), since this could cause lots of</div>
<div>4716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * memory allocations as the representations contract and expend, resulting</div>
<div>4717&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * in expensive GC.</div>
<div>4718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return number of bytes reclaimed.</div>
<div>4720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long compactMemory() {</div>
<div>4722&emsp;&emsp;</div>
<div>4723&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long oldSize = inMemorySize;</div>
<div>4724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final INKeyRep oldKeyRep = entryKeys;</div>
<div>4725&emsp;&emsp;</div>
<div>4726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = entryTargets.compact(this);</div>
<div>4727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = entryKeys.compact(this);</div>
<div>4728&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        offHeapBINIds = offHeapBINIds.compact(this, EMPTY_OFFHEAP_BIN_IDS);</div>
<div>4729&emsp;&emsp;</div>
<div>4730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>4731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Note that we only need to account for mem usage changes in the key</div>
<div>4732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * rep here, not the target rep.  The target rep, unlike the key rep,</div>
<div>4733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * updates its mem usage internally, and the responsibility for mem</div>
<div>4734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * usage of contained nodes is fixed -- it is always managed by the IN.</div>
<div>4735&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>4736&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * When the key rep changes, the accountsForKeyByteMemUsage property</div>
<div>4737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * also changes. Recalc the size of the entire IN, because</div>
<div>4738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * responsibility for managing contained key byte mem usage has shifted</div>
<div>4739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * between the key rep and the IN parent.</div>
<div>4740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">4741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryKeys != oldKeyRep) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</div>
<div>4743&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4744&emsp;&emsp;</div>
<div>4745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return oldSize - inMemorySize;</div>
<div>4746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4747&emsp;&emsp;</div>
<div>4748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4749&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the amount of memory currently budgeted for this IN.</div>
<div>4750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getBudgetedMemorySize() {</div>
<div>4752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return inMemorySize - accumulatedDelta;</div>
<div>4753&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4754&emsp;&emsp;</div>
<div>4755&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called as part of a memory budget reset (during a checkpoint) to clear</div>
<div>4757&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the accumulated delta and return the total memory size.</div>
<div>4758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4759&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long resetAndGetMemorySize() {</div>
<div>4760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        accumulatedDelta = 0;</div>
<div>4761&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return inMemorySize;</div>
<div>4762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4763&emsp;&emsp;</div>
<div>4764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected void updateMemorySize(long oldSize, long newSize) {</div>
<div>4765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long delta = newSize - oldSize;</div>
<div>4766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(delta);</div>
<div>4767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4768&emsp;&emsp;</div>
<div>4769&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called when a cached child is replaced by another cached child.</div>
<div>4771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4772&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void updateMemorySize(Node oldNode, Node newNode) {</div>
<div>4773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long delta = 0;</div>
<div style="background-color:limegreen;">4774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (newNode != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            delta = newNode.getMemorySizeIncludedByParent();</div>
<div>4776&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4777&emsp;&emsp;</div>
<div style="background-color:limegreen;">4778&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (oldNode != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            delta -= oldNode.getMemorySizeIncludedByParent();</div>
<div>4780&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        updateMemorySize(delta);</div>
<div>4782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4783&emsp;&emsp;</div>
<div>4784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4785&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Change this.onMemorySize by the given delta and update the memory</div>
<div>4786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * budget for the cache, but only if the accummulated delta for this</div>
<div>4787&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * node exceeds the ACCUMULATED_LIMIT threshold and this IN is actually</div>
<div>4788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * on the IN list. (For example, when we create new INs, they are</div>
<div>4789&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * manipulated off the IN list before being added; if we updated the</div>
<div>4790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * environment wide cache then, we'd end up double counting.)</div>
<div>4791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void updateMemorySize(long delta) {</div>
<div>4793&emsp;&emsp;</div>
<div style="background-color:limegreen;">4794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (delta == 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4795&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>4796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4797&emsp;&emsp;</div>
<div>4798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        inMemorySize += delta;</div>
<div>4799&emsp;&emsp;</div>
<div style="background-color:limegreen;">4800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (getInListResident()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4801&emsp;&emsp;</div>
<div>4802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>4803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * This assertion is disabled if the environment is invalid to</div>
<div>4804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * avoid spurious assertions during testing of IO errors.  If the</div>
<div>4805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * environment is invalid, memory budgeting errors are irrelevant.</div>
<div>4806&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * [#21929]</div>
<div>4807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">4808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">4809&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                inMemorySize >= getFixedMemoryOverhead() ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">4810&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                !getEnv().isValid():&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "delta: " + delta + " inMemorySize: " + inMemorySize +</div>
<div>4812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " overhead: " + getFixedMemoryOverhead() +</div>
<div>4813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " computed: " + computeMemorySize() +</div>
<div>4814&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " dump: " + toString() + assertPrintMemorySize();</div>
<div>4815&emsp;&emsp;</div>
<div>4816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            accumulatedDelta += delta;</div>
<div style="background-color:limegreen;">4817&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (accumulatedDelta > ACCUMULATED_LIMIT ||&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                accumulatedDelta &#60; -ACCUMULATED_LIMIT) {</div>
<div>4819&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                updateMemoryBudget();</div>
<div>4820&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>4821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4823&emsp;&emsp;</div>
<div>4824&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Move the accumulated delta to the memory budget.</div>
<div>4826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4827&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void updateMemoryBudget() {</div>
<div>4828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl env = getEnv();</div>
<div>4829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        env.getInMemoryINs().memRecalcUpdate(this, accumulatedDelta);</div>
<div>4830&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        env.getMemoryBudget().updateTreeMemoryUsage(accumulatedDelta);</div>
<div>4831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        accumulatedDelta = 0;</div>
<div>4832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4833&emsp;&emsp;</div>
<div>4834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the treeAdmin memory in objects referenced by this IN.</div>
<div>4836&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Specifically, this refers to the DbFileSummaryMap held by</div>
<div>4837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * MapLNs</div>
<div>4838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4839&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getTreeAdminMemorySize() {</div>
<div>4840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return 0;  // by default, no treeAdminMemory</div>
<div>4841&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4842&emsp;&emsp;</div>
<div>4843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>4844&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  Utility method used during unit testing.</div>
<div>4845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected long printMemorySize() {</div>
<div>4847&emsp;&emsp;</div>
<div>4848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long inOverhead = getFixedMemoryOverhead();</div>
<div>4849&emsp;&emsp;</div>
<div>4850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long statesOverhead =</div>
<div>4851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            MemoryBudget.byteArraySize(entryStates.length);</div>
<div>4852&emsp;&emsp;</div>
<div>4853&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int lsnOverhead =  computeLsnOverhead();</div>
<div>4854&emsp;&emsp;</div>
<div>4855&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int entryOverhead = 0;</div>
<div style="background-color:limegreen;">4856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4857&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryOverhead += getEntryInMemorySize(i);</div>
<div>4858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4859&emsp;&emsp;</div>
<div style="background-color:limegreen;">4860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final int keyPrefixOverhead =  (keyPrefix != null) ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4861&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            MemoryBudget.byteArraySize(keyPrefix.length) : 0;</div>
<div>4862&emsp;&emsp;</div>
<div style="background-color:limegreen;">4863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final int provisionalOverhead = (provisionalObsolete != null) ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            provisionalObsolete.getMemorySize() : 0;</div>
<div>4865&emsp;&emsp;</div>
<div>4866&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long targetRepOverhead = entryTargets.calculateMemorySize();</div>
<div>4867&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long keyRepOverhead = entryKeys.calculateMemorySize();</div>
<div>4868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long total = inOverhead + statesOverhead + lsnOverhead +</div>
<div>4869&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             entryOverhead + keyPrefixOverhead +  provisionalOverhead +</div>
<div>4870&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             targetRepOverhead + keyRepOverhead;</div>
<div>4871&emsp;&emsp;</div>
<div>4872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long offHeapBINIdOverhead = offHeapBINIds.getMemorySize();</div>
<div>4873&emsp;&emsp;</div>
<div>4874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(" nEntries:" + nEntries +</div>
<div>4875&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           "/" + entryStates.length +</div>
<div>4876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " in: " + inOverhead +</div>
<div>4877&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " states: " + statesOverhead +</div>
<div>4878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " entry: " + entryOverhead +</div>
<div>4879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " lsn: " + lsnOverhead +</div>
<div>4880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " keyPrefix: " + keyPrefixOverhead +</div>
<div>4881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " provisional: " + provisionalOverhead +</div>
<div>4882&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " targetRep(" + entryTargets.getType() + "): " +</div>
<div>4883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           targetRepOverhead +</div>
<div>4884&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " keyRep(" + entryKeys.getType() +"): " +</div>
<div>4885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           keyRepOverhead +</div>
<div>4886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " offHeapBINIds: " + offHeapBINIdOverhead +</div>
<div>4887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " Total: " + total +</div>
<div>4888&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           " inMemorySize: " + inMemorySize);</div>
<div>4889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return total;</div>
<div>4890&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4891&emsp;&emsp;</div>
<div>4892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /* Utility method used to print memory size in an assertion. */</div>
<div>4893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean assertPrintMemorySize() {</div>
<div>4894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        printMemorySize();</div>
<div>4895&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>4896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4897&emsp;&emsp;</div>
<div>4898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean verifyMemorySize() {</div>
<div>4899&emsp;&emsp;</div>
<div>4900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long calcMemorySize = computeMemorySize();</div>
<div style="background-color:limegreen;">4901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (calcMemorySize != inMemorySize) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4902&emsp;&emsp;</div>
<div>4903&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            String msg = "-Warning: Out of sync. Should be " +</div>
<div>4904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                calcMemorySize + " / actual: " + inMemorySize +</div>
<div>4905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " node: " + getNodeId();</div>
<div>4906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LoggerUtils.envLogMsg(Level.INFO, getEnv(), msg);</div>
<div>4907&emsp;&emsp;</div>
<div>4908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.out.println(msg);</div>
<div>4909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            printMemorySize();</div>
<div>4910&emsp;&emsp;</div>
<div>4911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>4912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return true;</div>
<div>4914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4915&emsp;&emsp;</div>
<div>4916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4917&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Adds (increments) or removes (decrements) the cache stats for the key</div>
<div>4918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and target representations.  Used when rep objects are being replaced</div>
<div>4919&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * with a new instance, rather than by calling their mutator methods.</div>
<div>4920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Specifically, it is called when mutating from full bin to bin delta</div>
<div>4921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * or vice-versa.</div>
<div>4922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4923&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected void updateRepCacheStats(boolean increment) {</div>
<div style="background-color:limegreen;">4924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4925&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys.updateCacheStats(increment, this);</div>
<div>4926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets.updateCacheStats(increment, this);</div>
<div>4927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4928&emsp;&emsp;</div>
<div>4929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected int getCompactMaxKeyLength() {</div>
<div>4930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getEnv().getCompactMaxKeyLength();</div>
<div>4931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4932&emsp;&emsp;</div>
<div>4933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Called when adding/removing this IN to/from the INList.</div>
<div>4935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4936&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setInListResident(boolean resident) {</div>
<div>4937&emsp;&emsp;</div>
<div style="background-color:limegreen;">4938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!resident) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Decrement the stats before clearing its residency */</div>
<div>4940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryTargets.updateCacheStats(false, this);</div>
<div>4941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys.updateCacheStats(false, this);</div>
<div>4942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4943&emsp;&emsp;</div>
<div style="background-color:limegreen;">4944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (resident) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_RESIDENT_BIT;</div>
<div>4946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>4947&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_RESIDENT_BIT;</div>
<div>4948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4949&emsp;&emsp;</div>
<div style="background-color:limegreen;">4950&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (resident) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /* Increment the stats after setting its residency. */</div>
<div>4952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryTargets.updateCacheStats(true, this);</div>
<div>4953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys.updateCacheStats(true, this);</div>
<div>4954&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>4955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4956&emsp;&emsp;</div>
<div>4957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4958&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether this IN is on the INList.</div>
<div>4959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4960&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean getInListResident() {</div>
<div style="background-color:limegreen;">4961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_RESIDENT_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4962&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4963&emsp;&emsp;</div>
<div>4964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN getPrevLRUNode() {</div>
<div>4965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    	return prevLRUNode;</div>
<div>4966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4967&emsp;&emsp;</div>
<div>4968&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setPrevLRUNode(IN node) {</div>
<div>4969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    	prevLRUNode = node;</div>
<div>4970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4971&emsp;&emsp;</div>
<div>4972&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public IN getNextLRUNode() {</div>
<div>4973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    	return nextLRUNode;</div>
<div>4974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4975&emsp;&emsp;</div>
<div>4976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setNextLRUNode(IN node) {</div>
<div>4977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    	nextLRUNode = node;</div>
<div>4978&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4979&emsp;&emsp;</div>
<div>4980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Try to compact or otherwise reclaim memory in this IN and return the</div>
<div>4982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * number of bytes reclaimed. For example, a BIN should evict LNs, if</div>
<div>4983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * possible.</div>
<div>4984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>4985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used by the evictor to reclaim memory by some means short of evicting</div>
<div>4986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the entire node.  If a positive value is returned, the evictor will</div>
<div>4987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * postpone full eviction of this node.</div>
<div>4988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long partialEviction() {</div>
<div>4990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return 0;</div>
<div>4991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>4992&emsp;&emsp;</div>
<div>4993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>4994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether any child is non-null in the main or off-heap cache.</div>
<div>4995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>4996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean hasCachedChildren() {</div>
<div style="background-color:limegreen;">4997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert isLatchOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>4998&emsp;&emsp;</div>
<div style="background-color:limegreen;">4999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5000&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (entryTargets.get(i) != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return true;</div>
<div>5002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5004&emsp;&emsp;</div>
<div>5005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>5006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5007&emsp;&emsp;</div>
<div>5008&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Disallow delta on next log. Set to true (a) when we we delete a slot</div>
<div>5010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * from a BIN, (b) when the cleaner marks a BIN as dirty so that it will</div>
<div>5011&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * be migrated during the next checkpoint.</div>
<div>5012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setProhibitNextDelta(boolean val) {</div>
<div>5014&emsp;&emsp;</div>
<div style="background-color:limegreen;">5015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5016&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>5017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5018&emsp;&emsp;</div>
<div style="background-color:limegreen;">5019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (val) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags |= IN_PROHIBIT_NEXT_DELTA_BIT;</div>
<div>5021&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>5022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            flags &= ~IN_PROHIBIT_NEXT_DELTA_BIT;</div>
<div>5023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5024&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5025&emsp;&emsp;</div>
<div>5026&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean getProhibitNextDelta() {</div>
<div style="background-color:limegreen;">5027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (flags & IN_PROHIBIT_NEXT_DELTA_BIT) != 0;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5029&emsp;&emsp;</div>
<div>5030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>5031&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Validate the subtree that we're about to delete.  Make sure there aren't</div>
<div>5032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * more than one valid entry on each IN and that the last level of the tree</div>
<div>5033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * is empty. Also check that there are no cursors on any bins in this</div>
<div>5034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * subtree. Assumes caller is holding the latch on this parent node.</div>
<div>5035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * While we could latch couple down the tree, rather than hold latches as</div>
<div>5037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * we descend, we are presumably about to delete this subtree so</div>
<div>5038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * concurrency shouldn't be an issue.</div>
<div>5039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return true if the subtree rooted at the entry specified by "index" is</div>
<div>5041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * ok to delete.</div>
<div>5042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5043&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overriden by BIN class.</div>
<div>5044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5045&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean validateSubtreeBeforeDelete(int index)</div>
<div>5046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>5047&emsp;&emsp;</div>
<div>5048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (index >= nEntries) {</div>
<div>5049&emsp;&emsp;</div>
<div>5050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>5051&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * There's no entry here, so of course this entry is deletable.</div>
<div>5052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>5053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>5054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>5055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            IN child = fetchIN(index, CacheMode.UNCHANGED);</div>
<div>5056&emsp;&emsp;</div>
<div>5057&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean needToLatch = !child.isLatchExclusiveOwner();</div>
<div>5058&emsp;&emsp;</div>
<div>5059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>5060&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (needToLatch) {</div>
<div>5061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.latch(CacheMode.UNCHANGED);</div>
<div>5062&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5063&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return child.isValidForDelete();</div>
<div>5064&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } finally {</div>
<div>5065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (needToLatch && isLatchOwner()) {</div>
<div>5066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.releaseLatch();</div>
<div>5067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5068&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5071&emsp;&emsp;</div>
<div>5072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Check if this node fits the qualifications for being part of a deletable</div>
<div>5074&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * subtree. It can only have one IN child and no LN children.</div>
<div>5075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Note: the method is overwritten by BIN and LN.</div>
<div>5077&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BIN.isValidForDelete() will not fetch any child LNs.</div>
<div>5078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * LN.isValidForDelete() simply returns false.</div>
<div>5079&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * We assume that this is only called under an assert.</div>
<div>5081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>5083&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    boolean isValidForDelete()</div>
<div>5084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>5085&emsp;&emsp;</div>
<div>5086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        assert(!isBINDelta());</div>
<div>5087&emsp;&emsp;</div>
<div>5088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>5089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Can only have one valid child, and that child should be</div>
<div>5090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * deletable.</div>
<div>5091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>5092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (nEntries > 1) {            // more than 1 entry.</div>
<div>5093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>5094&emsp;&emsp;</div>
<div>5095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else if (nEntries == 1) {    // 1 entry, check child</div>
<div>5096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            IN child = fetchIN(0, CacheMode.UNCHANGED);</div>
<div>5097&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean needToLatch = !child.isLatchExclusiveOwner();</div>
<div>5098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (needToLatch) {</div>
<div>5099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child.latch(CacheMode.UNCHANGED);</div>
<div>5100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5101&emsp;&emsp;</div>
<div>5102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean ret = false;</div>
<div>5103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            try {</div>
<div>5104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (child.isBINDelta()) {</div>
<div>5105&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    return false;</div>
<div>5106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5107&emsp;&emsp;</div>
<div>5108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ret = child.isValidForDelete();</div>
<div>5109&emsp;&emsp;</div>
<div>5110&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } finally {</div>
<div>5111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (needToLatch) {</div>
<div>5112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.releaseLatch();</div>
<div>5113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return ret;</div>
<div>5116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {                       // 0 entries.</div>
<div>5117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return true;</div>
<div>5118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5120&emsp;&emsp;</div>
<div>5121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Check that the IN is in a valid state.  For now, validity means that the</div>
<div>5123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * keys are in sorted order and that there are more than 0 entries.</div>
<div>5124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * maxKey, if non-null specifies that all keys in this node must be less</div>
<div>5125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * than maxKey.</div>
<div>5126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @throws EnvironmentFailureException when implemented.</div>
<div>5127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5128&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>5129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void verify(byte[] maxKey)</div>
<div>5130&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws EnvironmentFailureException {</div>
<div>5131&emsp;&emsp;</div>
<div>5132&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /********* never used, but may be used for the basis of a verify()</div>
<div>5133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   method in the future.</div>
<div>5134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        try {</div>
<div>5135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Comparator&#60;byte[]> userCompareToFcn =</div>
<div>5136&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (databaseImpl == null ? null : getKeyComparator());</div>
<div>5137&emsp;&emsp;</div>
<div>5138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte[] key1 = null;</div>
<div>5139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            for (int i = 1; i &#60; nEntries; i++) {</div>
<div>5140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                key1 = entryKeys.get(i);</div>
<div>5141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte[] key2 = entryKeys.get(i - 1);</div>
<div>5142&emsp;&emsp;</div>
<div>5143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int s = Key.compareKeys(key1, key2, userCompareToFcn);</div>
<div>5144&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (s &#60;= 0) {</div>
<div>5145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    throw EnvironmentFailureException.unexpectedState</div>
<div>5146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        ("IN " + getNodeId() + " key " + (i-1) +</div>
<div>5147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         " (" + Key.dumpString(key2, 0) +</div>
<div>5148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         ") and " +</div>
<div>5149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         i + " (" + Key.dumpString(key1, 0) +</div>
<div>5150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         ") are out of order");</div>
<div>5151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5153&emsp;&emsp;</div>
<div>5154&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            boolean inconsistent = false;</div>
<div>5155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (maxKey != null && key1 != null) {</div>
<div>5156&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (Key.compareKeys(key1, maxKey, userCompareToFcn) >= 0) {</div>
<div>5157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    inconsistent = true;</div>
<div>5158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5160&emsp;&emsp;</div>
<div>5161&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (inconsistent) {</div>
<div>5162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                throw EnvironmentFailureException.unexpectedState</div>
<div>5163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    ("IN " + getNodeId() +</div>
<div>5164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                     " has entry larger than next entry in parent.");</div>
<div>5165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5166&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } catch (DatabaseException DE) {</div>
<div>5167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            DE.printStackTrace(System.out);</div>
<div>5168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        *****************/</div>
<div>5170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5171&emsp;&emsp;</div>
<div>5172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Add self and children to this in-memory IN list. Called by recovery, can</div>
<div>5174&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * run with no latching.</div>
<div>5175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>5177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    final void rebuildINList(INList inList)</div>
<div>5178&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>5179&emsp;&emsp;</div>
<div>5180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>5181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Recompute your in memory size first and then add yourself to the</div>
<div>5182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * list.</div>
<div>5183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>5184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        initMemorySize();</div>
<div>5185&emsp;&emsp;</div>
<div>5186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        inList.add(this);</div>
<div>5187&emsp;&emsp;</div>
<div>5188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean hasCachedChildren = false;</div>
<div>5189&emsp;&emsp;</div>
<div>5190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>5191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Add your children if they're resident. (LNs know how to stop the</div>
<div>5192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * flow).</div>
<div>5193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div>5194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        for (int i = 0; i &#60; nEntries; i++) {</div>
<div>5195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Node n = getTarget(i);</div>
<div>5196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (n != null) {</div>
<div>5197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                n.rebuildINList(inList);</div>
<div>5198&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                hasCachedChildren = true;</div>
<div>5199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (getOffHeapBINId(i) >= 0) {</div>
<div>5201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                hasCachedChildren = true;</div>
<div>5202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5204&emsp;&emsp;</div>
<div>5205&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (isUpperIN()) {</div>
<div>5206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (hasCachedChildren) {</div>
<div>5207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setHasCachedChildrenFlag(true);</div>
<div>5208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>5209&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setHasCachedChildrenFlag(false);</div>
<div>5210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (!isDIN()) {</div>
<div>5211&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    if (traceLRU) {</div>
<div>5212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        LoggerUtils.envLogMsg(</div>
<div>5213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            traceLevel, getEnv(),</div>
<div>5214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            "rebuildINList " +</div>
<div>5215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            Thread.currentThread().getId() +</div>
<div>5216&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            "-" +</div>
<div>5217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            Thread.currentThread().getName() +</div>
<div>5218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            "-" + getEnv().getName() +</div>
<div>5219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            " Adding UIN to LRU: " +</div>
<div>5220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            getNodeId());</div>
<div>5221&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>5222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getEvictor().addBack(this);</div>
<div>5223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5225&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else if (isBIN() && !isDBIN()) {</div>
<div>5226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            getEvictor().addBack(this);</div>
<div>5227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5229&emsp;&emsp;</div>
<div>5230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>5231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * DbStat support.</div>
<div>5232&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void accumulateStats(TreeWalkerStatsAccumulator acc) {</div>
<div>5234&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        acc.processIN(this, getNodeId(), getLevel());</div>
<div>5235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5236&emsp;&emsp;</div>
<div>5237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the last logged LSN, which for a BIN may be a delta.</div>
<div>5239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * It is called from IN.postFetch/RecoveryInit(). If the logrec we have</div>
<div>5241&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * just read was a BINDelta, this.lastFullVersion has already been set (in</div>
<div>5242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BINDeltaLogEntry.readMainItem() or in OldBinDelta.reconstituteBIN()).</div>
<div>5243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * So, this method will set this.lastDeltaVersion. Otherwise, if the</div>
<div>5244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * logrec was a full BIN, this.lastFullVersion has not been set yet,</div>
<div>5245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * and it will be set here. In this case, this.lastDeltaVersion will</div>
<div>5246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * remain NULL.</div>
<div>5247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5248&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void setLastLoggedLsn(long lsn) {</div>
<div>5249&emsp;&emsp;</div>
<div style="background-color:limegreen;">5250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (getLastFullLsn() == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setLastFullLsn(lsn);</div>
<div>5253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>5254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                ((BIN)this).setLastDeltaLsn(lsn);</div>
<div>5255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>5257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLastFullLsn(lsn);</div>
<div>5258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5260&emsp;&emsp;</div>
<div>5261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5262&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the LSN of the last last logged version of this IN, or NULL_LSN</div>
<div>5263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * if never logged.</div>
<div>5264&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long getLastLoggedLsn() {</div>
<div style="background-color:limegreen;">5266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            return (getLastDeltaLsn() != DbLsn.NULL_LSN ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getLastDeltaLsn() :</div>
<div>5269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    getLastFullLsn());</div>
<div>5270&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5271&emsp;&emsp;</div>
<div>5272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getLastFullLsn();</div>
<div>5273&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5274&emsp;&emsp;</div>
<div>5275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5276&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Sets the last full version LSN.</div>
<div>5277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setLastFullLsn(long lsn) {</div>
<div>5279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lastFullVersion = lsn;</div>
<div>5280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5281&emsp;&emsp;</div>
<div>5282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5283&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the last full version LSN, or NULL_LSN if never logged.</div>
<div>5284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long getLastFullLsn() {</div>
<div>5286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return lastFullVersion;</div>
<div>5287&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5288&emsp;&emsp;</div>
<div>5289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns the last delta version LSN, or NULL_LSN if a delta was not last</div>
<div>5291&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * logged. For BINs, it just returns the value of the lastDeltaVersion</div>
<div>5292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * field. Public for unit testing.</div>
<div>5293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long getLastDeltaLsn() {</div>
<div>5295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return DbLsn.NULL_LSN;</div>
<div>5296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5297&emsp;&emsp;</div>
<div>5298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>5299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Logging support</div>
<div>5300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5301&emsp;&emsp;</div>
<div>5302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * When splits and checkpoints intermingle in a deferred write databases,</div>
<div>5304&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * a checkpoint target may appear which has a valid target but a null LSN.</div>
<div>5305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Deferred write dbs are written out in checkpoint style by either</div>
<div>5306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Database.sync() or a checkpoint which has cleaned a file containing</div>
<div>5307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * deferred write entries. For example,</div>
<div>5308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   INa</div>
<div>5309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *    |</div>
<div>5310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *   BINb</div>
<div>5311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  A checkpoint or Database.sync starts</div>
<div>5313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  The INList is traversed, dirty nodes are selected</div>
<div>5314&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  BINb is bypassed on the INList, since it's not dirty</div>
<div>5315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  BINb is split, creating a new sibling, BINc, and dirtying INa</div>
<div>5316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *  INa is selected as a dirty node for the ckpt</div>
<div>5317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If this happens, INa is in the selected dirty set, but not its dirty</div>
<div>5319&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * child BINb and new child BINc.</div>
<div>5320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * In a durable db, the existence of BINb and BINc are logged</div>
<div>5322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * anyway. But in a deferred write db, there is an entry that points to</div>
<div>5323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * BINc, but no logged version.</div>
<div>5324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * This will not cause problems with eviction, because INa can't be</div>
<div>5326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * evicted until BINb and BINc are logged, are non-dirty, and are detached.</div>
<div>5327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * But it can cause problems at recovery, because INa will have a null LSN</div>
<div>5328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * for a valid entry, and the LN children of BINc will not find a home.</div>
<div>5329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * To prevent this, search for all dirty children that might have been</div>
<div>5330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * missed during the selection phase, and write them out. It's not</div>
<div>5331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * sufficient to write only null-LSN children, because the existing sibling</div>
<div>5332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * must be logged lest LN children recover twice (once in the new sibling,</div>
<div>5333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * once in the old existing sibling.</div>
<div>5334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * TODO:</div>
<div>5336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Would the problem above be solved by logging dirty nodes using a tree</div>
<div>5337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * traversal (post-order), rather than using the dirty map?</div>
<div>5338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overriden by BIN class.</div>
<div>5340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void logDirtyChildren()</div>
<div>5342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>5343&emsp;&emsp;</div>
<div style="background-color:limegreen;">5344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!isBINDelta());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5345&emsp;&emsp;</div>
<div>5346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        EnvironmentImpl envImpl = getDatabase().getEnv();</div>
<div>5347&emsp;&emsp;</div>
<div>5348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Look for targets that are dirty. */</div>
<div style="background-color:limegreen;">5349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; getNEntries(); i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5350&emsp;&emsp;</div>
<div>5351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            IN child = (IN) getTarget(i);</div>
<div>5352&emsp;&emsp;</div>
<div style="background-color:limegreen;">5353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (child != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5354&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                child.latch(CacheMode.UNCHANGED);</div>
<div>5355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                try {</div>
<div style="background-color:limegreen;">5356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    if (child.getDirty()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        /* Ask descendants to log their children. */</div>
<div>5358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        child.logDirtyChildren();</div>
<div>5359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        long childLsn =</div>
<div>5360&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            child.log(false, // allowDeltas</div>
<div>5361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                      true,  // isProvisional</div>
<div>5362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                      true,  // backgroundIO</div>
<div>5363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                      this); // parent</div>
<div>5364&emsp;&emsp;</div>
<div>5365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        updateEntry(</div>
<div>5366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            i, childLsn, VLSN.NULL_VLSN_SEQUENCE,</div>
<div>5367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            0/*lastLoggedSize*/);</div>
<div>5368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    }</div>
<div>5369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } finally {</div>
<div>5370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    child.releaseLatch();</div>
<div>5371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5375&emsp;&emsp;</div>
<div>5376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long log() {</div>
<div>5377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return logInternal(</div>
<div>5378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            this, null, false /*allowDeltas*/, true /*allowCompress*/,</div>
<div>5379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Provisional.NO, false /*backgroundIO*/, null /*parent*/);</div>
<div>5380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5381&emsp;&emsp;</div>
<div>5382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long log(</div>
<div>5383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean allowDeltas,</div>
<div>5384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean isProvisional,</div>
<div>5385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean backgroundIO,</div>
<div>5386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN parent) {</div>
<div>5387&emsp;&emsp;</div>
<div style="background-color:limegreen;">5388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return logInternal(&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            this, null, allowDeltas, true /*allowCompress*/,</div>
<div>5390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            isProvisional ? Provisional.YES : Provisional.NO,</div>
<div>5391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            backgroundIO, parent);</div>
<div>5392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5393&emsp;&emsp;</div>
<div>5394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long log(</div>
<div>5395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean allowDeltas,</div>
<div>5396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Provisional provisional,</div>
<div>5397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean backgroundIO,</div>
<div>5398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN parent) {</div>
<div>5399&emsp;&emsp;</div>
<div>5400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return logInternal(</div>
<div>5401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            this, null, allowDeltas, true /*allowCompress*/, provisional, backgroundIO,</div>
<div>5402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            parent);</div>
<div>5403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5404&emsp;&emsp;</div>
<div>5405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final long optionalLog() {</div>
<div>5406&emsp;&emsp;</div>
<div style="background-color:limegreen;">5407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (databaseImpl.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return getLastLoggedLsn();</div>
<div>5409&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>5410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return logInternal(</div>
<div>5411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                this, null, false /*allowDeltas*/, true /*allowCompress*/,</div>
<div>5412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                Provisional.NO, false /*backgroundIO*/, null /*parent*/);</div>
<div>5413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5415&emsp;&emsp;</div>
<div>5416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public long optionalLogProvisional(IN parent) {</div>
<div>5417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return optionalLogProvisional(parent, true /*allowCompress*/);</div>
<div>5418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5419&emsp;&emsp;</div>
<div>5420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    long optionalLogProvisionalNoCompress(IN parent) {</div>
<div>5421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return optionalLogProvisional(parent, false /*allowCompress*/);</div>
<div>5422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5423&emsp;&emsp;</div>
<div>5424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private long optionalLogProvisional(IN parent, boolean allowCompress) {</div>
<div>5425&emsp;&emsp;</div>
<div style="background-color:limegreen;">5426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (databaseImpl.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return getLastLoggedLsn();</div>
<div>5428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>5429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return logInternal(</div>
<div>5430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                this, null, false /*allowDeltas*/, allowCompress,</div>
<div>5431&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                Provisional.YES, false /*backgroundIO*/, parent);</div>
<div>5432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5434&emsp;&emsp;</div>
<div>5435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public static long logEntry(</div>
<div>5436&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        INLogEntry&#60;BIN> logEntry,</div>
<div>5437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Provisional provisional,</div>
<div>5438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean backgroundIO,</div>
<div>5439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        IN parent) {</div>
<div>5440&emsp;&emsp;</div>
<div>5441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return logInternal(</div>
<div>5442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            null, logEntry, true /*allowDeltas*/, false /*allowCompress*/,</div>
<div>5443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            provisional, backgroundIO, parent);</div>
<div>5444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5445&emsp;&emsp;</div>
<div>5446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Bottleneck method for all IN logging.</div>
<div>5448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If 'node' is non-null, 'logEntry' must be null.</div>
<div>5450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * If 'node' is null, 'logEntry' and 'parent' must be non-null.</div>
<div>5451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * When 'logEntry' is non-null we are logging an off-heap BIN, and it is</div>
<div>5453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * not resident in the main cache. The lastFull/DeltaLsns are not updated</div>
<div>5454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * here, and this must be done instead by the caller.</div>
<div>5455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * When 'node' is non-null, 'parent' may or may not be null. It must be</div>
<div>5457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * non-null when logging provisionally, since obsolete LSNs are added to</div>
<div>5458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * the parent's collection.</div>
<div>5459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private static long logInternal(</div>
<div>5461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final IN node,</div>
<div>5462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        INLogEntry&#60;?> logEntry,</div>
<div>5463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean allowDeltas,</div>
<div>5464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean allowCompress,</div>
<div>5465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Provisional provisional,</div>
<div>5466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean backgroundIO,</div>
<div>5467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final IN parent) {</div>
<div>5468&emsp;&emsp;</div>
<div style="background-color:limegreen;">5469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert node == null || node.isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert parent == null || parent.isLatchExclusiveOwner();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert node != null || parent != null;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert (node == null) != (logEntry == null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5473&emsp;&emsp;</div>
<div style="background-color:limegreen;">5474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final DatabaseImpl dbImpl =&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            (node != null) ? node.getDatabase() : parent.getDatabase();</div>
<div>5476&emsp;&emsp;</div>
<div>5477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final EnvironmentImpl envImpl = dbImpl.getEnv();</div>
<div>5478&emsp;&emsp;</div>
<div style="background-color:limegreen;">5479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final boolean countObsoleteNow =&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            provisional != Provisional.YES || dbImpl.isTemporary();&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5481&emsp;&emsp;</div>
<div style="background-color:limegreen;">5482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final boolean isBin = (node != null) ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5483&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            node.isBIN() : (parent.getNormalizedLevel() == 2);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5484&emsp;&emsp;</div>
<div style="background-color:limegreen;">5485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final BIN bin = (node != null && isBin) ? ((BIN) node) : null;&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5486&emsp;&emsp;</div>
<div>5487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final boolean isDelta;</div>
<div>5488&emsp;&emsp;</div>
<div style="background-color:limegreen;">5489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBin) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (logEntry != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>5492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * When a logEntry is supplied (node/bin are null), the logic</div>
<div>5493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * below is implemented by OffHeapCache.createBINLogEntry.</div>
<div>5494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div>5495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                isDelta = logEntry.isBINDelta();</div>
<div>5496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>5497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* Compress non-dirty slots before determining delta status. */</div>
<div style="background-color:limegreen;">5498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (allowCompress) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl.lazyCompress(bin, false /*compressDirtySlots*/);</div>
<div>5500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5501&emsp;&emsp;</div>
<div style="background-color:limegreen;">5502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                isDelta = bin.isBINDelta() ||&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5503&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                    (allowDeltas && bin.shouldLogDelta());&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5504&emsp;&emsp;</div>
<div>5505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* Be sure that we didn't illegally mutate to a delta. */</div>
<div style="background-color:limegreen;">5506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                assert (!(isDelta && bin.isDeltaProhibited()));&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5507&emsp;&emsp;</div>
<div>5508&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* Also compress dirty slots, if we will not log a delta. */</div>
<div style="background-color:limegreen;">5509&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (allowCompress && !isDelta) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5510&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    envImpl.lazyCompress(bin, true /*compressDirtySlots*/);</div>
<div>5511&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5512&emsp;&emsp;</div>
<div>5513&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /*</div>
<div>5514&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * Write dirty LNs in deferred-write databases after</div>
<div>5515&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 * compression to reduce total logging, at least for temp DBs.</div>
<div>5516&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 */</div>
<div style="background-color:limegreen;">5517&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                if (dbImpl.isDeferredWriteMode()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5518&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    bin.logDirtyChildren();</div>
<div>5519&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>5520&emsp;&emsp;</div>
<div style="background-color:limegreen;">5521&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>                logEntry = isDelta ?&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5522&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    (new BINDeltaLogEntry(bin)) :</div>
<div>5523&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    (new INLogEntry&#60;>(bin));</div>
<div>5524&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5525&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">5526&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert node != null;&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5527&emsp;&emsp;</div>
<div>5528&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            isDelta = false;</div>
<div>5529&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            logEntry = new INLogEntry&#60;>(node);</div>
<div>5530&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5531&emsp;&emsp;</div>
<div>5532&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final LogParams params = new LogParams();</div>
<div>5533&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        params.entry = logEntry;</div>
<div>5534&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        params.provisional = provisional;</div>
<div>5535&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        params.repContext = ReplicationContext.NO_REPLICATE;</div>
<div>5536&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        params.nodeDb = dbImpl;</div>
<div>5537&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        params.backgroundIO = backgroundIO;</div>
<div>5538&emsp;&emsp;</div>
<div>5539&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>5540&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * For delta logging:</div>
<div>5541&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *  + Count lastDeltaVersion obsolete, if non-null.</div>
<div>5542&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *  + Set lastDeltaVersion to newly logged LSN.</div>
<div>5543&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *  + Leave lastFullVersion unchanged.</div>
<div>5544&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>5545&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * For full version logging:</div>
<div>5546&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *  + Count lastFullVersion and lastDeltaVersion obsolete, if non-null.</div>
<div>5547&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *  + Set lastFullVersion to newly logged LSN.</div>
<div>5548&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *  + Set lastDeltaVersion to null.</div>
<div>5549&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">5550&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final long oldLsn =&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5551&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            isDelta ? DbLsn.NULL_LSN : logEntry.getPrevFullLsn();</div>
<div>5552&emsp;&emsp;</div>
<div>5553&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final long auxOldLsn = logEntry.getPrevDeltaLsn();</div>
<div>5554&emsp;&emsp;</div>
<div>5555&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>5556&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * Determine whether to count the prior version of an IN (as well as</div>
<div>5557&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * accumulated provisionally obsolete LSNs for child nodes) obsolete</div>
<div>5558&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * when logging the new version.</div>
<div>5559&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>5560&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * True is set if we are logging the IN non-provisionally, since the</div>
<div>5561&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * non-provisional version durably replaces the prior version and</div>
<div>5562&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * causes all provisional children to also become durable.</div>
<div>5563&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         *</div>
<div>5564&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * True is also set if the database is temporary. Since we never use a</div>
<div>5565&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * temporary DB past recovery, prior versions of an IN are never used.</div>
<div>5566&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         * [#16928]</div>
<div>5567&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         */</div>
<div style="background-color:limegreen;">5568&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (countObsoleteNow) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5569&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            params.oldLsn = oldLsn;</div>
<div>5570&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            params.auxOldLsn = auxOldLsn;</div>
<div style="background-color:limegreen;">5571&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            params.packedObsoleteInfo =&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5572&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (node != null) ? node.provisionalObsolete : null;</div>
<div>5573&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5574&emsp;&emsp;</div>
<div>5575&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Log it. */</div>
<div>5576&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final LogItem item = envImpl.getLogManager().log(params);</div>
<div>5577&emsp;&emsp;</div>
<div style="background-color:limegreen;">5578&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (node != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5579&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            node.setDirty(false);</div>
<div>5580&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5581&emsp;&emsp;</div>
<div style="background-color:limegreen;">5582&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (countObsoleteNow) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5583&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (node != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5584&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                node.discardProvisionalObsolete();</div>
<div>5585&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">5586&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (parent != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5587&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            parent.trackProvisionalObsolete(node, oldLsn);</div>
<div>5588&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            parent.trackProvisionalObsolete(node, auxOldLsn);</div>
<div>5589&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>5590&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * TODO:</div>
<div>5591&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The parent is null and provisional is YES when evicting the root</div>
<div>5592&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * of a DW DB. How does obsolete counting happen?</div>
<div>5593&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>5594&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5595&emsp;&emsp;</div>
<div style="background-color:limegreen;">5596&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5597&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>5598&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * When a logEntry is supplied (node/bin are null), the logic</div>
<div>5599&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * below is implemented by OffHeapCache.postBINLog.</div>
<div>5600&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">5601&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isDelta) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5602&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setLastDeltaLsn(item.lsn);</div>
<div>5603&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>5604&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setLastFullLsn(item.lsn);</div>
<div>5605&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setLastDeltaLsn(DbLsn.NULL_LSN);</div>
<div>5606&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5607&emsp;&emsp;</div>
<div>5608&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.setProhibitNextDelta(false);</div>
<div>5609&emsp;&emsp;</div>
<div style="background-color:limegreen;">5610&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        } else if (node != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5611&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            node.setLastFullLsn(item.lsn);</div>
<div>5612&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5613&emsp;&emsp;</div>
<div>5614&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final Evictor evictor = envImpl.getEvictor();</div>
<div>5615&emsp;&emsp;</div>
<div style="background-color:limegreen;">5616&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (node != null && evictor.getUseDirtyLRUSet()) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5617&emsp;&emsp;</div>
<div>5618&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>5619&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * To capture all cases where a node needs to be moved to the</div>
<div>5620&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * priority-1 LRUSet after being cleaned, we invoke moveToPri1LRU()</div>
<div>5621&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * from IN.afterLog(). This includes the case where the node is</div>
<div>5622&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * being logged as part of being evicted, in which case we don't</div>
<div>5623&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * really want it to go back to the LRU. However, this is ok</div>
<div>5624&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * because moveToPri1LRU() checks whether the node is actually</div>
<div>5625&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * in the priority-2 LRUSet before moving it to the priority-1</div>
<div>5626&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * LRUSet.</div>
<div>5627&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>5628&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (traceLRU && node.isUpperIN()) {</div>
<div>5629&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LoggerUtils.envLogMsg(</div>
<div>5630&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    traceLevel, envImpl,</div>
<div>5631&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    Thread.currentThread().getId() + "-" +</div>
<div>5632&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        Thread.currentThread().getName() +</div>
<div>5633&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        "-" + envImpl.getName() +</div>
<div>5634&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        " afterLogCommon(): " +</div>
<div>5635&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        " Moving UIN to mixed LRU: " + node.getNodeId());</div>
<div>5636&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5637&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            evictor.moveToPri1LRU(node);</div>
<div>5638&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5639&emsp;&emsp;</div>
<div>5640&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return item.lsn;</div>
<div>5641&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5642&emsp;&emsp;</div>
<div>5643&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5644&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Adds the given obsolete LSN and any tracked obsolete LSNs for the given</div>
<div>5645&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * child IN to this IN's tracking list.  This method is called to track</div>
<div>5646&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * obsolete LSNs when a child IN is logged provisionally.  Such LSNs</div>
<div>5647&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * cannot be considered obsolete until an ancestor IN is logged</div>
<div>5648&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * non-provisionally.</div>
<div>5649&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5650&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    void trackProvisionalObsolete(final IN childIN, final long obsoleteLsn) {</div>
<div>5651&emsp;&emsp;</div>
<div style="background-color:limegreen;">5652&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final boolean moveChildInfo =&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5653&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            (childIN != null && childIN.provisionalObsolete != null);</div>
<div>5654&emsp;&emsp;</div>
<div style="background-color:limegreen;">5655&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final boolean addChildLsn = (obsoleteLsn != DbLsn.NULL_LSN);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5656&emsp;&emsp;</div>
<div style="background-color:limegreen;">5657&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!moveChildInfo && !addChildLsn) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5658&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return;</div>
<div>5659&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5660&emsp;&emsp;</div>
<div style="background-color:limegreen;">5661&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final int oldMemSize = (provisionalObsolete != null) ?&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5662&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             provisionalObsolete.getMemorySize() : 0;</div>
<div>5663&emsp;&emsp;</div>
<div style="background-color:limegreen;">5664&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (moveChildInfo) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5665&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (provisionalObsolete != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5666&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* Append child info to parent info. */</div>
<div>5667&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                provisionalObsolete.copyObsoleteInfo</div>
<div>5668&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    (childIN.provisionalObsolete);</div>
<div>5669&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>5670&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* Move reference from child to parent. */</div>
<div>5671&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                provisionalObsolete = childIN.provisionalObsolete;</div>
<div>5672&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5673&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            childIN.updateMemorySize(</div>
<div>5674&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                0 - childIN.provisionalObsolete.getMemorySize());</div>
<div>5675&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            childIN.provisionalObsolete = null;</div>
<div>5676&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5677&emsp;&emsp;</div>
<div style="background-color:limegreen;">5678&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (addChildLsn) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5679&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (provisionalObsolete == null) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>5680&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                provisionalObsolete = new PackedObsoleteInfo();</div>
<div>5681&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5682&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            provisionalObsolete.addObsoleteInfo(obsoleteLsn);</div>
<div>5683&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5684&emsp;&emsp;</div>
<div style="background-color:limegreen;">5685&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        updateMemorySize(oldMemSize,&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>5686&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         (provisionalObsolete != null) ?</div>
<div>5687&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         provisionalObsolete.getMemorySize() :</div>
<div>5688&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         0);</div>
<div>5689&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5690&emsp;&emsp;</div>
<div>5691&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5692&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Discards the provisional obsolete tracking information in this node</div>
<div>5693&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * after it has been counted in the live tracker.  This method is called</div>
<div>5694&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * after this node is logged non-provisionally.</div>
<div>5695&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5696&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void discardProvisionalObsolete()</div>
<div>5697&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        throws DatabaseException {</div>
<div>5698&emsp;&emsp;</div>
<div style="background-color:limegreen;">5699&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (provisionalObsolete != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5700&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            updateMemorySize(0 - provisionalObsolete.getMemorySize());</div>
<div>5701&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            provisionalObsolete = null;</div>
<div>5702&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5703&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5704&emsp;&emsp;</div>
<div>5705&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>5706&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * NOOP for upper INs. Overriden by BIN class.</div>
<div>5707&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5708&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void mutateToFullBIN(boolean leaveFreeSlot) {</div>
<div>5709&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5710&emsp;&emsp;</div>
<div>5711&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int getNEntriesToWrite(boolean deltasOnly) {</div>
<div style="background-color:limegreen;">5712&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!deltasOnly) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5713&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return nEntries;</div>
<div>5714&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5715&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getNDeltas();</div>
<div>5716&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5717&emsp;&emsp;</div>
<div>5718&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getNDeltas() {</div>
<div>5719&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int n = 0;</div>
<div style="background-color:limegreen;">5720&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">5721&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!isDirty(i)) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5722&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>5723&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5724&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            n += 1;</div>
<div>5725&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5726&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return n;</div>
<div>5727&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5728&emsp;&emsp;</div>
<div>5729&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5730&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see Node#getGenericLogType</div>
<div>5731&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5732&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>5733&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final LogEntryType getGenericLogType() {</div>
<div>5734&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getLogType();</div>
<div>5735&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5736&emsp;&emsp;</div>
<div>5737&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5738&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Get the log type of this node.</div>
<div>5739&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5740&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public LogEntryType getLogType() {</div>
<div>5741&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return LogEntryType.LOG_IN;</div>
<div>5742&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5743&emsp;&emsp;</div>
<div>5744&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5745&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see Loggable#getLogSize</div>
<div>5746&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *</div>
<div>5747&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overrriden by DIN and DBIN classes.</div>
<div>5748&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5749&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>5750&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public int getLogSize() {</div>
<div>5751&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return getLogSize(false);</div>
<div>5752&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5753&emsp;&emsp;</div>
<div>5754&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final int getLogSize(boolean deltasOnly) {</div>
<div>5755&emsp;&emsp;</div>
<div style="background-color:limegreen;">5756&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        BIN bin = (isBIN() ? (BIN)this : null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5757&emsp;&emsp;</div>
<div style="background-color:limegreen;">5758&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean haveVLSNCache = (bin != null && bin.isVLSNCachingEnabled());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5759&emsp;&emsp;</div>
<div>5760&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int size = 0;</div>
<div>5761&emsp;&emsp;</div>
<div>5762&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean haveExpiration = false;</div>
<div>5763&emsp;&emsp;</div>
<div style="background-color:limegreen;">5764&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5765&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int base = bin.getExpirationBase();</div>
<div style="background-color:limegreen;">5766&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            haveExpiration = (base != -1);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5767&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += LogUtils.getPackedIntLogSize(base);</div>
<div>5768&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5769&emsp;&emsp;</div>
<div>5770&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += LogUtils.getPackedLongLogSize(nodeId);</div>
<div>5771&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += LogUtils.getByteArrayLogSize(identifierKey); // identifier key</div>
<div>5772&emsp;&emsp;</div>
<div style="background-color:limegreen;">5773&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (keyPrefix != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5774&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += LogUtils.getByteArrayLogSize(keyPrefix);</div>
<div>5775&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5776&emsp;&emsp;</div>
<div>5777&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += 1; // one byte for boolean flags</div>
<div>5778&emsp;&emsp;</div>
<div>5779&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int nEntriesToWrite = getNEntriesToWrite(deltasOnly);</div>
<div>5780&emsp;&emsp;</div>
<div style="background-color:limegreen;">5781&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final int maxEntriesToWrite =&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5782&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            (!deltasOnly ?</div>
<div>5783&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             getMaxEntries() :</div>
<div>5784&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             bin.getDeltaCapacity(nEntriesToWrite));</div>
<div>5785&emsp;&emsp;</div>
<div>5786&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += LogUtils.getPackedIntLogSize(nEntriesToWrite);</div>
<div>5787&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += LogUtils.getPackedIntLogSize(level);</div>
<div>5788&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += LogUtils.getPackedIntLogSize(maxEntriesToWrite);</div>
<div>5789&emsp;&emsp;</div>
<div style="background-color:limegreen;">5790&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final boolean compactLsnsRep = (entryLsnLongArray == null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5791&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        size += LogUtils.getBooleanLogSize();   // compactLsnsRep</div>
<div style="background-color:limegreen;">5792&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (compactLsnsRep) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5793&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += LogUtils.INT_BYTES;         // baseFileNumber</div>
<div>5794&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5795&emsp;&emsp;</div>
<div style="background-color:limegreen;">5796&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {    // entries&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5797&emsp;&emsp;</div>
<div style="background-color:limegreen;">5798&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (deltasOnly && !isDirty(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5799&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>5800&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5801&emsp;&emsp;</div>
<div style="background-color:limegreen;">5802&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            size += LogUtils.getByteArrayLogSize(entryKeys.get(i)) + // key&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5803&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (compactLsnsRep ? LogUtils.INT_BYTES :</div>
<div>5804&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 LogUtils.getLongLogSize()) +                       // LSN</div>
<div>5805&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                1;                                                  // state</div>
<div>5806&emsp;&emsp;</div>
<div style="background-color:limegreen;">5807&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (isLastLoggedSizeStored(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5808&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                size += LogUtils.getPackedIntLogSize(getLastLoggedSize(i));</div>
<div>5809&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5810&emsp;&emsp;</div>
<div style="background-color:limegreen;">5811&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (haveVLSNCache && isEmbeddedLN(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5812&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                size += LogUtils.getPackedLongLogSize(bin.getCachedVLSN(i));</div>
<div>5813&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5814&emsp;&emsp;</div>
<div style="background-color:limegreen;">5815&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (haveExpiration) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5816&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                size +=</div>
<div>5817&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    LogUtils.getPackedIntLogSize(bin.getExpirationOffset(i));</div>
<div>5818&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5819&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5820&emsp;&emsp;</div>
<div style="background-color:limegreen;">5821&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (deltasOnly) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5822&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += LogUtils.getPackedIntLogSize(bin.getFullBinNEntries());</div>
<div>5823&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += LogUtils.getPackedIntLogSize(bin.getFullBinMaxEntries());</div>
<div>5824&emsp;&emsp;</div>
<div>5825&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            size += bin.getBloomFilterLogSize();</div>
<div>5826&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5827&emsp;&emsp;</div>
<div>5828&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return size;</div>
<div>5829&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5830&emsp;&emsp;</div>
<div>5831&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>5832&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Overridden by DIN and DBIN classes.</div>
<div>5833&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5834&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>5835&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void writeToLog(ByteBuffer logBuffer) {</div>
<div>5836&emsp;&emsp;</div>
<div>5837&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        serialize(logBuffer, false /*deltasOnly*/, true /*clearDirtyBits*/);</div>
<div>5838&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5839&emsp;&emsp;</div>
<div>5840&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void writeToLog(ByteBuffer logBuffer, boolean deltasOnly) {</div>
<div>5841&emsp;&emsp;</div>
<div style="background-color:limegreen;">5842&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        serialize(logBuffer, deltasOnly, !deltasOnly /*clearDirtyBits*/);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5843&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5844&emsp;&emsp;</div>
<div>5845&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5846&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * WARNING: In the case of BINs this method is not only used for logging</div>
<div>5847&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * but also for off-heap caching. Therefore, this method should not have</div>
<div>5848&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * side effects unless the clearDirtyBits param is true.</div>
<div>5849&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5850&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void serialize(ByteBuffer logBuffer,</div>
<div>5851&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                boolean deltasOnly,</div>
<div>5852&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                boolean clearDirtyBits) {</div>
<div>5853&emsp;&emsp;</div>
<div style="background-color:limegreen;">5854&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!deltasOnly || isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5855&emsp;&emsp;</div>
<div style="background-color:limegreen;">5856&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        BIN bin = (isBIN() ? (BIN)this : null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5857&emsp;&emsp;</div>
<div style="background-color:limegreen;">5858&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        byte[] bloomFilter = (deltasOnly ? bin.createBloomFilter() : null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5859&emsp;&emsp;</div>
<div>5860&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean haveExpiration = false;</div>
<div>5861&emsp;&emsp;</div>
<div style="background-color:limegreen;">5862&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5863&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int base = bin.getExpirationBase();</div>
<div style="background-color:limegreen;">5864&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            haveExpiration = (base != -1);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5865&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.writePackedInt(logBuffer, base);</div>
<div>5866&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5867&emsp;&emsp;</div>
<div>5868&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writePackedLong(logBuffer, nodeId);</div>
<div>5869&emsp;&emsp;</div>
<div>5870&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writeByteArray(logBuffer, identifierKey);</div>
<div>5871&emsp;&emsp;</div>
<div style="background-color:limegreen;">5872&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean hasKeyPrefix = (keyPrefix != null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>5873&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean mayHaveLastLoggedSize = mayHaveLastLoggedSizeStored();</div>
<div style="background-color:limegreen;">5874&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean haveVLSNCache = (bin != null && bin.isVLSNCachingEnabled());&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5875&emsp;&emsp;</div>
<div style="background-color:limegreen;">5876&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        byte booleans = (byte) (isRoot() ? 1 : 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5877&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        booleans |= (hasKeyPrefix ? 2 : 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5878&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        booleans |= (mayHaveLastLoggedSize ? 4 : 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5879&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        booleans |= (bloomFilter != null ? 8 : 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5880&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        booleans |= (haveVLSNCache ? 16 : 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5881&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        booleans |= (isExpirationInHours() ? 32 : 0);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5882&emsp;&emsp;</div>
<div>5883&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        logBuffer.put(booleans);</div>
<div>5884&emsp;&emsp;</div>
<div style="background-color:limegreen;">5885&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (hasKeyPrefix) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5886&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.writeByteArray(logBuffer, keyPrefix);</div>
<div>5887&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5888&emsp;&emsp;</div>
<div>5889&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final int nEntriesToWrite = getNEntriesToWrite(deltasOnly);</div>
<div>5890&emsp;&emsp;</div>
<div style="background-color:limegreen;">5891&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        final int maxEntriesToWrite =&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5892&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            (!deltasOnly ?</div>
<div>5893&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             getMaxEntries() :</div>
<div>5894&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             bin.getDeltaCapacity(nEntriesToWrite));</div>
<div>5895&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /*</div>
<div>5896&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (deltasOnly) {</div>
<div>5897&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            BIN bin = (BIN)this;</div>
<div>5898&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            System.out.println(</div>
<div>5899&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "Logging BIN-delta: " + getNodeId() +</div>
<div>5900&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " is delta = " + isBINDelta() +</div>
<div>5901&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " nEntries = " + nEntriesToWrite +</div>
<div>5902&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " max entries = " + maxEntriesToWrite +</div>
<div>5903&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " full BIN entries = " + bin.getFullBinNEntries() +</div>
<div>5904&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " full BIN max entries = " + bin.getFullBinMaxEntries());</div>
<div>5905&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5906&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        */</div>
<div>5907&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writePackedInt(logBuffer, nEntriesToWrite);</div>
<div>5908&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writePackedInt(logBuffer, level);</div>
<div>5909&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writePackedInt(logBuffer, maxEntriesToWrite);</div>
<div>5910&emsp;&emsp;</div>
<div>5911&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* true if compact representation. */</div>
<div style="background-color:limegreen;">5912&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean compactLsnsRep = (entryLsnLongArray == null);&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5913&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        LogUtils.writeBoolean(logBuffer, compactLsnsRep);</div>
<div style="background-color:limegreen;">5914&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (compactLsnsRep) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5915&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.writeInt(logBuffer, (int) baseFileNumber);</div>
<div>5916&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5917&emsp;&emsp;</div>
<div style="background-color:limegreen;">5918&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5919&emsp;&emsp;</div>
<div style="background-color:limegreen;">5920&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (deltasOnly && !isDirty(i)) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5921&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                continue;</div>
<div>5922&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5923&emsp;&emsp;</div>
<div>5924&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.writeByteArray(logBuffer, entryKeys.get(i));</div>
<div>5925&emsp;&emsp;</div>
<div>5926&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>5927&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * A NULL_LSN may be stored when an incomplete insertion occurs,</div>
<div>5928&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * but in that case the KnownDeleted flag must be set. See</div>
<div>5929&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * Tree.insert.  [#13126]</div>
<div>5930&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div style="background-color:limegreen;">5931&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            assert checkForNullLSN(i) :&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>5932&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "logging IN " + getNodeId() + " with null lsn child " +</div>
<div>5933&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " db=" + databaseImpl.getDebugName() +</div>
<div>5934&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " isDeferredWriteMode=" + databaseImpl.isDeferredWriteMode() +</div>
<div>5935&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                " isTemporary=" + databaseImpl.isTemporary();</div>
<div>5936&emsp;&emsp;</div>
<div style="background-color:limegreen;">5937&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (compactLsnsRep) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5938&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int offset = i &#60;&#60; 2;</div>
<div>5939&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int fileOffset = getFileOffset(offset);</div>
<div>5940&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logBuffer.put(getFileNumberOffset(offset));</div>
<div>5941&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logBuffer.put((byte) (fileOffset & 0xff));</div>
<div>5942&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logBuffer.put((byte) ((fileOffset >>> 8) & 0xff));</div>
<div>5943&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                logBuffer.put((byte) ((fileOffset >>> 16) & 0xff));</div>
<div>5944&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>5945&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LogUtils.writeLong(logBuffer, entryLsnLongArray[i]);</div>
<div>5946&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5947&emsp;&emsp;</div>
<div>5948&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            logBuffer.put(</div>
<div>5949&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                (byte) (entryStates[i] & EntryStates.CLEAR_TRANSIENT_BITS));</div>
<div>5950&emsp;&emsp;</div>
<div style="background-color:limegreen;">5951&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (clearDirtyBits) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>5952&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryStates[i] &= EntryStates.CLEAR_DIRTY_BIT;</div>
<div>5953&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5954&emsp;&emsp;</div>
<div>5955&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (isLastLoggedSizeStored(i)) {</div>
<div>5956&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LogUtils.writePackedInt(logBuffer, getLastLoggedSize(i));</div>
<div>5957&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5958&emsp;&emsp;</div>
<div>5959&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (haveVLSNCache && isEmbeddedLN(i)) {</div>
<div>5960&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LogUtils.writePackedLong(logBuffer, bin.getCachedVLSN(i));</div>
<div>5961&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5962&emsp;&emsp;</div>
<div>5963&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (haveExpiration) {</div>
<div>5964&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                LogUtils.writePackedInt(</div>
<div>5965&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    logBuffer, bin.getExpirationOffset(i));</div>
<div>5966&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5967&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5968&emsp;&emsp;</div>
<div style="background-color:limegreen;">5969&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (deltasOnly) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5970&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.writePackedInt(logBuffer, bin.getFullBinNEntries());</div>
<div>5971&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LogUtils.writePackedInt(logBuffer, bin.getFullBinMaxEntries());</div>
<div>5972&emsp;&emsp;</div>
<div style="background-color:limegreen;">5973&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (bloomFilter != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>5974&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                BINDeltaBloomFilter.writeToLog(bloomFilter, logBuffer);</div>
<div>5975&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>5976&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5977&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5978&emsp;&emsp;</div>
<div>5979&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /*</div>
<div>5980&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Used for assertion to prevent writing a null lsn to the log.</div>
<div>5981&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5982&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private boolean checkForNullLSN(int index) {</div>
<div>5983&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean ok;</div>
<div style="background-color:limegreen;">5984&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div style="background-color:limegreen;">5985&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            ok = !(getLsn(index) == DbLsn.NULL_LSN &&&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>5986&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   (entryStates[index] & EntryStates.KNOWN_DELETED_BIT) == 0);</div>
<div>5987&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div style="background-color:limegreen;">5988&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            ok = (getLsn(index) != DbLsn.NULL_LSN);&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>5989&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>5990&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return ok;</div>
<div>5991&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>5992&emsp;&emsp;</div>
<div>5993&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>5994&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Returns whether the given serialized IN is a BIN that may have</div>
<div>5995&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * expiration values.</div>
<div>5996&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>5997&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public boolean mayHaveExpirationValues(</div>
<div>5998&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ByteBuffer itemBuffer,</div>
<div>5999&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int entryVersion) {</div>
<div>6000&emsp;&emsp;</div>
<div style="background-color:limegreen;">6001&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (!isBIN() || entryVersion &#60; 12) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6002&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            return false;</div>
<div>6003&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6004&emsp;&emsp;</div>
<div>6005&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        itemBuffer.mark();</div>
<div>6006&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int expirationBase = LogUtils.readPackedInt(itemBuffer);</div>
<div>6007&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        itemBuffer.reset();</div>
<div>6008&emsp;&emsp;</div>
<div style="background-color:limegreen;">6009&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        return (expirationBase != -1);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6010&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6011&emsp;&emsp;</div>
<div>6012&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>6013&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void readFromLog(</div>
<div>6014&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ByteBuffer itemBuffer,</div>
<div>6015&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int entryVersion) {</div>
<div>6016&emsp;&emsp;</div>
<div>6017&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        materialize(</div>
<div>6018&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            itemBuffer, entryVersion,</div>
<div>6019&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            false /*deltasOnly*/, true /*clearDirtyBits*/);</div>
<div>6020&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6021&emsp;&emsp;</div>
<div>6022&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public void readFromLog(</div>
<div>6023&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ByteBuffer itemBuffer,</div>
<div>6024&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int entryVersion,</div>
<div>6025&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean deltasOnly) {</div>
<div>6026&emsp;&emsp;</div>
<div style="background-color:limegreen;">6027&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        materialize(&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6028&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            itemBuffer, entryVersion,</div>
<div>6029&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            deltasOnly, !deltasOnly /*clearDirtyBits*/);</div>
<div>6030&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6031&emsp;&emsp;</div>
<div>6032&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6033&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * WARNING: In the case of BINs this method is used not only for logging</div>
<div>6034&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * but also for off-heap caching. Therefore, this method should not have</div>
<div>6035&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * side effects unless the clearDirtyBits param is true or an older log</div>
<div>6036&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * version is passed (off-heap caching uses the current version).</div>
<div>6037&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6038&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void materialize(</div>
<div>6039&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ByteBuffer itemBuffer,</div>
<div>6040&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int entryVersion,</div>
<div>6041&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean deltasOnly,</div>
<div>6042&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean clearDirtyBits) {</div>
<div>6043&emsp;&emsp;</div>
<div style="background-color:limegreen;">6044&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!deltasOnly || isBIN());&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6045&emsp;&emsp;</div>
<div style="background-color:limegreen;">6046&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        BIN bin = (isBIN() ? (BIN)this : null);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6047&emsp;&emsp;</div>
<div style="background-color:limegreen;">6048&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean unpacked = (entryVersion &#60; 6);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6049&emsp;&emsp;</div>
<div>6050&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean haveExpiration = false;</div>
<div>6051&emsp;&emsp;</div>
<div style="background-color:limegreen;">6052&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null && entryVersion >= 12) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6053&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int base = LogUtils.readPackedInt(itemBuffer);</div>
<div style="background-color:limegreen;">6054&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            haveExpiration = (base != -1);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6055&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin.setExpirationBase(base);</div>
<div>6056&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6057&emsp;&emsp;</div>
<div>6058&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nodeId = LogUtils.readLong(itemBuffer, unpacked);</div>
<div>6059&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        identifierKey = LogUtils.readByteArray(itemBuffer, unpacked);</div>
<div>6060&emsp;&emsp;</div>
<div>6061&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        byte booleans = itemBuffer.get();</div>
<div>6062&emsp;&emsp;</div>
<div style="background-color:limegreen;">6063&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        setIsRootFlag((booleans & 1) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6064&emsp;&emsp;</div>
<div style="background-color:limegreen;">6065&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if ((booleans & 2) != 0) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6066&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            keyPrefix = LogUtils.readByteArray(itemBuffer, unpacked);</div>
<div>6067&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6068&emsp;&emsp;</div>
<div style="background-color:limegreen;">6069&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean mayHaveLastLoggedSize = ((booleans & 4) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">6070&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !(mayHaveLastLoggedSize && (entryVersion &#60; 9));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6071&emsp;&emsp;</div>
<div style="background-color:limegreen;">6072&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean hasBloomFilter = ((booleans & 8) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">6073&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert(!hasBloomFilter || (entryVersion >= 10 && deltasOnly));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6074&emsp;&emsp;</div>
<div style="background-color:limegreen;">6075&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        boolean haveVLSNCache = ((booleans & 16) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div style="background-color:limegreen;">6076&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        assert !(haveVLSNCache && (entryVersion &#60; 11));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY] & [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6077&emsp;&emsp;</div>
<div style="background-color:limegreen;">6078&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        setExpirationInHours((booleans & 32) != 0);&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6079&emsp;&emsp;</div>
<div>6080&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        nEntries = LogUtils.readInt(itemBuffer, unpacked);</div>
<div>6081&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        level = LogUtils.readInt(itemBuffer, unpacked);</div>
<div>6082&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int length = LogUtils.readInt(itemBuffer, unpacked);</div>
<div>6083&emsp;&emsp;</div>
<div>6084&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryTargets = INTargetRep.NONE;</div>
<div>6085&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryKeys = new INKeyRep.Default(length);</div>
<div>6086&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        baseFileNumber = -1;</div>
<div>6087&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        long storedBaseFileNumber = -1;</div>
<div style="background-color:limegreen;">6088&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (disableCompactLsns) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6089&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = null;</div>
<div>6090&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = new long[length];</div>
<div>6091&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>6092&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnByteArray = new byte[length &#60;&#60; 2];</div>
<div>6093&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryLsnLongArray = null;</div>
<div>6094&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6095&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        entryStates = new byte[length];</div>
<div>6096&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean compactLsnsRep = false;</div>
<div>6097&emsp;&emsp;</div>
<div style="background-color:limegreen;">6098&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (entryVersion > 1) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6099&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            compactLsnsRep = LogUtils.readBoolean(itemBuffer);</div>
<div style="background-color:limegreen;">6100&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (compactLsnsRep) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>6101&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                baseFileNumber = LogUtils.readInt(itemBuffer);</div>
<div>6102&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                storedBaseFileNumber = baseFileNumber;</div>
<div>6103&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6104&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6105&emsp;&emsp;</div>
<div style="background-color:limegreen;">6106&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>6107&emsp;&emsp;</div>
<div>6108&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryKeys = entryKeys.set(</div>
<div>6109&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                i, LogUtils.readByteArray(itemBuffer, unpacked), this);</div>
<div>6110&emsp;&emsp;</div>
<div>6111&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long lsn;</div>
<div>6112&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (compactLsnsRep) {</div>
<div>6113&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* LSNs in compact form. */</div>
<div>6114&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                byte fileNumberOffset = itemBuffer.get();</div>
<div>6115&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int fileOffset = (itemBuffer.get() & 0xff);</div>
<div>6116&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                fileOffset |= ((itemBuffer.get() & 0xff) &#60;&#60; 8);</div>
<div>6117&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                fileOffset |= ((itemBuffer.get() & 0xff) &#60;&#60; 16);</div>
<div>6118&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (fileOffset == THREE_BYTE_NEGATIVE_ONE) {</div>
<div>6119&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    lsn = DbLsn.NULL_LSN;</div>
<div>6120&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                } else {</div>
<div>6121&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    lsn = DbLsn.makeLsn</div>
<div>6122&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        (storedBaseFileNumber + fileNumberOffset, fileOffset);</div>
<div>6123&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>6124&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>6125&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                /* LSNs in long form. */</div>
<div>6126&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                lsn = LogUtils.readLong(itemBuffer);              // LSN</div>
<div>6127&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6128&emsp;&emsp;</div>
<div>6129&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setLsnInternal(i, lsn);</div>
<div>6130&emsp;&emsp;</div>
<div>6131&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            byte entryState = itemBuffer.get();                   // state</div>
<div>6132&emsp;&emsp;</div>
<div>6133&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (clearDirtyBits) {</div>
<div>6134&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryState &= EntryStates.CLEAR_DIRTY_BIT;</div>
<div>6135&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6136&emsp;&emsp;</div>
<div>6137&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>6138&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * The MIGRATE_BIT (now the transient OFFHEAP_DIRTY_BIT) was</div>
<div>6139&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * accidentally written in a pre-JE 6 log version.</div>
<div>6140&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>6141&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (entryVersion &#60; 9) {</div>
<div>6142&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryState &= EntryStates.CLEAR_TRANSIENT_BITS;</div>
<div>6143&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6144&emsp;&emsp;</div>
<div>6145&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            /*</div>
<div>6146&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * A NULL_LSN is the remnant of an incomplete insertion and the</div>
<div>6147&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * KnownDeleted flag should be set.  But because of bugs in prior</div>
<div>6148&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * releases, the KnownDeleted flag may not be set.  So set it here.</div>
<div>6149&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             * See Tree.insert.  [#13126]</div>
<div>6150&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             */</div>
<div>6151&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (entryVersion &#60; 9 && lsn == DbLsn.NULL_LSN) {</div>
<div>6152&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                entryState |= EntryStates.KNOWN_DELETED_BIT;</div>
<div>6153&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6154&emsp;&emsp;</div>
<div>6155&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            entryStates[i] = entryState;</div>
<div>6156&emsp;&emsp;</div>
<div>6157&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (mayHaveLastLoggedSize && !isEmbeddedLN(i)) {</div>
<div>6158&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                setLastLoggedSizeUnconditional(</div>
<div>6159&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    i, LogUtils.readPackedInt(itemBuffer));</div>
<div>6160&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6161&emsp;&emsp;</div>
<div>6162&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (haveVLSNCache && isEmbeddedLN(i)) {</div>
<div>6163&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setCachedVLSNUnconditional(</div>
<div>6164&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    i, LogUtils.readPackedLong(itemBuffer));</div>
<div>6165&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6166&emsp;&emsp;</div>
<div>6167&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (haveExpiration) {</div>
<div>6168&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setExpirationOffset(i, LogUtils.readPackedInt(itemBuffer));</div>
<div>6169&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6170&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6171&emsp;&emsp;</div>
<div style="background-color:limegreen;">6172&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (deltasOnly) {&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>6173&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            setBINDelta(true);</div>
<div>6174&emsp;&emsp;</div>
<div>6175&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (entryVersion >= 10) {</div>
<div>6176&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setFullBinNEntries(LogUtils.readPackedInt(itemBuffer));</div>
<div>6177&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.setFullBinMaxEntries(LogUtils.readPackedInt(itemBuffer));</div>
<div>6178&emsp;&emsp;</div>
<div>6179&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (hasBloomFilter) {</div>
<div>6180&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    bin.bloomFilter = BINDeltaBloomFilter.readFromLog(</div>
<div>6181&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        itemBuffer, entryVersion);</div>
<div>6182&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>6183&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6184&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6185&emsp;&emsp;</div>
<div>6186&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Dup conversion will be done by postFetchInit. */</div>
<div style="background-color:limegreen;">6187&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        needDupKeyConversion = (entryVersion &#60; 8);&nbsp;&#8594; [ALLOWCREATE]</b></div>
<div>6188&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6189&emsp;&emsp;</div>
<div>6190&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6191&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see Loggable#logicalEquals</div>
<div>6192&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Always return false, this item should never be compared.</div>
<div>6193&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6194&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>6195&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final boolean logicalEquals(Loggable other) {</div>
<div>6196&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return false;</div>
<div>6197&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6198&emsp;&emsp;</div>
<div>6199&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6200&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @see Loggable#dumpLog</div>
<div>6201&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6202&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>6203&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void dumpLog(StringBuilder sb, boolean verbose) {</div>
<div>6204&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(beginTag());</div>
<div>6205&emsp;&emsp;</div>
<div>6206&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;nodeId val=\"");</div>
<div>6207&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(nodeId);</div>
<div>6208&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\"/>");</div>
<div>6209&emsp;&emsp;</div>
<div>6210&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(Key.dumpString(identifierKey, "idKey", 0));</div>
<div>6211&emsp;&emsp;</div>
<div>6212&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // isRoot</div>
<div>6213&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;isRoot val=\"");</div>
<div>6214&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(isRoot());</div>
<div>6215&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\"/>");</div>
<div>6216&emsp;&emsp;</div>
<div>6217&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // level</div>
<div>6218&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;level val=\"");</div>
<div>6219&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(Integer.toHexString(level));</div>
<div>6220&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\"/>");</div>
<div>6221&emsp;&emsp;</div>
<div>6222&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (keyPrefix != null) {</div>
<div>6223&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(Key.dumpString(keyPrefix, "keyPrefix", 0));</div>
<div>6224&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6225&emsp;&emsp;</div>
<div>6226&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        // nEntries, length of entries array</div>
<div>6227&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;entries numEntries=\"");</div>
<div>6228&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(nEntries);</div>
<div>6229&emsp;&emsp;</div>
<div>6230&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\" length=\"");</div>
<div>6231&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(getMaxEntries());</div>
<div>6232&emsp;&emsp;</div>
<div>6233&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        final BIN bin = isBIN() ? (BIN) this : null;</div>
<div>6234&emsp;&emsp;</div>
<div>6235&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (isBINDelta(false)) {</div>
<div>6236&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("\" numFullBinEntries=\"");</div>
<div>6237&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(bin.getFullBinNEntries());</div>
<div>6238&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("\" maxFullBinEntries=\"");</div>
<div>6239&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(bin.getFullBinMaxEntries());</div>
<div>6240&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6241&emsp;&emsp;</div>
<div>6242&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        boolean compactLsnsRep = (entryLsnLongArray == null);</div>
<div>6243&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (compactLsnsRep) {</div>
<div>6244&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("\" baseFileNumber=\"");</div>
<div>6245&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(baseFileNumber);</div>
<div>6246&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6247&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\">");</div>
<div>6248&emsp;&emsp;</div>
<div>6249&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (verbose) {</div>
<div>6250&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            for (int i = 0; i &#60; nEntries; i++) {</div>
<div>6251&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;ref");</div>
<div>6252&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                dumpSlotState(sb, i, bin);</div>
<div>6253&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(">");</div>
<div>6254&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(Key.dumpString(getKey(i), 0));</div>
<div>6255&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                if (isEmbeddedLN(i)) {</div>
<div>6256&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    sb.append(Key.dumpString(getData(i), "data", 0));</div>
<div>6257&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }</div>
<div>6258&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(DbLsn.toString(getLsn(i)));</div>
<div>6259&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;/ref>");</div>
<div>6260&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6261&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6262&emsp;&emsp;</div>
<div>6263&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;/entries>");</div>
<div>6264&emsp;&emsp;</div>
<div>6265&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (isBINDelta(false)) {</div>
<div>6266&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            if (bin.bloomFilter != null) {</div>
<div>6267&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                BINDeltaBloomFilter.dumpLog(bin.bloomFilter, sb, verbose);</div>
<div>6268&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6269&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6270&emsp;&emsp;</div>
<div>6271&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        /* Add on any additional items from subclasses before the end tag. */</div>
<div>6272&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        dumpLogAdditional(sb);</div>
<div>6273&emsp;&emsp;</div>
<div>6274&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(endTag());</div>
<div>6275&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6276&emsp;&emsp;</div>
<div>6277&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6278&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Allows subclasses to add additional fields before the end tag. If they</div>
<div>6279&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * just overload dumpLog, the xml isn't nested.</div>
<div>6280&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6281&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    protected void dumpLogAdditional(StringBuilder sb) {</div>
<div>6282&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6283&emsp;&emsp;</div>
<div>6284&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String beginTag() {</div>
<div>6285&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return BEGIN_TAG;</div>
<div>6286&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6287&emsp;&emsp;</div>
<div>6288&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String endTag() {</div>
<div>6289&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return END_TAG;</div>
<div>6290&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6291&emsp;&emsp;</div>
<div>6292&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6293&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * For unit test support:</div>
<div>6294&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * @return a string that dumps information about this IN, without</div>
<div>6295&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6296&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>6297&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String dumpString(int nSpaces, boolean dumpTags) {</div>
<div>6298&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        StringBuilder sb = new StringBuilder();</div>
<div style="background-color:limegreen;">6299&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (dumpTags) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6300&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces));</div>
<div>6301&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(beginTag());</div>
<div>6302&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append('\n');</div>
<div>6303&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6304&emsp;&emsp;</div>
<div style="background-color:limegreen;">6305&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (dumpTags) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6306&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces));</div>
<div>6307&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("&#60;nodeId val=\"");</div>
<div>6308&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(nodeId);</div>
<div>6309&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("\"/>");</div>
<div>6310&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        } else {</div>
<div>6311&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(nodeId);</div>
<div>6312&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6313&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6314&emsp;&emsp;</div>
<div>6315&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        BIN bin = null;</div>
<div style="background-color:limegreen;">6316&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (isBIN()) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6317&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            bin = (BIN) this;</div>
<div>6318&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6319&emsp;&emsp;</div>
<div>6320&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6321&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;idkey>");</div>
<div style="background-color:limegreen;">6322&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        sb.append(identifierKey == null ?&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6323&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  "" :</div>
<div>6324&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  Key.dumpString(identifierKey, 0));</div>
<div>6325&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;/idkey>");</div>
<div>6326&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6327&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6328&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;prefix>");</div>
<div style="background-color:limegreen;">6329&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        sb.append(keyPrefix == null ? "" : Key.dumpString(keyPrefix, 0));&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6330&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;/prefix>\n");</div>
<div>6331&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6332&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;dirty val=\"").append(getDirty()).append("\"/>");</div>
<div>6333&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6334&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6335&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;level val=\"");</div>
<div>6336&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(Integer.toHexString(level)).append("\"/>");</div>
<div>6337&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6338&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6339&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;isRoot val=\"").append(isRoot()).append("\"/>");</div>
<div>6340&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6341&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6342&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;isBINDelta val=\"").append(isBINDelta(false)).append("\"/>");</div>
<div>6343&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6344&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(</div>
<div>6345&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            "&#60;prohibitNextDelta val=\"").</div>
<div>6346&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            append(getProhibitNextDelta()).append("\"/>");</div>
<div style="background-color:limegreen;">6347&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6348&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6349&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("&#60;cursors val=\"").append(bin.nCursors()).append("\"/>");</div>
<div>6350&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6351&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("&#60;deltas val=\"").append(bin.getNDeltas()).append("\"/>");</div>
<div>6352&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6353&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6354&emsp;&emsp;</div>
<div>6355&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6356&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;entries nEntries=\"");</div>
<div>6357&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(nEntries);</div>
<div>6358&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\">");</div>
<div>6359&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div>6360&emsp;&emsp;</div>
<div style="background-color:limegreen;">6361&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        for (int i = 0; i &#60; nEntries; i++) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6362&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces + 4));</div>
<div>6363&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("&#60;entry id=\"").append(i).append("\"");</div>
<div>6364&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            dumpSlotState(sb, i, bin);</div>
<div>6365&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(">\n");</div>
<div style="background-color:limegreen;">6366&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (getLsn(i) == DbLsn.NULL_LSN) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6367&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(TreeUtils.indent(nSpaces + 6));</div>
<div>6368&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;lsn/>");</div>
<div>6369&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>6370&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(DbLsn.dumpString(getLsn(i), nSpaces + 6));</div>
<div>6371&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6372&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append('\n');</div>
<div style="background-color:limegreen;">6373&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (entryKeys.get(i) == null) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6374&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(TreeUtils.indent(nSpaces + 6));</div>
<div>6375&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;key/>");</div>
<div>6376&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>6377&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(Key.dumpString(entryKeys.get(i), (nSpaces + 6)));</div>
<div>6378&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6379&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append('\n');</div>
<div style="background-color:limegreen;">6380&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (getOffHeapBINId(i) >= 0) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6381&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;ohBIN id=\"").append(i).append("\"");</div>
<div>6382&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(getOffHeapBINId(i)).append(">\n");</div>
<div>6383&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">6384&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (bin != null && bin.getOffHeapLNId(i) != 0) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>6385&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;ohLN id=\"").append(i).append("\"");</div>
<div>6386&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(bin.getOffHeapLNId(i)).append(">\n");</div>
<div>6387&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div style="background-color:limegreen;">6388&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (entryTargets.get(i) == null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6389&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(TreeUtils.indent(nSpaces + 6));</div>
<div>6390&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("&#60;target/>");</div>
<div>6391&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            } else {</div>
<div>6392&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append(entryTargets.get(i).dumpString(nSpaces + 6, true));</div>
<div>6393&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6394&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append('\n');</div>
<div>6395&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces + 4));</div>
<div>6396&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("&#60;/entry>");</div>
<div>6397&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append('\n');</div>
<div>6398&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6399&emsp;&emsp;</div>
<div>6400&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</div>
<div>6401&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("&#60;/entries>");</div>
<div>6402&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append('\n');</div>
<div style="background-color:limegreen;">6403&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (dumpTags) {&nbsp;&#8594; [ALLOWCREATE, TRANSACTIONAL, READONLY]</b></div>
<div>6404&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TreeUtils.indent(nSpaces));</div>
<div>6405&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(endTag());</div>
<div>6406&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6407&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return sb.toString();</div>
<div>6408&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6409&emsp;&emsp;</div>
<div>6410&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void dumpSlotState(StringBuilder sb, int i, BIN bin) {</div>
<div>6411&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append(" kd=\"").append(isEntryKnownDeleted(i));</div>
<div>6412&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\" pd=\"").append(isEntryPendingDeleted(i));</div>
<div>6413&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\" dirty=\"").append(isDirty(i));</div>
<div>6414&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\" embedded=\"").append(isEmbeddedLN(i));</div>
<div>6415&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\" noData=\"").append(isNoDataLN(i));</div>
<div style="background-color:limegreen;">6416&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6417&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("\" logSize=\"");</div>
<div>6418&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(bin.getLastLoggedSizeUnconditional(i));</div>
<div>6419&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            long vlsn = bin.getCachedVLSN(i);</div>
<div style="background-color:limegreen;">6420&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>            if (!VLSN.isNull(vlsn)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6421&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                sb.append("\" vlsn=\"").append(vlsn);</div>
<div>6422&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            }</div>
<div>6423&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div style="background-color:limegreen;">6424&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (bin != null && bin.getExpiration(i) != 0) {&nbsp;&#8594; [ALLOWCREATE, READONLY] & [ALLOWCREATE, READONLY]</b></div>
<div>6425&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append("\" expires=\"");</div>
<div>6426&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TTL.formatExpiration(</div>
<div>6427&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                bin.getExpiration(i), bin.isExpirationInHours()));</div>
<div>6428&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6429&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        sb.append("\"");</div>
<div>6430&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6431&emsp;&emsp;</div>
<div>6432&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    @Override</div>
<div>6433&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String toString() {</div>
<div>6434&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return dumpString(0, true);</div>
<div>6435&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6436&emsp;&emsp;</div>
<div>6437&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public String shortClassName() {</div>
<div>6438&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        return "IN";</div>
<div>6439&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6440&emsp;&emsp;</div>
<div>6441&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6442&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Send trace messages to the java.util.logger. Don't rely on the logger</div>
<div>6443&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * alone to conditionalize whether we send this message, we don't even want</div>
<div>6444&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to construct the message if the level is not enabled.</div>
<div>6445&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6446&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void traceSplit(Level level,</div>
<div>6447&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            IN parent,</div>
<div>6448&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            IN newSibling,</div>
<div>6449&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            long parentLsn,</div>
<div>6450&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            long myNewLsn,</div>
<div>6451&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            long newSiblingLsn,</div>
<div>6452&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            int splitIndex,</div>
<div>6453&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            int idKeyIndex,</div>
<div>6454&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                            int childIndex) {</div>
<div>6455&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Logger logger = getEnv().getLogger();</div>
<div>6456&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        if (logger.isLoggable(level)) {</div>
<div>6457&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            StringBuilder sb = new StringBuilder();</div>
<div>6458&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TRACE_SPLIT);</div>
<div>6459&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" parent=");</div>
<div>6460&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(parent.getNodeId());</div>
<div>6461&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" child=");</div>
<div>6462&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(getNodeId());</div>
<div>6463&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" newSibling=");</div>
<div>6464&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(newSibling.getNodeId());</div>
<div>6465&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" parentLsn = ");</div>
<div>6466&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(DbLsn.getNoFormatString(parentLsn));</div>
<div>6467&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" childLsn = ");</div>
<div>6468&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(DbLsn.getNoFormatString(myNewLsn));</div>
<div>6469&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" newSiblingLsn = ");</div>
<div>6470&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(DbLsn.getNoFormatString(newSiblingLsn));</div>
<div>6471&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" splitIdx=");</div>
<div>6472&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(splitIndex);</div>
<div>6473&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" idKeyIdx=");</div>
<div>6474&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(idKeyIndex);</div>
<div>6475&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" childIdx=");</div>
<div>6476&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(childIndex);</div>
<div>6477&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LoggerUtils.logMsg(logger,</div>
<div>6478&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                               databaseImpl.getEnv(),</div>
<div>6479&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                               level,</div>
<div>6480&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                               sb.toString());</div>
<div>6481&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6482&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6483&emsp;&emsp;</div>
<div>6484&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    /**</div>
<div>6485&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Send trace messages to the java.util.logger. Don't rely on the logger</div>
<div>6486&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * alone to conditionalize whether we send this message, we don't even want</div>
<div>6487&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * to construct the message if the level is not enabled.</div>
<div>6488&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */</div>
<div>6489&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    private void traceDelete(Level level, int index) {</div>
<div>6490&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Logger logger = databaseImpl.getEnv().getLogger();</div>
<div style="background-color:limegreen;">6491&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>        if (logger.isLoggable(level)) {&nbsp;&#8594; [ALLOWCREATE, READONLY]</b></div>
<div>6492&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            StringBuilder sb = new StringBuilder();</div>
<div>6493&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(TRACE_DELETE);</div>
<div>6494&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" in=").append(getNodeId());</div>
<div>6495&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(" index=");</div>
<div>6496&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            sb.append(index);</div>
<div>6497&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            LoggerUtils.logMsg(logger,</div>
<div>6498&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                               databaseImpl.getEnv(),</div>
<div>6499&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                               level,</div>
<div>6500&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                               sb.toString());</div>
<div>6501&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }</div>
<div>6502&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6503&emsp;&emsp;</div>
<div>6504&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    public final void setFetchINHook(TestHook hook) {</div>
<div>6505&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        fetchINHook = hook;</div>
<div>6506&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;    }</div>
<div>6507&emsp;&emsp;}</div>
</div>
</div>
</body>
</html>